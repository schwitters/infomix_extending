/*
** Title:          BWA.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        05/18/1999 17:12
** Description:    This is a generated source file for the BWA DataBlade module.
** Comments:       Generated for project BWA.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "BWA.h"


/* Function prototypes */
UDREXPORT BWA *BWAInput
	(mi_lvarchar *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT mi_lvarchar * BWAOutput
	(BWA *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT mi_sendrecv *BWASend
	(BWA *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT BWA * BWAReceive
	(mi_sendrecv *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT BWA *BWAImportText
	(mi_impexp * Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT mi_impexp *BWAExportText 
	(BWA *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT BWA *BWAImportBinary
	(mi_impexpbin * Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT mi_impexpbin *BWAExportBinary 
	(BWA *Gen_param1, MI_FPARAM *Gen_fparam);

UDREXPORT mi_integer BWACompare
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

UDREXPORT mi_boolean BWAEqual 
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

UDREXPORT mi_boolean BWAGreaterThan
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

UDREXPORT mi_boolean BWAGreaterThanOrEqual
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM * Gen_fparam);

mi_integer lvarchar_to_BWA(mi_lvarchar *bwa_in, BWA *bwa_out);

UDREXPORT mi_boolean BWALessThan
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

UDREXPORT mi_boolean BWALessThanOrEqual
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

UDREXPORT mi_boolean BWANotEqual
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);

/* {{FUNCTION(2028cd81-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWASend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns mi_sendrecv.
**
** Parameters:
**
**	BWA *           Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_sendrecv *                     The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWASend FunctionId: 2028cd81-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_sendrecv *
BWASend
(
BWA *            Gen_param1,       /* The UDT value                      */
MI_FPARAM *      Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con=NULL;     /* The current connection.       */
	BWA *           Gen_OutData=NULL; /* Pointer to the packet data.   */
	mi_sendrecv *   Gen_RetVal;       /* The return value.             */
	mi_integer      i;


	/*
	** Write to the trace file indicating
	** that BWASend has been called.
	*/
	DBDK_TRACE_ENTER( "BWASend" );

	/* The Send function needs to package up the fixed length 
	** BWA in an mi_lvarchar data container (mi_sendrecv is 
	** an mi_lvarchar, under the hood).
	*/

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( BWA ) );
	if( Gen_RetVal == 0 )
	{
		DBDK_TRACE_ERROR( "BWASend", ERRORMESG2, 10 );
		/* not reached */
	}

	/* Point to the output data container. */
	Gen_OutData = (BWA *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Copy each element in the boolean array to the output packet.
	**
	** mi_put_bytes() parameters are:
	**
	**	to (target data), from (source data), number of bytes
	*/
	for( i=0; i < 4; i++)
	{
		mi_put_bytes( (mi_unsigned_char1 *)&Gen_OutData->nulls[i], 
			(char *)&Gen_param1->nulls[i], 1 );
	}

	/* Copy each BWA part into the output packet */
	mi_put_bytes((mi_unsigned_char1 *)Gen_OutData->category, 
		(char *)Gen_param1->category, BWA_PART_SIZE + 1 );
	
	mi_put_bytes( (mi_unsigned_char1 *)Gen_OutData->family, 
		(char *)Gen_param1->family, BWA_PART_SIZE + 1 );
	
	mi_put_bytes( (mi_unsigned_char1 *)Gen_OutData->group, 
		(char *)Gen_param1->group, BWA_PART_SIZE + 1 );
	
	mi_put_bytes( (mi_unsigned_char1 *)Gen_OutData->identity, 
		(char *)Gen_param1->identity, BWA_PART_SIZE + 1 );

	/*
	** Write to the trace file indicating
	** that BWASend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWASend" );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* }}FUNCTION (#79SU) */



/* {{FUNCTION(2028cd82-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns BWA.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	BWA *                             The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAReceive FunctionId: 2028cd82-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
BWA *
BWAReceive
(
mi_sendrecv *           Gen_param1,    /* The UDT value.                */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con=NULL;     /* The current connection.    */
	BWA *           Gen_RetVal=NULL;  /* The return value.          */
	BWA *           Gen_InData=NULL;  /* Pointer to Packet data.    */
	mi_integer      i;

	/*
	** Write to the trace file indicating
	** that BWAReceive has been called.
	*/
	DBDK_TRACE_ENTER( "BWAReceive" );

	/* The Receive function needs to unpackage a BWA from
	** the input mi_lvarchar (mi_sendrecv is an mi_lvarchar, 
	** under the hood) and return the opaque type.
	*/

	/* Point to the input data. */
	Gen_InData = (BWA *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Allocate room for the UDT return value. */
	Gen_RetVal = (BWA *)mi_zalloc( sizeof( BWA ) );
	if( Gen_RetVal == 0 )
	{
		DBDK_TRACE_ERROR( "BWAReceive", ERRORMESG2, 10 );
		/* not reached */
	}

	/* Copy each element of the boolean array. 
	**
	** mi_get_bytes() parameters are:
	**
	**	from (source data), to (target data), number of bytes
	*/

	for( i=0; i < 4; i++)
	{
		mi_get_bytes( (mi_unsigned_char1 *)&Gen_InData->nulls[i], 
			(char *)&Gen_RetVal->nulls[i], 1 );
	}
	
	/* Copy each part from the output packet */
	mi_get_bytes( (mi_unsigned_char1 *)Gen_InData->category, 
			(char *)Gen_RetVal->category, BWA_PART_SIZE + 1 );
	
	mi_get_bytes( (mi_unsigned_char1 *)Gen_InData->family, 
			(char *)Gen_RetVal->family, BWA_PART_SIZE + 1 );

	mi_get_bytes( (mi_unsigned_char1 *)Gen_InData->group, 
			(char *)Gen_RetVal->group, BWA_PART_SIZE + 1 );

	mi_get_bytes( (mi_unsigned_char1 *)Gen_InData->identity, 
			(char *)Gen_RetVal->identity, BWA_PART_SIZE + 1 );

	/*
	** Write to the trace file indicating
	** that BWAReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWAReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#MSQC) */



/* {{FUNCTION(2028cd87-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns BWA.
**
** Parameters:
**
**	mi_bitvarying *                   Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	BWA *                             The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAImportBinary FunctionId: 2028cd87-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
BWA *
BWAImportBinary
(
mi_impexpbin * Gen_param1,       /* The input value.                   */
MI_FPARAM    * Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* This does the same thing as the Receive routine */
	return BWAReceive ((mi_sendrecv *) Gen_param1, Gen_fparam);

}
/* }}FUNCTION (#VD62) */



/* {{FUNCTION(2028cd88-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns mi_bitvarying.
**
** Parameters:
**
**	BWA *           Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_bitvarying *                                 The exported UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAExportBinary FunctionId: 2028cd88-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_impexpbin *
BWAExportBinary
(
BWA *              Gen_param1,       /* The UDT value.                  */
MI_FPARAM *        Gen_fparam        /* Standard info - see DBDK docs.  */
)
{
	/* This does the same thing as the Send routine */
	return ( (mi_impexpbin *) BWASend (Gen_param1, Gen_fparam) );
		
}
/* }}FUNCTION (#R52P) */



/* {{FUNCTION(2028cd89-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWACompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
**	This function returns the following values:
**	
**		-1  if arg1 < arg2
**		 0  if arg1 = arg2
**		 1  if arg1 > arg2
**
** Special Comments:
**
**	Compares two fixed-sized opaque types
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWACompare FunctionId: 2028cd89-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_integer
BWACompare
(
BWA *          Gen_param1,       /* The first UDT value to compare.    */
BWA *          Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *    Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION	*Gen_Con=NULL;
	mi_integer	status,
			Gen_RetVal;

	/*
	** Write to the trace file indicating
	** that BWACompare has been called.
	*/
	DBDK_TRACE_ENTER( "BWACompare" );

	/* The btree rules for Compare() are:
	**	if arg1 < arg2, return -1
    	**	if arg1 = arg2, return 0
    	**	if arg1 > arg2, return 1
	**
	** We start left and move right through the 4 parts.
	** We only need to check all parts if all leading parts
	** are the same.
	**
	** Only perform the comparison if both parts are not null.
	*/

	/* ======================= category =================== */
	if (Gen_param1->nulls[0]==MI_TRUE && Gen_param2->nulls[0]==MI_TRUE)
		Gen_RetVal = 0;
	else if 
		(Gen_param1->nulls[0]==MI_FALSE && Gen_param2->nulls[0]==MI_TRUE)
		Gen_RetVal = 1;
	else if 
		(Gen_param1->nulls[0]==MI_TRUE && Gen_param2->nulls[0]==MI_FALSE)
		Gen_RetVal = -1;
	else if 
		(Gen_param1->nulls[0]==MI_FALSE && Gen_param2->nulls[0]==MI_FALSE)
	{
#ifndef WIN32
		status = strcasecmp(Gen_param1->category, Gen_param2->category);
#else
		status = stricmp(Gen_param1->category, Gen_param2->category);
#endif

		if (status > 0)
			Gen_RetVal = 1;
		else if (status < 0)
			Gen_RetVal = -1;
		else
			Gen_RetVal = 0;
	} /* END category */

	/* If the categories are equal, go on to family */
	if (Gen_RetVal == 0)
	{

	if (Gen_param1->nulls[1]==MI_TRUE && Gen_param2->nulls[1]==MI_TRUE)
		Gen_RetVal = 0;
	else if 
		(Gen_param1->nulls[1]==MI_FALSE && Gen_param2->nulls[1]==MI_TRUE)
		Gen_RetVal = 1;
	else if 
		(Gen_param1->nulls[1]==MI_TRUE && Gen_param2->nulls[1]==MI_FALSE)
		Gen_RetVal = -1;
	else if 
		(Gen_param1->nulls[1]==MI_FALSE && Gen_param2->nulls[1]==MI_FALSE)
	{
#ifndef WIN32
		status = strcasecmp(Gen_param1->family, Gen_param2->family);
#else
		status = stricmp(Gen_param1->family, Gen_param2->family);
#endif
		if (status > 0)
			Gen_RetVal = 1;
		else if (status < 0)
			Gen_RetVal = -1;
		else
			Gen_RetVal = 0;
	}
	}	/* END family */

	/* If categories and families are equal, go on to group */
	if (Gen_RetVal == 0)
	{
	if (Gen_param1->nulls[2]==MI_TRUE && Gen_param2->nulls[2]==MI_TRUE)
		Gen_RetVal = 0;
	else if 
		(Gen_param1->nulls[2]==MI_FALSE && Gen_param2->nulls[2]==MI_TRUE)
		Gen_RetVal = 1;
	else if 
		(Gen_param1->nulls[2]==MI_TRUE && Gen_param2->nulls[2]==MI_FALSE)
		Gen_RetVal = -1;
	else if 
		(Gen_param1->nulls[2]==MI_FALSE && Gen_param2->nulls[2]==MI_FALSE)
	{
#ifndef WIN32
		status = strcasecmp(Gen_param1->group, Gen_param2->group);
#else
		status = stricmp(Gen_param1->group, Gen_param2->group);
#endif
		if (status > 0)
			Gen_RetVal = 1;
		else if (status < 0)
			Gen_RetVal = -1;
		else
			Gen_RetVal = 0;
	}	/* END group */
	}

	/* If categories, families, and groups are equal, go on to identity */
	if (Gen_RetVal == 0)
	{
	if (Gen_param1->nulls[3]==MI_TRUE && Gen_param2->nulls[3]==MI_TRUE)
		Gen_RetVal = 0;
	else if 
		(Gen_param1->nulls[3]==MI_FALSE && Gen_param2->nulls[3]==MI_TRUE)
		Gen_RetVal = 1;
	else if 
		(Gen_param1->nulls[3]==MI_TRUE && Gen_param2->nulls[3]==MI_FALSE)
		Gen_RetVal = -1;
	else if 
		(Gen_param1->nulls[3]==MI_FALSE && Gen_param2->nulls[3]==MI_FALSE)
	{
#ifndef WIN32
		status = strcasecmp(Gen_param1->identity, Gen_param2->identity);
#else
		status = stricmp(Gen_param1->identity, Gen_param2->identity);
#endif
		if (status > 0)
			Gen_RetVal = 1;
		else if (status < 0)
			Gen_RetVal = -1;
		else
			Gen_RetVal = 0;
	}
	}	/* END Identity */

	/*
	** Write to the trace file indicating
	** that BWACompare has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWACompare" );

	return Gen_RetVal;
}
/* }}FUNCTION (#JUS3) */



/* {{FUNCTION(2028cd8a-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types for equality
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAEqual FunctionId: 2028cd8a-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWAEqual
(
BWA *         Gen_param1,       /* The first UDT value to compare.    */
BWA *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *   Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == BWACompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#63N0) */



/* {{FUNCTION(2028cd8c-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWALessThan
**
** Description:
**
**	Determine if one UDT value is less than another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWALessThan FunctionId: 2028cd8c-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWALessThan
(
BWA *           Gen_param1,       /* The first UDT value to compare.    */
BWA *           Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *     Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 == BWACompare(
			Gen_param1, Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#OP7B) */



/* {{FUNCTION(2028cd8e-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWALessThanOrEqual
**
** Description:
**
**	Determine if one UDT value is less than or equal to another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWALessThanOrEqual FunctionId: 2028cd8e-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWALessThanOrEqual
(
BWA *          Gen_param1,       /* The first UDT value to compare.    */
BWA *          Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *    Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 > BWACompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#437J) */



/* {{FUNCTION(2028cd8d-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAGreaterThan
**
** Description:
**
**	Determine if one UDT value is greater than another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAGreaterThan FunctionId: 2028cd8d-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWAGreaterThan
(
BWA *          Gen_param1,       /* The first UDT value to compare.    */
BWA *          Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *    Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 == BWACompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#IDMC) */



/* {{FUNCTION(2028cd8f-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAGreaterThanOrEqual
**
** Description:
**
**	Determine if one UDT value is greater than or equal to another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAGreaterThanOrEqual FunctionId: 2028cd8f-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWAGreaterThanOrEqual
(
BWA *          Gen_param1,       /* The first UDT value to compare.    */
BWA *          Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *    Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 < BWACompare( Gen_param1,
			Gen_param2, Gen_fparam ) );
}
/* }}FUNCTION (#U9QQ) */



/* {{FUNCTION(2028cd8b-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWANotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Compares two fixed-sized opaque types for non-equality
**
** Parameters:
**
**	BWA *           Gen_param1;       The first UDT value to compare.
**	BWA *           Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWANotEqual FunctionId: 2028cd8b-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_boolean
BWANotEqual
(
BWA *          Gen_param1,       /* The first UDT value to compare.    */
BWA *          Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *    Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != BWACompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#QTUL) */



/* {{FUNCTION(2028cd85-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns BWA.
**
** Parameters:
**
**	mi_impexp *     Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	BWA *                             The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAImportText FunctionId: 2028cd85-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
BWA *
BWAImportText
(
mi_impexp *    Gen_param1,  /* The import text.                       */
MI_FPARAM *    Gen_fparam   /* Standard info - see DBDK docs.         */
)
{
	/* This routine does the same thing as the Input routine */

	return BWAInput ( (mi_lvarchar *) Gen_param1, Gen_fparam );
}
/* }}FUNCTION (#LG5D) */



/* {{FUNCTION(2028cd86-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type BWA returns mi_impexp.
**
** Parameters:
**
**	BWA *           Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_impexp *                       The exported UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAExportText FunctionId: 2028cd86-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_impexp *
BWAExportText
(
BWA *        Gen_param1,       /* The UDT value.                     */
MI_FPARAM *  Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* This does the same thing as the Output routine */
	return ( (mi_impexp *) BWAOutput (Gen_param1, Gen_fparam) );
}
/* }}FUNCTION (#K5TI) */



/* {{FUNCTION(2028cd83-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type BWA to its internal representation.   
**
** Special Comments:
**
**	Support routine for opaque type BWA returns BWA.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	BWA *                             The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAInput FunctionId: 2028cd83-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
BWA *
BWAInput
(
mi_lvarchar *    Gen_param1,     /* Pointer to the input text.      */
MI_FPARAM *      Gen_fparam      /* Standard info - see DBDK docs.  */
)
{
	MI_CONNECTION * Gen_Con=NULL;      /* The current connection.  */
	BWA *           Gen_RetVal=NULL;   /* The return value.        */
	mi_integer	num_parts;

	/*
	** Write to the trace file indicating
	** that BWAInput has been called.
	*/
	DBDK_TRACE_ENTER( "BWAInput" );

	/* Allocate a new UDT for the return result. 
	**
	** Since it is a fixed-size data structure, we can optimize
	** input by allocating the return value just the first
	** time the UDR is invoked in a query, then re-use that
	** allocated memory. To cache the return, we need to do this:
	**
	**	- detect the first UDR invocation
	**	- allocate the return value with a PER_COMMAND duration
	**	- store a pointer to the allocated memory in the MI_FPARAM
	**
	** The "Memory Allocation for UDRs" tech note on the IDN
	** DataBlade Corner (http://www.informix.com/idn) provides
	** specific details on memory management.
	*/

	/* Fetch our pointer from the MI_FPARAM. If this is the first
	** invocation, it will be NULL.
	*/
	Gen_RetVal = (BWA *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (BWA *) NULL)
	{
		/* It's time for us to allocate the return value */
		Gen_RetVal = (BWA *)mi_dalloc( sizeof( BWA ), PER_COMMAND );
		if( Gen_RetVal == 0 )
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in BWAInput."
			*/
			DBDK_TRACE_ERROR( "BWAInput", ERRORMESG2, 10 );
			/* not reached */
		}

		/* Store the pointer to the allocated memory in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);
	}

	/* Initialize all parts to NULL */
	Gen_RetVal->nulls[0] = MI_TRUE;
	Gen_RetVal->nulls[1] = MI_TRUE;
	Gen_RetVal->nulls[2] = MI_TRUE;
	Gen_RetVal->nulls[3] = MI_TRUE;

	/* Call lvarchar_to_BWA to fill in the BWA structure */
	num_parts = lvarchar_to_BWA(Gen_param1, Gen_RetVal);

	/*
	** Write to the trace file indicating
	** that BWAInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWAInput" );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#AB41) */


mi_integer
lvarchar_to_BWA(mi_lvarchar *bwa_in, BWA *Gen_OutData)
{
	
	mi_string	*Gen_InData=NULL, 
			*p=NULL,
			*r="lvarchar_to_BWA";
	mi_integer	Gen_InData_len,	/* length of the input BWA */
			i,		/* loop counter */
			part_length,	/* strcspn return value */
			num_dots=0;	/* this must be 3 */

	/* The data container in the mi_lvarchar is never null
	** terminated, so we can't just pass a pointer to it to 
	** functions that expect a null-terminated string. Instead,
	** we need to access it based on the length stored in the
	** mi_lvarchar.
	**
	** Now, we could create a null-terminated string like this:
	**
	**	Gen_InData = mi_lvarchar_to_string (bwa_in);
	**
	** But performance will be better if we can avoid making yet 
	** another copy of the input data. So we're going get a pointer 
	** to the data container using mi_get_vardata(), then manage the 
	** access to it based on the length returned by mi_get_varlen().
	*/
	Gen_InData = mi_get_vardata(bwa_in);
	Gen_InData_len = mi_get_varlen(bwa_in);

	/* Parse the input text.
	**
	** Here's the format:
	**
	**	category.family.group.identity
	**
	** The "dot" is the field delimiter. Any field can be
	** empty (NULL) and the nulls array keeps track of which
	** fields are not NULL (MI_FALSE) and which fields are
	** NULL (MI_TRUE).
	*/

	/* Find out up front how many parts we have. */
	for(p=Gen_InData, i=0; i < Gen_InData_len; p++, i++)
	{
		if(p[0] == '.')
			num_dots++;
	}
	if(num_dots != 3)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA1",
			"UDR_NAME%s",	r, 
			"NUM_PARTS%d",	num_dots+1,
			(mi_integer) NULL);

		return MI_ERROR;	/* not reached */
	}

	p=Gen_InData; /* reset back to the beginning of the input text */
	i=0;

	/* ================== Get Category ================== */

	/* Use strcspn(), which is available on both UNIX and NT,
	** to find out how many characters there are before the
	** first dot. If a dot is the first character, strcspn() 
	** returns 0.
	*/
	part_length = strcspn(p, BWA_PART_DELIMITER);

	if(part_length == 0)
	{
		Gen_OutData->nulls[0] = MI_TRUE;
	}
	else if (part_length > BWA_PART_SIZE)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA0",
			"UDR_NAME%s",	r,
			"LENGTH%d",	part_length,
			"PART_NAME%s",	"Category",
			"MAX_LENGTH%d",	BWA_PART_SIZE,
			(mi_integer) NULL);
	}
	else
	{
		Gen_OutData->nulls[0] = MI_FALSE;
		memcpy(Gen_OutData->category, p, part_length);
		Gen_OutData->category[part_length]='\0';
		i += part_length;
	}
	i++; /* move past the dot */
	p = Gen_InData + i;

	/* ================== Get Family ================== */
	part_length = strcspn(p, BWA_PART_DELIMITER);

	if(part_length == 0)
	{
		Gen_OutData->nulls[1] = MI_TRUE;
	}
	else if (part_length > BWA_PART_SIZE)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA0",
			"UDR_NAME%s",	r,
			"LENGTH%d",	part_length,
			"PART_NAME%s",	"Family",
			"MAX_LENGTH%d",	BWA_PART_SIZE,
			(mi_integer) NULL);
	}
	else
	{
		Gen_OutData->nulls[1] = MI_FALSE;
		memcpy(Gen_OutData->family, p, part_length);
		Gen_OutData->family[part_length]='\0';
		i += part_length;
	}
	i++; /* move past the dot */
	p = Gen_InData + i;

	/* ================== Get Group ================== */
	part_length = strcspn(p, BWA_PART_DELIMITER);

	if(part_length == 0)
	{
		Gen_OutData->nulls[2] = MI_TRUE;
	}
	else if (part_length > BWA_PART_SIZE)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA0",
			"UDR_NAME%s",	r,
			"LENGTH%d",	part_length,
			"PART_NAME%s",	"Group",
			"MAX_LENGTH%d",	BWA_PART_SIZE,
			(mi_integer) NULL);
	}
	else
	{
		Gen_OutData->nulls[2] = MI_FALSE;
		memcpy(Gen_OutData->group, p, part_length);
		Gen_OutData->group[part_length]='\0';
		i += part_length;
	}
	i++; /* move past the dot */
	p = Gen_InData + i;

	/* ================== Get Identity ================== */
	/* Everything left is the last part */

	part_length = Gen_InData_len - i;

	if(part_length == 0)
	{
		Gen_OutData->nulls[3] = MI_TRUE;
	}
	else if (part_length > BWA_PART_SIZE)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA0",
			"UDR_NAME%s",	r,
			"LENGTH%d",	part_length,
			"PART_NAME%s",	"Identity",
			"MAX_LENGTH%d",	BWA_PART_SIZE,
			(mi_integer) NULL);
	}
	else
	{
		Gen_OutData->nulls[3] = MI_FALSE;
		memcpy(Gen_OutData->identity, p, part_length);
		Gen_OutData->identity[part_length]='\0';
	}

	return num_dots;
}

/* {{FUNCTION(2028cd84-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type BWA to its external representation.   
**
**	Data can be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type BWA returns mi_lvarchar.
**
** Parameters:
**
**	BWA *           Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                     The constructed UDT value.
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    BWAOutput FunctionId: 2028cd84-0a3d-11d3-984d-000000000000
**
********************************************************************************
*/

UDREXPORT
mi_lvarchar *
BWAOutput
(
BWA *          Gen_param1,     /* The UDT value.                     */
MI_FPARAM *    Gen_fparam      /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con=NULL;       /* The current connection.  */
	mi_lvarchar *   Gen_RetVal=NULL;    /* The return result.       */
	mi_string		tempbuf[136];
	mi_integer		size;
	MI_MEMORY_DURATION dur;

	/*
	** Write to the trace file indicating
	** that BWAOutput has been called.
	*/
	DBDK_TRACE_ENTER( "BWAOutput" );

	/* Allocate the return result. 
	**
	** Optimize output by allocating the return value just 
	** the first time the UDR is invoked in a query, then 
	** re-use that allocated memory. To cache the return 
	** value, we need to do the following:
	**
	**	- Detect the first UDR invocation
	**	- Allocate the return value with a PER_COMMAND duration.
	**	  The allocation size should be the largest that could 
	**	  ever be needed: "category.family.group.identity".
	**		4 x 32 + 3 dots = 131
	**	- store a pointer to the allocated memory in the MI_FPARAM
	**	- Each invocation needs to then set the accurate size
	**	  for that return value using mi_set_varlen.
	**	  And it needs to tell the routine manager how large
	**	  the return value is by calling mi_fp_setretlen.
	**
	** The "Memory Allocation for UDRs" tech note on the IDN
	** DataBlade Corner (http://www.informix.com/idn) provides
	** specific details on memory management.
	*/

	/* Fetch our pointer from the MI_FPARAM. If this is the first
	** invocation, it will be NULL.
	*/
	Gen_RetVal = (mi_lvarchar *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (mi_lvarchar *) NULL)
	{
		/* It's time for us to allocate the return value.
		** Four parts, 3 dots + 1 to round up to an even number.
		*/
		size = (BWA_PART_SIZE * 4) + 4;

		/* We need to allocate the memory with a PER_COMMAND duration */
		dur = mi_switch_mem_duration(PER_COMMAND);

		Gen_RetVal = mi_new_var(size);
		if( Gen_RetVal == 0 )
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in BWAInput."
			*/
			DBDK_TRACE_ERROR( "BWAOutput", ERRORMESG2, 10 );
			/* not reached */
		}
		/* Store the pointer in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);

		/* Restore the previous memory duration */
		(void) mi_switch_mem_duration(dur);
	}

	/* Build up the return text in the temporary buffer */
	memset(tempbuf, '\0', sizeof(tempbuf));

	if (Gen_param1->nulls[0] == MI_TRUE)
		sprintf(tempbuf, ".");
	else
		sprintf(tempbuf, "%s.", Gen_param1->category);

	if (Gen_param1->nulls[1] == MI_TRUE)
		sprintf(tempbuf, "%s.", tempbuf);
	else
		sprintf(tempbuf, "%s%s.", tempbuf, Gen_param1->family);

	if (Gen_param1->nulls[2] == MI_TRUE)
		sprintf(tempbuf, "%s.", tempbuf);
	else
		sprintf(tempbuf, "%s%s.", tempbuf, Gen_param1->group);

	if (Gen_param1->nulls[3] == MI_FALSE)
		sprintf(tempbuf, "%s%s", tempbuf, Gen_param1->identity);

	/* Determine the size of the resulting text. */
	size = strlen(tempbuf);

	/* Set this size in two places:
	**	- mi_lvarchar
	**	- MI_FPARAM return value size
	*/
	mi_set_varlen(Gen_RetVal, size);
	mi_fp_setretlen(Gen_fparam, 0, size);

	/* Copy the data from tempbuf into the mi_lvarchar.
	**
	** It is EXTREMELY important that the size first be set
	** in the mi_lvarchar with mi_set_varlen because that's how 
	** the server figures out how many bytes to copy from the 
	** temp buffer into the mi_lvarchar.
	*/
	mi_set_vardata (Gen_RetVal, tempbuf);

	/*
	** Write to the trace file indicating
	** that BWAOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWAOutput" );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#UI5G) */



#ifdef __cplusplus

}

#endif
