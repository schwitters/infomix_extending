/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        05/18/1999 17:12
** Description:    This is a generated source file for the BWA DataBlade module.
** Comments:       Generated for project BWA.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <limits.h> 

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>
#include <minmmem.h>

/* This is the project include file. */
#include "BWA.h"

/* Function prototypes used by this file */

UDREXPORT mi_integer BWACompare
	(BWA *Gen_param1, BWA *Gen_param2, MI_FPARAM *Gen_fparam);
UDREXPORT mi_lvarchar *BWAGroup
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_lvarchar *BWACategory
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_lvarchar *BWAFamily
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_lvarchar *BWAIdentity
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_integer BWAContains
	(BWA *bwa_in1, BWA *bwa_in2, MI_FPARAM *Gen_fparam);
UDREXPORT mi_integer BWAEmpty
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_integer BWANotEmpty
	(BWA *bwa_in, MI_FPARAM *Gen_fparam);
UDREXPORT mi_integer BWANotEmptyPart
	(BWA *bwa_in, mi_integer part_num, MI_FPARAM *Gen_fparam);
UDREXPORT mi_integer BWAEmptyPart
	(BWA *bwa_in, mi_integer part_num, MI_FPARAM *Gen_fparam);

/* {{FUNCTION(2028cd96-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	Group
**
** Description:
**	Extracts the "Group" field from a BWA.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Group (BWA) returns varchar (32).
**
** Parameters:
	BWA	Input BWA
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *BWAGroup
(
BWA *                   bwa_in,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_lvarchar*    Gen_RetVal=NULL;       /* The return value. */
	MI_CONNECTION * Gen_Con=NULL;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer		size;
	MI_MEMORY_DURATION dur;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Group has been called.
	*/
	DBDK_TRACE_ENTER( "Group" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Allocate the return value just the first time the UDR
	** is invoked in a query, cache it in the MI_FPARAM, and 
	** re-use it on subsequent invocations.
	**
	**	- Detect the first UDR invocation
	**	- Allocate the return value with a PER_COMMAND duration.
	**	  The allocation size should be the largest that could 
	**        ever be needed (32 characters).
	**	- Store a pointer to the allocated memory in the MI_FPARAM
	**	- Each invocation needs to then set the accurate size
	**	  for that return value using mi_set_varlen for the
	**	  lvarchar and mi_fp_setretlen for the MI_FPARAM.
	**
	** The "Memory Allocation for UDRs" tech note on the IDN
	** DataBlade Corner (http://www.informix.com/idn) for info
	** on memory management.
	*/

	/* Fetch our pointer from the MI_FPARAM. If this is the first
	** invocation, it will be NULL.
	*/
	Gen_RetVal = (mi_lvarchar *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (mi_lvarchar *) NULL)
	{
		/* It's time for us to allocate it.*/
		size = BWA_PART_SIZE;

		/* We need to allocate the memory with a PER_COMMAND duration */
		dur = mi_switch_mem_duration(PER_COMMAND);

		Gen_RetVal = mi_new_var(size);
		if( Gen_RetVal == 0 )
		{
			DBDK_TRACE_ERROR( "BWAGroup", ERRORMESG2, 10 );
			/* not reached */
		}

		/* Store the pointer in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);

		/* Restore the previous memory duration */
		(void) mi_switch_mem_duration(dur);
	}

	/* If the value is not filled in, return SQL NULL */
	if (bwa_in->nulls[2] == MI_TRUE)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	}
	else
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE);

		/* Determine the size of the return text. */
		size = strlen(bwa_in->group);

		/* Set this size in the output mi_lvarchar
		** and for the MI_FPARAM return value.
		*/
		mi_set_varlen(Gen_RetVal, size);
		mi_fp_setretlen(Gen_fparam, 0, size);

		/* Copy the data from the BWA into the mi_lvarchar.
		**
		** It is EXTREMELY important that the size first be set
		** in the mi_lvarchar with mi_set_varlen because that's how 
		** the server figures out how many bytes to copy from the 
		** temp buffer into the mi_lvarchar.
		*/
		mi_set_vardata (Gen_RetVal, bwa_in->group);
	}
	/* ------ }}Your_Code (#Q1PA) END ------ */

	/*
	** Write to the trace file indicating
	** that Group has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Group" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#O03F) */




/* {{FUNCTION(2028cd94-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	Category
**
** Description:
**	Extracts the "Category" field from a BWA.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Category (BWA) returns varchar (32).
**
** Parameters:
**	BWA	The input BWA
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *BWACategory
(
BWA *                   bwa_in,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_lvarchar*    Gen_RetVal=NULL;  /* The return value. */
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer		size;
	MI_MEMORY_DURATION dur;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Category has been called.
	*/
	DBDK_TRACE_ENTER( "Category" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Allocate the return result. 
	**
	** Optimize output by allocating the return value just 
	** the first time the UDR is invoked in a query, then 
	** re-use that allocated memory. To cache the return, 
	** we need to do this:
	**
	**	- Detect the first UDR invocation
	**	- Allocate the return value with a PER_COMMAND duration.
	**	  The allocation size should be the largest that could 
	**        ever be needed (32 characters).
	**	- store a pointer to the allocated memory in the MI_FPARAM
	**	- Each invocation needs to then set the accurate size
	**	  for that return value using mi_set_varlen/mi_fp_setretlen.
	**
	** The "Memory Allocation for UDRs" tech note on the IDN
	** DataBlade Corner (http://www.informix.com/idn) provides
	** specific details on memory management.
	*/

	/* Fetch our pointer from the MI_FPARAM. If this is the first
	** invocation, it will be NULL.
	*/
	Gen_RetVal = (mi_lvarchar *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (mi_lvarchar *) NULL)
	{
		/* It's time for us to allocate it.*/
		size = BWA_PART_SIZE;

		/* We need to allocate the memory with a PER_COMMAND duration */
		dur = mi_switch_mem_duration(PER_COMMAND);

		Gen_RetVal = mi_new_var(size);
		if( Gen_RetVal == 0 )
		{
			DBDK_TRACE_ERROR( "BWACategory", ERRORMESG2, 10 );
			/* not reached */
		}
		/* Store the pointer in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);

		/* Restore the previous memory duration */
		(void) mi_switch_mem_duration(dur);
	}

	/* If the value is not filled in, return SQL NULL */
	if (bwa_in->nulls[0] == MI_TRUE)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	}
	else
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE);

		/* Determine the size of the return text. */
		size = strlen(bwa_in->category);

		/* Set this size in the mi_lvarchar and MI_FPARAM. */
		mi_set_varlen(Gen_RetVal, size);
		mi_fp_setretlen(Gen_fparam, 0, size);

		/* Copy the data from the BWA into the mi_lvarchar.
		**
		** It is EXTREMELY important that the size first be set
		** in the mi_lvarchar with mi_set_varlen because that's how 
		** the server figures out how many bytes to copy from the 
		** temp buffer into the mi_lvarchar.
		*/
		mi_set_vardata (Gen_RetVal, bwa_in->category);
	}

	/* ------ }}Your_Code (#JECS) END ------ */

	/*
	** Write to the trace file indicating
	** that Category has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Category" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#AFSO) */




/* {{FUNCTION(2028cd95-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	Family
**
** Description:
**	Extract the "Family" field from a BWA.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Family (BWA) returns varchar (32).
**
** Parameters:
**	BWA	The input BWA
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *BWAFamily
(
BWA *                   bwa_in,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_lvarchar*    Gen_RetVal=NULL;  /* The return value. */
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer		size;
	MI_MEMORY_DURATION dur;
	/* ------ }}Your_Declarations (#0000) END ------ */
	/*
	** Write to the trace file indicating
	** that Family has been called.
	*/
	DBDK_TRACE_ENTER( "Family" );


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Allocate the return value just the first time the UDR
	** is invoked in a query, cache it in the MI_FPARAM, and 
	** re-use it on subsequent invocations.
	**
	**	- Detect the first UDR invocation
	**	- Allocate the return value with a PER_COMMAND duration.
	**	  The allocation size should be the largest that could 
	**        ever be needed (32 characters).
	**	- Store a pointer to the allocated memory in the MI_FPARAM
	**	- Each invocation needs to then set the accurate size
	**	  for that return value using mi_set_varlen/mi_fp_setretlen.
	**
	** The "Memory Allocation for UDRs" tech note on the IDN
	** DataBlade Corner (http://www.informix.com/idn) for info
	** on memory management.
	*/

	/* Fetch our pointer from the MI_FPARAM. If this is the first
	** invocation, it will be NULL.
	*/
	Gen_RetVal = (mi_lvarchar *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (mi_lvarchar *) NULL)
	{
		/* It's time for us to allocate it.	*/
		size = BWA_PART_SIZE;

		/* We need to allocate the memory with a PER_COMMAND duration */
		dur = mi_switch_mem_duration(PER_COMMAND);

		Gen_RetVal = mi_new_var(size);
		if( Gen_RetVal == 0 )
		{
			DBDK_TRACE_ERROR( "BWAFamily", ERRORMESG2, 10 );
			/* not reached */
		}
		/* Store the pointer in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);

		/* Restore the previous memory duration */
		(void) mi_switch_mem_duration(dur);
	}

	/* If the value is not filled in, return SQL NULL */
	if (bwa_in->nulls[1] == MI_TRUE)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	}
	else
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE);

		/* Determine the size of the return text. */
		size = strlen(bwa_in->family);

		/* Set this size in the mi_lvarchar and MI_FPARAM. */
		mi_set_varlen(Gen_RetVal, size);
		mi_fp_setretlen(Gen_fparam, 0, size);

		/* Copy the data from the BWA into the mi_lvarchar.
		**
		** It is EXTREMELY important that the size first be set
		** in the mi_lvarchar with mi_set_varlen because that's how 
		** the server figures out how many bytes to copy from the 
		** temp buffer into the mi_lvarchar.
		*/
		mi_set_vardata (Gen_RetVal, bwa_in->family);
	}

	/* ------ }}Your_Code (#77NM) END ------ */

	/*
	** Write to the trace file indicating
	** that Family has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Family" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#ON3B) */




/* {{FUNCTION(2028cd97-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	Identity
**
** Description:
**	Extract the "Identity" field from a BWA.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Identity (BWA) returns varchar (32).
**
** Parameters:
**	BWA	The input BWA.
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *BWAIdentity
(
BWA *                   bwa_in,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_lvarchar*    Gen_RetVal=NULL;       /* The return value. */
	MI_CONNECTION * Gen_Con=NULL;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer		size;
	MI_MEMORY_DURATION dur;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Identity has been called.
	*/
	DBDK_TRACE_ENTER( "Identity" );


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Allocate the return value just the first time the UDR
	** is invoked in a query, cache it in the MI_FPARAM, then 
	** re-use it on subsequent invocations.
	**
	** BWACategory has the long explanation.
	*/

	/* Fetch our pointer from the MI_FPARAM. */
	Gen_RetVal = (mi_lvarchar *) mi_fp_funcstate(Gen_fparam);

	if(Gen_RetVal == (mi_lvarchar *) NULL)
	{
		/* First invocation -- it's time for us to allocate it.*/
		size = BWA_PART_SIZE;

		/* We need to allocate the memory with a PER_COMMAND duration */
		dur = mi_switch_mem_duration(PER_COMMAND);

		Gen_RetVal = mi_new_var(size);
		if( Gen_RetVal == 0 )
		{
			DBDK_TRACE_ERROR( "BWAIdentity", ERRORMESG2, 10 );
			/* not reached */
		}
		/* Store the pointer in the MI_FPARAM */
        	mi_fp_setfuncstate(Gen_fparam, (void *) Gen_RetVal);

		/* Restore the previous memory duration */
		(void) mi_switch_mem_duration(dur);
	}

	/* If the value is not filled in, return SQL NULL */
	if (bwa_in->nulls[3] == MI_TRUE)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	}
	else
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE);

		/* Determine the size of the return text. */
		size = strlen(bwa_in->identity);

		/* Set this size in the mi_lvarchar and MI_FPARAM. */
		mi_set_varlen(Gen_RetVal, size);
		mi_fp_setretlen(Gen_fparam, 0, size);

		/* Copy the data from the BWA into the mi_lvarchar.	*/
		mi_set_vardata (Gen_RetVal, bwa_in->identity);
	}

	/* ------ }}Your_Code (#JK5S) END ------ */

	/*
	** Write to the trace file indicating
	** that Identity has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Identity" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#IO8P) */




/* {{FUNCTION(2028cd93-0a3d-11d3-984d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWA_contains
**
** Description:
**	Determines if the column value (first argument) contains
**	any of the search parts in the second argument. If any part
**	in the search expression is not filled in, that part is
**	ignored when the UDR is executed. The comparison is case
**	insensitive.
**
**	The following query looks for all id's whose second
**	part ("family") is tshirt:
**
**		select * from products
**		where	Contains(id, ".tshirt..");
**
**	It is equivalent to these queries:
**
**		select * from products
**		where GetFamily(id) = "tshirt";
**
**		select * from products
**		where id = ".tshirt..";
**
**	The following query looks for all id's whose second
**	part ("family") is "tshirt" and whose fourth part is "blue":
**
**		select * from products
**		where	Contains(id, ".tshirt..blue");
**
**	It is equivalent to this query:
**
**		select * from products
**		where	GetFamily(id)="tshirt"
**		  and	GetIdentity(id)="blue";
**
**	The next query looks for an exact match on all 4 parts:
**
**		select * from products
**		where	Contains(id, "Fruit of the Loom.tshirt.v-neck.blue");
**
** Special Comments:
**
**	Entrypoint for the SQL routine Contains (BWA) returns boolean.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	05/18/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer BWAContains
(
BWA *                   bwa_in1,
BWA *			bwa_in2,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle.        */
	mi_integer      Gen_RetVal=MI_FALSE,
			keep_going=MI_TRUE,
			status;
	mi_string	*r="BWAContains";
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Contains has been called.
	*/
	DBDK_TRACE_ENTER( "Contains" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Start by setting the return value to NULL.
	** This is one of those "style choices".
	** I like to do this so that if I raise any
	** errors, I'm guaranteed that the routine manager
	** will ignore anything in the return value slot.
	*/
	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );

	/* This routine requires at least one part filled in */
	if (	bwa_in2->nulls[0] == MI_TRUE
		&&	bwa_in2->nulls[1] == MI_TRUE
		&&	bwa_in2->nulls[2] == MI_TRUE
		&&	bwa_in2->nulls[3] == MI_TRUE
	   )
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA2",
			"UDR_NAME%s",	r, 
			(mi_integer) NULL);

		return MI_ERROR;	/* not reached */
	}


	if ( bwa_in2->nulls[0] == MI_FALSE )	/* Category */
	{
		status = -1;
		if(bwa_in1->nulls[0]==MI_FALSE)
		{
#ifndef WIN32	
			status = strcasecmp (bwa_in1->category, bwa_in2->category);
#else
			status = stricmp (bwa_in1->category, bwa_in2->category);
#endif
		}
		if(status == 0) /* will still be -1 if nulls[0]==MI_TRUE */
			Gen_RetVal = MI_TRUE;
		else
		{
			Gen_RetVal = MI_FALSE;
			keep_going = MI_FALSE; /* pop out as soon as we have a false */
		}
	}


	if ( keep_going == MI_TRUE )
	{
		if ( bwa_in2->nulls[1]==MI_FALSE )	/* Family */
		{
			status = -1;
			if	( bwa_in1->nulls[1]==MI_FALSE )
			{
#ifndef WIN32
				status = strcasecmp (bwa_in1->family, bwa_in2->family);
#else
				status = stricmp (bwa_in1->family, bwa_in2->family);
#endif
			}
			if (status == 0)
					Gen_RetVal = MI_TRUE;
			else
			{
				Gen_RetVal = MI_FALSE;
				keep_going = MI_FALSE;
			}
		}
	}

	/* keep going if true .... */
	if ( keep_going == MI_TRUE )
	{
		if ( bwa_in2->nulls[2]==MI_FALSE )	/* Group */
		{
			status = -1;
			if	( bwa_in1->nulls[2]==MI_FALSE)
			{
#ifndef WIN32
				status = strcasecmp (bwa_in1->group, bwa_in2->group);
#else
				status = stricmp (bwa_in1->group, bwa_in2->group);	
#endif
			}
			if (status == 0)
				Gen_RetVal = MI_TRUE;
			else
			{
				Gen_RetVal = MI_FALSE;
				keep_going = MI_FALSE;
			}
		}
	}

	/* keep going if true .... */
	if ( keep_going == MI_TRUE )
	{
		if ( bwa_in2->nulls[3]==MI_FALSE )	/* Identity */
		{
			status = -1;
			if	( bwa_in1->nulls[3]==MI_FALSE )
			{
#ifndef WIN32
				status = strcasecmp (bwa_in1->identity, bwa_in2->identity);
#else
				status = stricmp (bwa_in1->identity, bwa_in2->identity);
#endif
			}
			if (status == 0)
				Gen_RetVal = MI_TRUE;
			else
			{
				Gen_RetVal = MI_FALSE;
				keep_going = MI_FALSE;
			}
		}
	}

	/* ------ }}Your_Code (#BD8C) END ------ */

	/*
	** Write to the trace file indicating
	** that Contains has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Contains" );

	/* Return the function's return value. */
	mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE );
	return Gen_RetVal;
}
/* }}FUNCTION (#DPAT) */

/* {{FUNCTION(1aa71b40-137e-11d3-9853-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAEmpty
**
** Description:
**	Returns MI_TRUE if any part in the BWA is empty. 
**	If all parts all filled in, return MI_FALSE.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Empty (BWA) returns boolean.
**
** Parameters:
**	BWA	The input BWA
**
** Return value:
**
**	mi_integer 	The boolean (MI_TRUE / MI_FALSE) return value. 
**
** History:
**
**	05/26/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer BWAEmpty
(
BWA *         bwa_in,
MI_FPARAM *   Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con=NULL;		/* The connection handle.  */
	mi_integer      Gen_RetVal=MI_FALSE;	/* The return value. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer	i;			/* loop counter */
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Empty has been called.
	*/
	DBDK_TRACE_ENTER( "Empty" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	
	/* Empty() returns MI_TRUE if any part in the BWA is
	** empty. If all parts all filled in, return MI_FALSE.
	**
	** So, if the null indicator for any part is set to MI_TRUE
	** (that part is empty) return MI_TRUE.
	*/

	/* Assume all parts are filled in. */
	Gen_RetVal = MI_FALSE; 
	
	for(i=0; i< 4; i++)
	{
		if(bwa_in->nulls[i] == MI_TRUE) /* this part is empty */
			Gen_RetVal=MI_TRUE;	/* BWA as a whole is Empty */
	}

	/* ------ }}Your_Code (#1JLK) END ------ */

	/*
	** Write to the trace file indicating
	** that Empty has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Empty" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#6F6G) */


/* {{FUNCTION(1aa71b42-137e-11d3-9853-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWANotEmpty
**
** Description:
**	Returns MI_TRUE if all parts are filled in.
**	Returns MI_FALSE if any part is empty.
**
** Special Comments:
**
**	Entrypoint for the SQL routine NotEmpty (BWA) returns boolean.
**
** Parameters:
**	BWA	The input BWA
**
** Return value:
**
**	mi_integer The boolean (MI_TRUE / MI_FALSE) return value
**
** History:
**
**	05/26/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer BWANotEmpty
(
BWA *           bwa_in,
MI_FPARAM *     Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle.   */
	mi_integer      Gen_RetVal;       /* The return value.	      */
	mi_integer		i;                /* loop counter */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that NotEmpty has been called.
	*/
	DBDK_TRACE_ENTER( "NotEmpty" );


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* NotEmpty() should return MI_TRUE if all parts are filled in
	** and it should return MI_FALSE if any part is empty.
	**
	** If the null indicator for any part is set to MI_TRUE
	** (the part is empty) return MI_FALSE. Otherwise return MI_TRUE. 
	*/

	/* Assume all parts are filled in, the BWA is NotEmpty */
	Gen_RetVal = MI_TRUE; 
	
	for(i=0; i< 4; i++)
	{
		if(bwa_in->nulls[i] == MI_TRUE) /* this part is empty */
			Gen_RetVal=MI_FALSE;	/* BWA as a whole is not NotEmpty */
	}

	/* ------ }}Your_Code (#AN8C) END ------ */

	/*
	** Write to the trace file indicating
	** that NotEmpty has successfully exited.
	*/
	DBDK_TRACE_EXIT( "NotEmpty" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#Q2F5) */

/* {{FUNCTION(1aa71b43-137e-11d3-9853-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWANotEmptyPart
**
** Description:
**	Returns MI_TRUE if the specified part is not empty (the nulls 
**	indicator is set to MI_FALSE). 
**	Returns MI_FALSE if the specified part is empty.
**
** Special Comments:
**
**	Entrypoint for the SQL routine NotEmpty (BWA,int) returns boolean.
**
** Parameters:
**	BWA            Input BWA
**	mi_integer     part #
**
** Return value:
**
**	mi_integer    Boolean return (MI_TRUE / MI_FALSE)
**
** History:
**
**	05/26/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer BWANotEmptyPart
(
BWA *                   bwa_in,
mi_integer              part_num,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle.  */
	mi_integer      Gen_RetVal;       /* The return value.       */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_string	*r="NotEmpty";
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that NotEmpty has been called.
	*/
	DBDK_TRACE_ENTER( "NotEmpty" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* If this part is not empty (the nulls indicator is set 
	** to MI_FALSE), return MI_TRUE. Otherwise return MI_FALSE.
	*/

	if( part_num < 1 || part_num > 4)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA1",
			"UDR_NAME%s",	r, 
			"NUM_PARTS%d",	part_num,
			(mi_integer) NULL);
	}

	if(bwa_in->nulls[part_num-1] == MI_FALSE)
		Gen_RetVal=MI_TRUE;
	else
		Gen_RetVal = MI_FALSE;

	/* ------ }}Your_Code (#AN8C) END ------ */

	/*
	** Write to the trace file indicating
	** that NotEmpty has successfully exited.
	*/
	DBDK_TRACE_EXIT( "NotEmpty" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#0BJK) */




/* {{FUNCTION(1aa71b41-137e-11d3-9853-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAEmptyPart
**
** Description:
**	If the specified part is empty (the nulls indicator is set 
**	to MI_TRUE), return MI_TRUE. Otherwise return MI_FALSE.
**
** Special Comments:
**
**	Entrypoint for the SQL routine Empty (BWA,int) returns boolean.
**
** Parameters:
**	BWA           Input BWA
**	mi_integer    Boolean (MI_TRUE / MI_FALSE) return
**
** Return value:
**
**	mi_integer
**
** History:
**
**	05/26/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer BWAEmptyPart
(
BWA *        bwa_in,
mi_integer   part_num,
MI_FPARAM *  Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con=NULL;     /* The connection handle. */
	mi_integer      Gen_RetVal;       /* The return value.      */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_string	*r="Empty";
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that Empty has been called.
	*/
	DBDK_TRACE_ENTER( "Empty" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* If this part is empty (the nulls indicator is set 
	** to MI_TRUE), return MI_TRUE. Otherwise return MI_FALSE.
	*/

	if( part_num < 1 || part_num > 4)
	{
		mi_db_error_raise (NULL, MI_SQL, "UBWA1",
			"UDR_NAME%s",	r, 
			"NUM_PARTS%d",	part_num,
			(mi_integer) NULL);
	}

	if(bwa_in->nulls[part_num-1] == MI_TRUE)
		Gen_RetVal=MI_TRUE;
	else
		Gen_RetVal = MI_FALSE;


	/* ------ }}Your_Code (#1JLK) END ------ */

	/*
	** Write to the trace file indicating
	** that Empty has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Empty" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#NJ5R) */

/* {{FUNCTION(a2c05a60-2caf-11d3-9854-000000000000) (MergeSection) */

/*****************************************************************************
** Statistics functions that maintain udr counts in PER_SESSION named memory:
**
**	BWAInitStats    C entrypoint for SQL UDR, sets all counts to 0
**	BWAPrintStats   C entrypoint for SQL UDR, prints all counts
**	BWABumpStats    Called by C entrypoints to bump count for a UDR
**	BwaGetStats     Called by other BWA*Stats to get pointer to memory
**
** These functions maintain a count of the number of times a UDR has been 
** called in PER_SESSION named memory. The feature is enabled when the user
** executes the BWAInitStats() or the BWAPrintStats() routine, and it stays
** enabled until the user exits the session.
**
**	===> IMPORTANT DISCLAIMER <====
**
**	The SQL UDRs that use this statistics feature are not documented 
**	in the BWA DataBlade documentation -- and this is deliberate.
**	You only know that this feature exists if you looked at the
**	source code and made it this far.
**
**	This code demonstrates named memory management. It is advanced 
**	IDS server code that you should not incorporate into DataBlade 
**	code unless you take the time to play with it and understand 
**	how to manage it.
**	
**	The mi_* named memory and locking functions are semi-public.
**	The "Memory Allocation for UDRs" tech note on the IDN DataBlade 
**	Corner (http://www.informix.com/idn) is the only Informix 
**	documentation that explains named memory management and 
**	concurrency control.
**
** To take advantage of this feature....
**
** You need to do two things in the source code:
**
**      1. Include the udr name you want to track in the BWAfuncList below. 
**         Currently only the btree operator class functions are on that list
**         because the author was interested in tracking the number of calls
**         during index creation.
**
**      2. Insert a call to BWABumpStats() in the UDR's C entrypoint.
**         For example, the BWACompare() C function had this code:
**
**              if(tf(BWA_STATS_CLASS,1))
**                   BWABumpStats("Compare");
**
**         The tf() call makes sure that the BWABumpStats() function only
**         gets called if the BWA_STATS_CLASS trace class has been
**         enabled. The user enables that trace class by executing the
**         BWAInitStats() or BWAPrintStats() UDR.
**
** You need to do several things in your SQL session:
**
**      1. Turn stats collection on by executing the
**         BWAInitStats() or BWAPrintStats() UDR.
**
**      2. Zero out the stats by calling BWAInitStats().
**
**      3. Output the current count by calling BWAPrintStats().
**
** Finally, if you find any bugs in this code, feel free to send email
** to jta@informix.com.
******************************************************************************
*/

/* 
** A readonly static list is ok.
**
** So far, this list only has the btree operator class functions.
*/
static char *BWAfuncList[] =
{
	"Compare",
	"Equal",
	"GreaterThan",
	"GreaterThanOrEqual",
	"LessThan",
	"LessThanOrEqual",
	"NotEqual",
};
#define BWAfuncNum (sizeof (BWAfuncList) / sizeof (char *))    

/* An mi_unsigned_integer is good for 0 to 4,294,967,295 
** (limits.h: ULONG_MAX).
**
** The "overflow" array in the BWAstat structure keeps track of 
** the number of times it reached ULONG_MAX and was set back to 1.
**
** The rollover feature is untested.
*/

typedef struct
{
	mi_unsigned_integer bwa_udr[BWAfuncNum];
	mi_integer          rollover[BWAfuncNum];
}
BWAstat;

#define BWA_MEM_NAME "BWA_func_count"
#define BWA_NAME_SIZE 36

typedef	struct 
{
	mi_string   stat_data [BWAfuncNum][BWA_NAME_SIZE];
	mi_integer  count;
} StateInfo;

/* Statistics gathering functions */
UDREXPORT void         BWAInitStats(MI_FPARAM *Gen_fparam);
UDREXPORT mi_lvarchar *BWAPrintStats (MI_FPARAM *Gen_fparam);
mi_integer             BWABumpStats (mi_string *udr_name);
static void            init_BWAPrintStats (MI_FPARAM *Gen_fparam);
static mi_lvarchar   * retone_BWAPrintStats (MI_FPARAM *Gen_fparam);
static BWAstat       * GetBwaStats();

/*****************************************************************************
**
** Procedure name:
**
**	BWAInitStats
**
** Description:
**
**	C entrypoint for the BwaInitStats() routine.
**
**	This routine calls GetBwaStats() to get a pointer to the
** 	named memory, then zero's out the count for each routine.
**
** Parameters:
**	None
**
** History:
**
**	06/27/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

/* GetBwaStats
**	BWAInitStats(), BWABumpStats(), and BWAPrintStats() call this 
**	function to retrieve the pointer to the PER_SESSION named memory 
**	that stores udr counts.
**
**	If that named memory has not been allocated yet, this function 
**	allocates it and enables the BWA_STATS_CLASS class. If the named
**	memory already exists, it just gets a pointer to it.
**
**	It then locks that memory to keep multiple threads from updating
**	it concurrently.
**
**	It returns the pointer to the caller. 
**
**	IMPORTANT! THE CALLER MUST UNLOCK THE MEMORY WHEN DONE!
*/
static
BWAstat *
GetBwaStats()
{
	BWAstat		*func_count = NULL;
	mi_string	msgbuf[80];
	mi_integer	memstat,	/* get/allocated status */
			lockstat,	/* lock status */
			i;		/* loop counter */
	mi_boolean	we_allocated=MI_TRUE;

	/* Allocate the named memory. If it already exists, get it.  */
	memstat = mi_named_alloc (sizeof(BWAstat),
		BWA_MEM_NAME, PER_SESSION, (void**) &func_count);
	if(memstat == MI_NAME_ALREADY_EXISTS)
	{
		memstat = mi_named_get
			(BWA_MEM_NAME, PER_SESSION, (void **) &func_count);
		we_allocated=MI_FALSE;
	}

	switch(memstat)
	{
		case MI_ERROR:
			mi_db_error_raise (NULL, MI_EXCEPTION,
			"GetBwaStats: mi_named_get or mi_named_zalloc failed.");
			return (BWAstat *)NULL;
		break;

		/* We got it. */
		case MI_OK:
			break;

		case MI_NO_SUCH_NAME:
			mi_db_error_raise (NULL, MI_EXCEPTION,
				"GetBwaStats: no name after good get");
			return (BWAstat *)NULL;
			break;

		default:
			sprintf(msgbuf,
				"GetBwaStats: mi_named memory case %d.", 
				memstat);
			mi_db_error_raise (NULL, MI_EXCEPTION, msgbuf);
			return (BWAstat *)NULL;
		break;
	}

	/*
	** BEGIN CRITICAL SECTION.
	**
	** All access to the BWAstat structure is done
	** inside a lock-protected section of code.
	**
	** If two threads try to modify the structure
	** at the same time, the second one blocks on
	** the mi_lock_memory call.
	**
	** A reader (BWAPrintStats) also blocks so that it 
	** gets a consistent read if another thread is 
	** updating that memory.
	**
	** So this function acquires the lock. The called
	** then must release the lock.
	*/

	/* 10 tries is very pessimistic */
	for (lockstat=MI_LOCK_IS_BUSY, i=0;
		lockstat == MI_LOCK_IS_BUSY && i < 10; i++)
	{
        	lockstat=mi_try_lock_memory(BWA_MEM_NAME, PER_SESSION);
		switch(lockstat)
		{
			case MI_OK:
				break;

			case MI_LOCK_IS_BUSY:
				mi_yield(); /* Yield the processor. */
				break;

			case MI_NO_SUCH_NAME:
				mi_db_error_raise(NULL, MI_EXCEPTION,
					"GetBwaStats: mi_try_lock_memory returned MI_NO_SUCH_NAME");
				return (BWAstat *)NULL;
				break;
			case MI_ERROR:
				mi_db_error_raise(NULL, MI_EXCEPTION,
                 			"GetBwaStats: mi_try_lock_memory failed!");
				return (BWAstat *)NULL;
              			break;

           		default:
				mi_db_error_raise(NULL, MI_EXCEPTION,
                 			"GetBwaStats: mi_try_lock_memory unhandled status!");
				return (BWAstat *)NULL;
              			break;
		} /* END switch */
	} /* END try to get a lock */


	/* Check the status after coming out of the loop. */
	if(lockstat == MI_LOCK_IS_BUSY)
	{
		mi_db_error_raise(NULL, MI_EXCEPTION, "GetBwaStats: Couldn't get lock");
		return (BWAstat *)NULL; /* not reached */
	}

	/* If we just allocated it, initialize it 
	** and set the trace class level for stats.
	*/
	if(we_allocated == MI_TRUE)
	{
		sprintf(msgbuf,"%s 1", BWA_STATS_CLASS);
		if( mi_tracelevel_set( msgbuf ) != MI_OK ) 
		{
			/* Release memory before raising error */
			mi_unlock_memory (BWA_MEM_NAME, PER_SESSION);
			mi_db_error_raise(NULL, MI_EXCEPTION,
				"GetBwaStats: mi_tracelevel_set failed!");
			return (BWAstat *)NULL;
		}

		/* initialize */
		for (i=0; i < BWAfuncNum; i++)
		{
			func_count->bwa_udr[i]=0;
			func_count->rollover[i]=0;
		}
	}

	/* We have the lock. Return the pointer.  */

	return func_count;
}

/*
** BWAInitStats
**	Resets all counts to 0.
*/
UDREXPORT void
BWAInitStats(MI_FPARAM *Gen_fparam)
{
	MI_CONNECTION * Gen_Con=NULL;          /* The connection handle. */
	BWAstat       *bwa_udr_count = NULL;
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	mi_integer	i;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/*
	** Write to the trace file indicating
	** that BWAInitStats has been called.
	*/
	DBDK_TRACE_ENTER( "BWAInitStats" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Get a pointer to the structure in named memory
	** that maintains the count of how many times each
	** udr has been called.
	*/
	bwa_udr_count = GetBwaStats();
	if ( bwa_udr_count == (BWAstat *)NULL)
	{
		mi_db_error_raise(NULL, MI_EXCEPTION, "GetBwaStats failed!");
		/* not reached */
	}

	/* We now have the pointer to the named memory, and it
	** is locked so now we can now safely update it.
	**
	** WE ARE RESPONSIBLE FOR RELEASING THE LOCK.
	*/
	for (i=0; i < BWAfuncNum; i++)
	{
		bwa_udr_count->bwa_udr[i]=0;
		bwa_udr_count->rollover[i]=0;
	}

	/* ==================== RELEASE THE LOCK ==================== */
	mi_unlock_memory (BWA_MEM_NAME, PER_SESSION);

	/* ------ }}Your_Code (#JJAB) END ------ */

	/*
	** Write to the trace file indicating
	** that BWAInitStats has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWAInitStats" );

	return;
}


/*
** BWABumpStats () is called by the C entrypoint function for a UDR
** to bump the count for that udr. 
**
** For example, the Compare function does this call:
**
**	if(tf(BWA_STATS_CLASS,1))         <= if the trace class is >= 1
**		BWABumpStats("Compare");  <= bump the count for "Compare"
**
** "Compare" is in the BWAfuncList defined above.  So far, only the btree 
** opclass UDRs are coded to do this. To add more UDR's, put them in
** BWAfuncList, code them as shown above, then recompile.
*/
mi_integer
BWABumpStats(mi_string *udr_name)
{
	MI_CONNECTION * Gen_Con=NULL;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	BWAstat       * bwa_udr_count = NULL;
	mi_integer	i, 
			udr_num = -1;
	mi_string	buf[80];
	/* ------ }}Your_Declarations (#0000) END ------ */

	DBDK_TRACE_ENTER( "BWABumpStats" );

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* First find the index of the udr we want to update. */
	for (i=0; i < BWAfuncNum && udr_num < 0; i++)
	{
		if(!strcmp(udr_name, BWAfuncList[i]) )
			udr_num = i;
	}

	if(udr_num == -1)
	{
		sprintf(buf, "Did not find %s in udr list", udr_name);
		mi_db_error_raise(NULL, MI_EXCEPTION, buf);
		return MI_ERROR; /* not reached */
	}

	/* Get a pointer to the structure in named memory
	** that maintains the count of how many times each
	** udr has been called.
	*/
	bwa_udr_count = GetBwaStats();
	if ( bwa_udr_count == (BWAstat *)NULL)
	{
		mi_db_error_raise(NULL, MI_EXCEPTION, "GetBwaStats failed!");
	}

	/* We now have the pointer to the named memory, and it
	** is locked so now we can now safely update it.
	**
	** WE ARE RESPONSIBLE FOR RELEASING THE LOCK.
	*/
	
	if (bwa_udr_count->bwa_udr[udr_num] == ULONG_MAX)
	{
		bwa_udr_count->bwa_udr[udr_num]=1;
		bwa_udr_count->rollover[udr_num]++;
	}
	else
		bwa_udr_count->bwa_udr[udr_num]++;

	/* ==================== RELEASE THE LOCK ==================== */
	mi_unlock_memory (BWA_MEM_NAME, PER_SESSION);

	/* ------ }}Your_Code (#JJAB) END ------ */

	/*
	** Write to the trace file indicating
	** that BWAInitStats has successfully exited.
	*/
	DBDK_TRACE_EXIT( "BWABumpStats" );

	return MI_OK;
}
/* }}FUNCTION (#G0TO) */


/* {{FUNCTION(a2c05a61-2caf-11d3-9854-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	BWAPrintStats
**
** Description:
**	Prints out the count for each UDR, one row for each UDR
**	(this is an iterator function).
**
** Special Comments:
**
**	Entrypoint for the SQL routine BWAPrintStats () returns lvarchar.
**
** Parameters:
**	None, just the MI_FPARAM.
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	06/27/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *BWAPrintStats(MI_FPARAM *Gen_fparam)
{
	int		Gen_IteratorState; /* This is the iteration state. */
	MI_CONNECTION * Gen_Con = NULL;	   /* The current connection. */
	mi_lvarchar *   Gen_RetVal = 0;    /* BWAPrintStats's return value. */
	StateInfo	* Gen_StateInfo; /* BWAPrintStats's state information.*/

	Gen_IteratorState = mi_fp_request( Gen_fparam );

	switch( Gen_IteratorState )
	{
		case SET_INIT:			/* Initialize */

			/*
			** Write to the trace file indicating
			** that BWAPrintStats has been called.
			*/
			DBDK_TRACE_ENTER( "BWAPrintStats (SET_INIT)" );
		
			init_BWAPrintStats(Gen_fparam);

			DBDK_TRACE_EXIT( "BWAPrintStats (SET_INIT)" );

			return (mi_lvarchar *)NULL;

		case SET_RETONE:		/* Iterate */
			/*
			** Write to the trace file indicating
			** that BWAPrintStats has been called.
			*/
			DBDK_TRACE_ENTER( "BWAPrintStats (SET_RETONE)" );

			Gen_RetVal = retone_BWAPrintStats(Gen_fparam);

			/*
			** Write to the trace file indicating
			** that BWAPrintStats has successfully exited.
			*/
			DBDK_TRACE_EXIT( "BWAPrintStats (SET_RETONE)" );
		
			return ( Gen_RetVal );

		case SET_END:			/* Conclude */

			DBDK_TRACE_ENTER( "BWAPrintStats (SET_END)" );

			/* Get the state information. */
			Gen_StateInfo = 
				(StateInfo *)mi_fp_funcstate(Gen_fparam);

			if( Gen_StateInfo != NULL )
			{
				mi_free( Gen_StateInfo );
			}

			DBDK_TRACE_EXIT( "BWAPrintStats (SET_END)" );

			return (mi_lvarchar *)NULL;

		default:
			/*
			** This is an invalid state so issue
			** the following message and quit.
			**
			** 	"Invalid iterator state used in BWAPrintStats."
			*/
			DBDK_TRACE_ERROR( "BWAPrintStats", ERRORMESG17, 10 );

			/* not reached */

			break;
	}

	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	return (mi_lvarchar *)NULL;
}

static
void init_BWAPrintStats(MI_FPARAM *Gen_fparam)
{
	MI_CONNECTION	* Gen_Con = NULL; /* The current connection. */
	StateInfo	* Gen_StateInfo; /* BWAPrintStats's state information.*/
	BWAstat		* bwa_udr_count = NULL;
	mi_integer	i;

	/*
	** Allocate the  state  information.
	*/
	Gen_StateInfo = (StateInfo *)
		mi_dalloc( sizeof( StateInfo ), PER_COMMAND );
	if( Gen_StateInfo == NULL )
	{
		DBDK_TRACE_ERROR( "BWAPrintStats", ERRORMESG2, 10 );
	}

	/* 
	** Get a pointer to the stats stored in named memory.
	** This places a lock on that named memory, so we need
	** to free that lock before we return.
	*/
	bwa_udr_count = GetBwaStats();
	if ( bwa_udr_count == (BWAstat *)NULL)
	{
		mi_db_error_raise(NULL, MI_EXCEPTION, "GetBwaStats failed!");
	}

	Gen_StateInfo->count=0;

	/* 
	** Copy the stats into our local state buffer 
	*/
	for(i=0; i< BWAfuncNum; i++)
	{
		sprintf(Gen_StateInfo->stat_data[i],
			"%18s: %10u (%d)",
			BWAfuncList[i], 
			bwa_udr_count->bwa_udr[i],
			bwa_udr_count->rollover[i]);
	}

	/* == RELEASE THE LOCK === */
	mi_unlock_memory (BWA_MEM_NAME, PER_SESSION);

	/* Store the private state info in Gen_fParam. */
	mi_fp_setfuncstate( Gen_fparam, Gen_StateInfo );

	return;
}

static
mi_lvarchar * retone_BWAPrintStats(MI_FPARAM *Gen_fparam)
{
	MI_CONNECTION	* Gen_Con = NULL; /* The current connection. */
	StateInfo	* Gen_StateInfo; /* BWAPrintStats's state information.*/
	mi_lvarchar	*Gen_RetVal;

	/*
	** Before  using,  insure  that  the  state
	** information  is valid. It might  not  be
	** if the function has not been  called  as
	** an iterator.
	*/
	Gen_StateInfo = (StateInfo *)mi_fp_funcstate( Gen_fparam );
	if( Gen_StateInfo == NULL )
	{
		DBDK_TRACE_ERROR( "BWAPrintStats", ERRORMESG2, 10 );
	}

	if(Gen_StateInfo->count == BWAfuncNum)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
		mi_fp_setisdone( Gen_fparam, MI_TRUE );
		return (mi_lvarchar *)NULL;
	}

	Gen_RetVal = 
		mi_string_to_lvarchar(Gen_StateInfo->stat_data[Gen_StateInfo->count]);

	Gen_StateInfo->count++;

	mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE );

	return Gen_RetVal;
}



/* }}FUNCTION (#RRJV) */

#ifdef __cplusplus

}

#endif
