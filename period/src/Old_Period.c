/*
** Title:               Period.c
** SCCSid:              %W% %E% %U%
** CCid:                %W% %E% %U%
** Author:              
** Created:             Apr 30, 1997 04:16:35 PM
** Description:         Generated 'C' file.
** Comments:            Generated for project Period.1.0.
**
*/
/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <limits.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Period.h"


/****************************************************************
**
** Function name:
**
**    PeriodInput
**
** Description:
**
**    This function converts from the external representation of the
**    UDT type Period to its internal representation.   The external
**    representation is a blank-separated list of values and the
**    internal representation is a 'C' structure of type Period as
**    defined in the header file.
**
**    Data may be inserted into a table using an SQL insert statement:
**
**        insert into tablename values ( 'value-list' );
**
**    value-list is a space-delimited list of values.
**
**    For the default locale, U.S. 8859-1 English, the following
**    determines the format to use for the date character string:
**
**    1. The format that the DBDATE environment variable specifies
**       if set.
**    2. The format that the GL_DATE environment variable specifies
**       if set.
**    3. The default date format mm/dd/yyyy.
**
**    Consult the INFORMIX-ESQL/C Programmer's Manual for more details.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    Period *                                 The constructed UDT value.
**
** History:
**
**  Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
**  May 1, 1997  - Changed by P Brown to make the input format 'Date to Date',
**                 from 'Date Date'.
**
**
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodInput FunctionId: -1
**
*****************************************************************
*/
Period *
PeriodInput
(
mi_lvarchar *           Gen_param1,    /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
    Period * Gen_OutData;			   /* Pointer to the output data.        */
    mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
    Period * Gen_RetVal;			   /* The return value.                  */
    long            Gen_InternalDate;  /* Internal date representation.      */
    gl_mchar_t *    Gen_DatePtr;       /* Scanning pointer.                  */
    gl_mchar_t *    Gen_DatePtr2;      /* Scanning pointer.                  */
    mi_integer      Gen_DateIndex;     /* Keep track of the length.          */
    char            Gen_DateStr[80];   /* Hold the mi_date string here.      */
    char *          Gen_Start;         /* Start of the input data.           */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodInput."
        */
        DBDK_TRACE_ERROR( "PeriodInput", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodInput has been called.
    */
    DBDK_TRACE_ENTER( "PeriodInput" );

    /* Allocate memory room to build the UDT in. */
    Gen_RetVal = new_Period();

    /* Point to the input data. */
    Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );

    /* Point to the start of the data. */
    Gen_Start = (char *)Gen_InData;

    /* Point to the output data. */
    Gen_OutData = (Period *)Gen_RetVal;

    /* Get the length of the input string. */
    Gen_DataLen = mi_get_varlen( Gen_param1 );

    /* Scan past leading white space. */
    for( ;(char *)Gen_InData < Gen_Start + Gen_DataLen; )
    {
        if( !ifx_gl_ismblank( Gen_InData, 4 ) )
        {
            break;
        }

        /* Advance to the next character */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );
    }

    /*
    ** Transfer the data value to a NULL terminated
    ** buffer for conversion by rstrdate.
    */
    for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
         Gen_DatePtr2  = Gen_InData,
         Gen_DateIndex = 0;
           (char *)Gen_InData < Gen_Start + Gen_DataLen &&
           !ifx_gl_ismblank( Gen_InData, 4 ); )
    {
        /* Advance the input pointer. */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

        /* Keep track of the length. */
        ++Gen_DateIndex;
    }

    /* Copy the string and terminate. */
    ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
                    (int)(Gen_InData - Gen_DatePtr2) );
    Gen_DateStr[Gen_InData - Gen_DatePtr2] = '\0';

/*
**   CHANGES HERE. 
**  
**    Rather than simply stepping forward to the next non-space character,
**  I need to step over the 'to ', if one is there. 
**/
    if (strncmp(Gen_InData," to ",4) == 0)
    {    
        Gen_InData+=4;
    } else 
    {
        /* Advance to the next data value. */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );
    }

    /* Check for an empty string. */
    if( Gen_DateIndex == 0 )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodInput." );
        */
        DBDK_TRACE_ERROR( "PeriodInput", ERRORMESG11, 10 );

        /* not reached */
    }
    /* Convert the date to internal format. */
    if( rstrdate( Gen_DateStr, &Gen_InternalDate ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodInput".
        */
        DBDK_TRACE_ERROR( "PeriodInput", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData->start = Gen_InternalDate;

    /* Scan past leading white space. */
    for( ;(char *)Gen_InData < Gen_Start + Gen_DataLen; )
    {
        if( !ifx_gl_ismblank( Gen_InData, 4 ) )
        {
            break;
        }

        /* Advance to the next character */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );
    }

    /*
    ** Transfer the data value to a NULL terminated
    ** buffer for conversion by rstrdate.
    */
    for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
         Gen_DatePtr2  = Gen_InData,
         Gen_DateIndex = 0;
           (char *)Gen_InData < Gen_Start + Gen_DataLen &&
           !ifx_gl_ismblank( Gen_InData, 4 ); )
    {
        /* Advance the input pointer. */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

        /* Keep track of the length. */
        ++Gen_DateIndex;
    }

    /* Copy the string and terminate. */
    ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
                    (int)(Gen_InData - Gen_DatePtr2) );
    Gen_DateStr[Gen_InData - Gen_DatePtr2] = '\0';

    /* Advance to the next data value. */
    Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

    /* Check for an empty string. */
    if( Gen_DateIndex == 0 )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodInput." );
        */
        DBDK_TRACE_ERROR( "PeriodInput", ERRORMESG11, 10 );

        /* not reached */
    }
    /* Convert the date to internal format. */
    if( rstrdate( Gen_DateStr, &Gen_InternalDate ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodInput".
        */
        DBDK_TRACE_ERROR( "PeriodInput", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData->finish = Gen_InternalDate;

    /* Check the thing. */
    Check_Period(Gen_OutData);

    /*
    ** Write to the trace file indicating
    ** that PeriodInput has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodInput" );

    /* Close the connection. */
    mi_close( Gen_Con );


    /* Return the UDT value. */
    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodInput checksum: 1176098142 */

/****************************************************************
**
** Function name:
**
**    PeriodOutput
**
** Description:
**
**    This function converts from the internal representation of the
**    UDT type Period to its external representation.   The external
**    representation is a blank-separated list of values and the
**    internal representation is a 'C' structure of type Period as
**    defined in the header file.
**
**    Data may be retrieved from a table using an SQL select statement:
**
**        select from tablename;
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    Period *                   Gen_param1;   Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
**    May 1,  1997 - Changed by P Brown to make the public format a little more
**                   intuitive.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodOutput FunctionId: -1
**
*****************************************************************
*/
mi_lvarchar *
PeriodOutput
(
Period *        Gen_param1,    /* The UDT value.                     */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
    Period * Gen_InData;       /* Pointer to the input data.         */
    char *          Gen_OutData;       /* Pointer to the output data.        */
    mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
    mi_integer      Gen_DataLen;       /* The data length.                   */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodOutput."
        */
        DBDK_TRACE_ERROR( "PeriodOutput", ERRORMESG1, 10 );

        /* not reached */
    }

    /* Compute the maximum length of the text representation. */
    Gen_CharLen =    1;    /* Leave room for the NULL terminator. */
    Gen_CharLen +=  21;    /* Add the length for Gen_OutData->start.                  */
    Gen_CharLen +=  21;    /* Add the length for Gen_OutData->finish.                 */

    /* Allocate room for the output string. */
    Gen_RetVal = mi_new_var( Gen_CharLen );
    if( Gen_RetVal == 0 )
    {
        /*
        ** Memory allocation has failed so issue
        ** the following message and quit.
        **
        **     "Memory allocation has failed in PeriodOutput."
        */
        DBDK_TRACE_ERROR( "PeriodOutput", ERRORMESG2, 10 );

        /* not reached */
    }

    /* Point to the input data. */
    Gen_InData = Gen_param1;

    /* Point to the output data. */
    Gen_OutData = mi_get_vardata( Gen_RetVal );

    /* Format the attribute value into the output string. */

    /* Convert the date from internal format. */
    if( rdatestr( Gen_InData->start, Gen_OutData ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodOutput."
        */
        DBDK_TRACE_ERROR( "PeriodOutput", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData += strlen( Gen_OutData );
/*
** CHANGES:
**   
**     Plonk the " to " between the dates, rather than the simple spaces
**   used otherwise.
**/

    strcat(Gen_OutData," to ");
    Gen_OutData+=4;

/*
** *Gen_OutData++ = ' ';
**/
    /* Convert the date from internal format. */
    if( rdatestr( Gen_InData->finish, Gen_OutData ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodOutput."
        */
        DBDK_TRACE_ERROR( "PeriodOutput", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData += strlen( Gen_OutData );
    *Gen_OutData++ = ' ';

    /*
    ** Compute the length of the data and
    ** place it in the return structure.
    */
    Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
    mi_set_varlen ( Gen_RetVal, Gen_DataLen );

    /* Close the connection. */
    mi_close( Gen_Con );

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodOutput checksum: 486504435  */

/****************************************************************
**
** Function name:
**
**    PeriodSend
**
** Description:
**
**    The binary send function is used to convert an instance of a
**    data type between its internal representation on the server and
**    on the client.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodSend FunctionId: -1
**
*****************************************************************
*/
mi_sendrecv *
PeriodSend
(
Period *        Gen_param1,    /* The UDT value                      */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    Period * Gen_InData;       /* Pointer to the UDT value.          */
    Period * Gen_OutData;      /* Pointer to the packet data.        */
    mi_sendrecv *   Gen_RetVal;        /* The return value.                  */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodSend."
        */
        DBDK_TRACE_ERROR( "PeriodSend", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodSend has been called.
    */
    DBDK_TRACE_ENTER( "PeriodSend" );

    /* Allocate a new return value. */
    Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( Period ) );
    if( Gen_RetVal == 0 )
    {
        /*
        ** Memory allocation has failed so issue
        ** the following message and quit.
        **
        **     "Memory allocation has failed in PeriodSend."
        */
        DBDK_TRACE_ERROR( "PeriodSend", ERRORMESG2, 10 );

        /* not reached */
    }

    /* Point to the input data. */
    Gen_InData = Gen_param1;

    /* Point to the output data. */
    Gen_OutData = (Period *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

    /* Prepare the value for Gen_OutData->start. */
    mi_put_date( (mi_unsigned_char1 *)&Gen_OutData->start, &Gen_InData->start );

    /* Prepare the value for Gen_OutData->finish. */
    mi_put_date( (mi_unsigned_char1 *)&Gen_OutData->finish, &Gen_InData->finish );


    /*
    ** Write to the trace file indicating
    ** that PeriodSend has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodSend" );

    /* Close the connection. */
    mi_close( Gen_Con );

    /* Return the UDT for transmission. */
    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodSend checksum: 183694148  */

/****************************************************************
**
** Function name:
**
**    PeriodReceive
**
** Description:
**
**    The binary receive function is used to convert an instance of a
**    data type between its internal representation on the server and
**    on the client.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodReceive FunctionId: -1
**
*****************************************************************
*/
Period *
PeriodReceive
(
mi_sendrecv *           Gen_param1,    /* The UDT value.                     */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    Period * Gen_RetVal;       /* The return value.                  */
    Period * Gen_InData;       /* Packet data.                       */
    Period * Gen_OutData;      /* Output UDT value.                  */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodReceive."
        */
        DBDK_TRACE_ERROR( "PeriodReceive", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodReceive has been called.
    */
    DBDK_TRACE_ENTER( "PeriodReceive" );

    /* Allocate room for the UDT. */
    Gen_RetVal = new_Period();

    /* Point to the input data. */
    Gen_InData = (Period *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

    /* Point to the output data. */
    Gen_OutData = (Period *)Gen_RetVal;

    /* Copy the attribute value(s) from the transmission parcel. */
    /* Prepare the value for Gen_InData->start. */
    mi_get_date( (mi_unsigned_char1 *)&Gen_InData->start, &Gen_OutData->start );

    /* Prepare the value for Gen_InData->finish. */
    mi_get_date( (mi_unsigned_char1 *)&Gen_InData->finish, &Gen_OutData->finish );


    /*
    ** Write to the trace file indicating
    ** that PeriodReceive has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodReceive" );

    /* Return the transmitted UDT value. */
    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodReceive checksum: 192217031  */

/****************************************************************
**
** Function name:
**
**    PeriodImportText
**
** Description:
**
**    The import function enables bulk copy for user-defined types.
**    When the  LOAD statement is  used from  dbaccess to copy data
**    from a file  into the database, the  server calls the  import
**    function to convert the  incoming  value  to the data  type's
**    internal format.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    Period *  The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodImportText FunctionId: -1
**
*****************************************************************
*/
Period *
PeriodImportText
(
mi_impexp *             Gen_param1,    /* The import text.                   */
MI_FPARAM *             Gen_fparam     /* Std info - see DBDK docs.          */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
    Period * Gen_OutData;      /* Ptr to the output data.            */
    Period * Gen_RetVal;       /* The return value.                  */
    mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
    long            Gen_InternalDate;  /* Internal date representation.      */
    gl_mchar_t *    Gen_DatePtr;       /* Scanning pointer.                  */
    gl_mchar_t *    Gen_DatePtr2;      /* Scanning pointer.                  */
    mi_integer      Gen_DateIndex;     /* Keep track of the length.          */
    char            Gen_DateStr[80];   /* Hold the mi_date string here.      */
    char *          Gen_Start;         /* Scanning ptr.                      */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodImportText."
        */
        DBDK_TRACE_ERROR( "PeriodImportText", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodImportText has been called.
    */
    DBDK_TRACE_ENTER( "PeriodImportText" );

    /* Allocate memory for the return UDT. */
    Gen_RetVal = new_Period();

    /* Point to the input data. */
    Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

    /* Point to the start of the data. */
    Gen_Start = (char *)Gen_InData;

    /* Point to the output data. */
    Gen_OutData = Gen_RetVal;

    /* Get the length of the input string. */
    Gen_DataLen = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

    /* Scan past leading white space. */
    for( ;(char *)Gen_InData < Gen_Start + Gen_DataLen; )
    {
        if( !ifx_gl_ismblank( Gen_InData, 4 ) )
        {
            break;
        }

        /* Advance to the next character */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );
    }

    /*
    ** Transfer the data value to a NULL terminated
    ** buffer for conversion by rstrdate.
    */
    for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
         Gen_DatePtr2  = Gen_InData,
         Gen_DateIndex = 0;
           (char *)Gen_InData < Gen_Start + Gen_DataLen &&
           !ifx_gl_ismblank( Gen_InData, 4 ); )
    {
        /* Advance the input pointer. */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

        /* Keep track of the length. */
        ++Gen_DateIndex;
    }

    /* Copy the string and terminate. */
    ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
            (int)(Gen_InData - Gen_DatePtr2));
    Gen_DateStr[Gen_InData - Gen_DatePtr2] = '\0';

    /* Advance to the next data value. */
    Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

    /* Check for an empty string. */
    if( Gen_DateIndex == 0 )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodImportText."
        */
        DBDK_TRACE_ERROR( "PeriodImportText", ERRORMESG11, 10 );

        /* not reached */
    }

    /* Convert the date to internal format. */
    if( rstrdate( Gen_DateStr, &Gen_InternalDate ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodImportText."
        */
        DBDK_TRACE_ERROR( "PeriodImportText", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData->start = Gen_InternalDate;

    /* Scan past leading white space. */
    for( ;(char *)Gen_InData < Gen_Start + Gen_DataLen; )
    {
        if( !ifx_gl_ismblank( Gen_InData, 4 ) )
        {
            break;
        }

        /* Advance to the next character */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );
    }

    /*
    ** Transfer the data value to a NULL terminated
    ** buffer for conversion by rstrdate.
    */
    for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
         Gen_DatePtr2  = Gen_InData,
         Gen_DateIndex = 0;
           (char *)Gen_InData < Gen_Start + Gen_DataLen &&
           !ifx_gl_ismblank( Gen_InData, 4 ); )
    {
        /* Advance the input pointer. */
        Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

        /* Keep track of the length. */
        ++Gen_DateIndex;
    }

    /* Copy the string and terminate. */
    ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
            (int)(Gen_InData - Gen_DatePtr2));
    Gen_DateStr[Gen_InData - Gen_DatePtr2] = '\0';

    /* Advance to the next data value. */
    Gen_InData = ifx_gl_mbsnext( Gen_InData, 4 );

    /* Check for an empty string. */
    if( Gen_DateIndex == 0 )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodImportText."
        */
        DBDK_TRACE_ERROR( "PeriodImportText", ERRORMESG11, 10 );

        /* not reached */
    }

    /* Convert the date to internal format. */
    if( rstrdate( Gen_DateStr, &Gen_InternalDate ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in PeriodImportText."
        */
        DBDK_TRACE_ERROR( "PeriodImportText", ERRORMESG11, 10 );

        /* not reached */
    }
    Gen_OutData->finish = Gen_InternalDate;


    /*
    ** Write to the trace file indicating
    ** that PeriodImportText has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodImportText" );

    /* Close the connection. */
    mi_close( Gen_Con );

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodImportText checksum: 1314296476 */

/****************************************************************
**
** Function name:
**
**    PeriodExportText
**
** Description:
**
**    The export function enables bulk copy for user-defined types.
**    When the UNLOAD statement is used from  dbaccess to copy data
**    from  the  database to a  file, the  server calls the  export
**    function  to convert the outcoming  value to the data  type's
**    external format.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    Period *                                 The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodExportText FunctionId: -1
**
*****************************************************************
*/
mi_impexp *
PeriodExportText
(
Period *        Gen_param1,    /* The UDT value.                     */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    mi_integer      Gen_CharLen;       /* Maximum character length.          */
    mi_impexp *     Gen_RetVal;        /* The return result.                 */
    Period *  Gen_InData;      /* Pointer to the input data.         */
    char *          Gen_OutData;       /* Pointer to the output data.        */
    mi_integer      Gen_DataLen;       /* The final length.                  */

    /* Get the current connection handle. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodExportText."
        */
        DBDK_TRACE_ERROR( "PeriodExportText", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodExportText has been called.
    */
    DBDK_TRACE_ENTER( "PeriodExportText" );

    /* Compute the maximum length of the text representation. */
    Gen_CharLen =    1;    /* Leave room for the NULL terminator. */
    Gen_CharLen +=  21;    /* Add the length for Gen_OutData->start.                  */
    Gen_CharLen +=  21;    /* Add the length for Gen_OutData->finish.                 */

    Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
    if( Gen_RetVal == 0 )
    {
        /*
        ** Memory allocation has failed so issue
        ** the following message and quit.
        **
        **     "Memory allocation has failed in PeriodExportText."
        */
        DBDK_TRACE_ERROR( "PeriodExportText", ERRORMESG2, 10 );

        /* not reached */
    }

    /* Point to the input data. */
    Gen_InData = Gen_param1;

    /* Get a pointer to where our data will be copied to. */
    Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

    if( rdatestr( Gen_InData->start, Gen_OutData ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in Period."
        */
        DBDK_TRACE_ERROR( "PeriodExportText", ERRORMESG11, 10 );

        /* not reached */
    }

    /* Advance past the formatted data. */
    Gen_OutData += strlen( Gen_OutData );
    *Gen_OutData++ = ' ';

    if( rdatestr( Gen_InData->finish, Gen_OutData ) )
    {
        /*
        ** Data conversion has failed so issue
        ** the following message and quit.
        **
        **     "Input data format error in Period."
        */
        DBDK_TRACE_ERROR( "PeriodExportText", ERRORMESG11, 10 );

        /* not reached */
    }

    /* Advance past the formatted data. */
    Gen_OutData += strlen( Gen_OutData );
    *Gen_OutData++ = ' ';


    /*
    ** Compute the length of the data and
    ** place it in the return structure.
    */
    Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
    mi_set_varlen( (mi_lvarchar *)Gen_RetVal, Gen_DataLen );

    /*
    ** Write to the trace file indicating
    ** that PeriodExportText has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodExportText" );

    /* Close the connection. */
    mi_close( Gen_Con );

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodExportText checksum: 878550816  */

/****************************************************************
**
** Function name:
**
**    PeriodImportBinary
**
** Description:
**
**    The  importbinary  function is  used to  support  bulk copy of
**    binary data. This function is the same as the import function,
**    except that it  operates  on internal  representations of  the
**    data type.  This function is  usually only  provided for large
**    object  data types and is called by the LOAD BINARY command of
**    dbaccess.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    Period *  The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodImportBinary FunctionId: -1
**
*****************************************************************
*/
Period *
PeriodImportBinary
(
mi_bitvarying *         Gen_param1,    /* The input value.                   */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    Period * Gen_RetVal;       /* The return result.                 */
    Period * Gen_InData;       /* The UDT input value.               */
    Period * Gen_OutData;      /* The transfer data.                 */

    /* Get the current connection. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodImportBinary."
        */
        DBDK_TRACE_ERROR( "PeriodImportBinary", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodImportBinary has been called.
    */
    DBDK_TRACE_ENTER( "PeriodImportBinary" );

    /* Allocate a new UDT for the return result. */
    Gen_RetVal = new_Period();

    /* Point to the transfer data. */
    Gen_InData = (Period *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

    /* Point to the output data. */
    Gen_OutData = (Period *)Gen_RetVal;

    /* Transfer the data value for Gen_InData->start. */
    mi_get_date( (mi_unsigned_char1 *)&Gen_InData->start, &Gen_OutData->start );

    /* Transfer the data value for Gen_InData->finish. */
    mi_get_date( (mi_unsigned_char1 *)&Gen_InData->finish, &Gen_OutData->finish );


    /*
    ** Write to the trace file indicating
    ** that PeriodImportBinary has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodImportBinary" );

    /* Close the connection. */
    mi_close( Gen_Con );

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodImportBinary checksum: 334086177  */

/****************************************************************
**
** Function name:
**
**    PeriodExportBinary
**
** Description:
**
**    The  exportbinary  function  is  used  to  support  bulk  copy  of
**    binary  data.  This function is the same as  the export  function,
**    except that it  operates on  internal  representations of the data
**    type.  This  function is usually only  provided  for large  object
**    data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
**    mi_lvarchar *   Gen_param1;        Pointer to the input text.
**    MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**    Period *  The constructed UDT value.
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodExportBinary FunctionId: -1
**
*****************************************************************
*/
mi_bitvarying *
PeriodExportBinary
(
Period *        Gen_param1,    /* The UDT value.                     */
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */
    mi_bitvarying * Gen_RetVal;        /* The return value.                  */
    Period * Gen_InData;       /* The transfer data.                 */
    Period * Gen_OutData;      /* The output data.                   */

    /* Get the current connection. */
    Gen_Con = mi_open( NULL, NULL, NULL );

    /* Verify that the connection has been established. */
    if( Gen_Con == 0 )
    {
        /*
        ** Opening the current connection has failed
        ** so issue the following message and quit.
        **
        **     "Connection has failed in PeriodExportBinary."
        */
        DBDK_TRACE_ERROR( "PeriodExportBinary", ERRORMESG1, 10 );

        /* not reached */
    }

    /*
    ** Write to the trace file indicating
    ** that PeriodExportBinary has been called.
    */
    DBDK_TRACE_ENTER( "PeriodExportBinary" );

    /* Allocate the output parcel. */
    Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Period ) );
    if( Gen_RetVal == 0 )
    {
        /*
        ** Memory allocation has failed so issue
        ** the following message and quit.
        **
        **     "Memory allocation has failed in PeriodExportBinary."
        */
        DBDK_TRACE_ERROR( "PeriodExportBinary", ERRORMESG2, 10 );

        /* not reached */
    }

    /* Point to the input data. */
    Gen_InData = Gen_param1;

    /* Point to the output data. */
    Gen_OutData = (Period *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

    /* Transfer the data value for Gen_OutData->start. */
    mi_put_date( (mi_unsigned_char1 *)&Gen_OutData->start, &Gen_InData->start );

    /* Transfer the data value for Gen_OutData->finish. */
    mi_put_date( (mi_unsigned_char1 *)&Gen_OutData->finish, &Gen_InData->finish );


    /*
    ** Write to the trace file indicating
    ** that PeriodExportBinary has successfully exited.
    */
    DBDK_TRACE_EXIT( "PeriodExportBinary" );

    /* Close the connection. */
    mi_close( Gen_Con );

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodExportBinary checksum: 819390793  */
/**
 ** ##########################################################################
 **
 **                         THE REAL WORK STARTS HERE 
 **
 ** ##########################################################################
 **
***/

/****************************************************************
**
** Function name:
**
**    PeriodEqual
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodEqual FunctionId: fb03a432-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodEqual
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    mi_integer      Gen_RetVal = MI_FALSE;  /* The return value.  */

    if ((Argument1 == NULL) || (Argument2 == NULL))
		return MI_FALSE;

    /**
     **    Intervals are equal if they have the same start and end.
     **/
    if ((Argument1->start  == Argument2->start) &&
        (Argument1->finish == Argument2->finish))
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}

mi_integer
PeriodNotEqual
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	mi_integer	Gen_RetVal;

	if ((Argument1 == NULL) || (Argument2 == NULL))
        	return MI_FALSE;

	switch(PeriodEqual(Argument1, Argument2, Gen_fparam))
	{
		case MI_FALSE:
			Gen_RetVal = MI_TRUE;
		 break;
		default:
			Gen_RetVal = MI_FALSE;
		 break;
	}
    return Gen_RetVal;
}

/* Warning: Do not modify. PeriodEqual checksum: 199489520  */

/****************************************************************
**
** Function name:
**
**    PeriodContains
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodContains FunctionId: fb03a43f-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodContains
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM     *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    mi_integer      Gen_RetVal = MI_FALSE;   /* The return value. */

    if ((Argument1->start  <= Argument2->start) &&
        (Argument1->finish >= Argument2->finish))
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodContains checksum: 509465718  */

/****************************************************************
**
** Function name:
**
**    PeriodWithin
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodWithin FunctionId: fb03a43c-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodWithin
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM     *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    mi_integer      Gen_RetVal  = MI_FALSE;     /* The return value.  */

    if ((Argument1->start  >= Argument2->start) &&
        (Argument1->finish <= Argument2->finish))
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodWithin checksum: 103056506  */

/****************************************************************
**
** Function name:
**
**    PeriodOverlap
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodOverlap FunctionId: fb03a433-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodOverlap
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM     *    gen_fParam
)
{
    mi_integer      Gen_RetVal = MI_FALSE;     /* The return value.  */

    if (!((Argument1->finish < Argument2->start) ||
          (Argument1->start  > Argument2->finish)))
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}
/* Warning: Do not modify. PeriodOverlap checksum: 106144766  */

/*
**  PeriodOverlapRetVal
**
**  Takes two Period arguments, and a third INTEGER OUT
**  parameter. If the two Period arguments overlap, it
**  returns MI_TRUE as a result, and into the OUT
**  parameter it places the number of days that the two
**  Overlap. If the two Periods do not Overlap the UDF
**  returns FALSE, and the OUT Parameter will hold a 
**  NULL.
**
**  This UDF is declared as follows:
**
CREATE FUNCTION Overlap (Period,Period, OUT INTEGER)
RETURNS boolean
WITH ( NOT VARIANT, PARALLELIZABLE )
EXTERNAL NAME
"$INFORMIXDIR/extend/bin/Period.bld(PeriodOverlapRetVal)"
LANGUAGE C;
**
**  And it would be used as follows, to calculate the
** total number of days that Reservations overlapped
** Conferences within some period of time.
**
**  SELECT  C.Conf_Name,
**          SUM(Calc_Days)
**    FROM Conferences C, Reservations R
**   WHERE Overlap(C.Duration,'01/01/2000 to 03/31/2000')
**     AND Overlap(C.Duration,R.Reservation, 
**                 Calc_Days # INTEGER )
**   GROUP BY C.Conf_Name;
**
**/
mi_integer
PeriodOverlapRetVal
(
Period *    Argument1,
Period *    Argument2,
mi_integer  * nRetInterval,
MI_FPARAM     *    gen_fParam
)
{
	mi_integer	Gen_RetVal;
	mi_fp_setargisnull(gen_fParam, 2, MI_TRUE);

	if (( Gen_RetVal = PeriodOverlap ( Argument1, 
                                       Argument2, 
                                       gen_fParam ))
        == MI_TRUE ) 
	{
		mi_fp_setargisnull(gen_fParam, 2, MI_FALSE);

		*nRetInterval = ((MIN( Argument1->finish, 
                               Argument2->finish )) -
                         (MAX( Argument1->start, 
                               Argument2->start)));
	}
	return Gen_RetVal;
}

/**
 ** These are the support functions. 
 **/
/****************************************************************
**
** Function name:
**
**    PeriodUnion
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodUnion FunctionId: fb03a43e-c1ae-11d0-a365-00aa000a2652
**
**  NOTE: OK. There is no problem with the 'third arg is the first arg'
**        here, because I only look at the start and finish together. 
**        
**
*****************************************************************
*/
mi_integer
PeriodUnion
(
Period *    Argument1,
Period *    Argument2,
Period *    Argument3,
MI_FPARAM     *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	Argument3->start  = ((Argument1->start <= Argument2->start)?Argument1->start:Argument2->start);
	Argument3->finish = ((Argument1->finish>= Argument2->finish)?Argument1->finish:Argument2->finish);

    return MI_OK;
}
/* Warning: Do not modify. PeriodUnion checksum: 404002806  */

/****************************************************************
**
** Function name:
**
**    PeriodInter
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodInter FunctionId: fb03a438-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodInter
(
Period *    Argument1,
Period *    Argument2,
Period *    Argument3,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{

	if (!((Argument1->finish < Argument2->start) ||
          (Argument1->start  > Argument2->finish)))
	{
		Argument3->finish = ((Argument1->finish<=Argument2->finish)?(Argument1->finish):(Argument2->finish));
		Argument3->start  = ((Argument1->start>=Argument2->start)?(Argument1->start):(Argument2->start));

		return MI_OK;
	}
	Argument3->start = 0;
	Argument3->finish = 0;
	return 0;

}
/* Warning: Do not modify. PeriodInter checksum: 903814729  */

/****************************************************************
**
** Function name:
**
**    PeriodSize
**
** Description:
**
** Special Comments:
**
**    Support routine for opaque type Period returns ?.
**
** Parameters:
**
** Return value:
**
**    mi_integer
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodSize FunctionId: fb03a439-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_integer
PeriodSize
(
Period *    Argument1,
mi_double_precision    *    Argument2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{

	if (( Argument1->finish == 0 ) && ( Argument1->start == 0))
	{
		*Argument2 = 0.0;
	} else {
		*Argument2 = (mi_double_precision)(Argument1->finish - Argument1->start);

		/*
		** Guard against the Zero.
		**/
		if (*Argument2 < 0.0000001 )
			*Argument2 = 0.0000001;

	}
	return MI_OK;

}
/* Warning: Do not modify. PeriodSize checksum: 597151136  */

/*************************************************************************
**
** Function name:
**
**    Hash
**
** Description:
**
**     This function returns the mi_integer hash value that allows 
**    for an efficient comparison of two value.
**
**     This is a very simply hashing function that is relatively
**    lightweight. 
**
**  
**/
mi_integer
PeriodHash(
Period *    Argument1,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    mi_integer    nResult = 0,
                  i = 0;
    mi_char    *    pCh;

    pCh = (mi_char *)Argument1;
 
    for(i=0;i<8;i++)              /* 8 is the SIZEOF the struct */
    {
           nResult ^= (nResult < 11 ^ nResult << 6 ^ pCh[i]);
    }
 
    return nResult;
}

/*************************************************************************
**
** Function name:
**
**     PeriodCmp
**
** Description:
**
**     This function is the Compare function for the data type. Although
**   this function is documented as being used in the B-Tree, it has
**   lots of uses in the engine, particularly in sort_distinct nodes,
**   for DISTINCT or UNION operations.
**
**/
mi_integer
PeriodCmp (
Period *    Arg1,
Period *    Arg2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    if ((Arg1->start < Arg2->start) ||
        ((Arg1->start == Arg2->start) &&
             (Arg1->finish < Arg2->finish)))
        return -1;
    else if ((Arg1->start == Arg2->start) &&
                 (Arg1->finish == Arg2->finish))
        return 0;
    else
        return 1;
}


/*************************************************************************
**
** Function name:
**
**    PeriodInt
**
**   Description:
**
**      This is a function which returns the int pair for the
**    date. The return is a text, because I'm too lazy to do the
**    right thing and write an entirely new date.
**
**
**/
mi_lvarchar *
PeriodInt(
Period *    Arg1,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    mi_string      *    pBuf;
    mi_lvarchar    *    pResult;

    pBuf = (mi_string *)mi_alloc(32);
    
    sprintf(pBuf,"%d %d",Arg1->start, Arg1->finish);

    pResult = mi_string_to_lvarchar(pBuf);

    return pResult;

}
/**************************************************************************
**
**   Function name:
**
**       PeriodStart
**
**   Description:
**
**       Takes a Period and returns the start date
**
**/
mi_date
PeriodStart(
Period *    Arg1,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    return Arg1->start;
}
/**************************************************************************
**
**   Function name:
**
**       PeriodFinish
**
**   Description:
**
**       Takes a Period and returns the finish date
**
**/
mi_date 
PeriodFinish(
Period *    Arg1,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    return Arg1->finish;
}
/*************************************************************************
**
** Function name:
**
**    PeriodIntInt
**
**   Description:
**
**      This is a function that returns a Period from a pair
**     of integers.
**   
**/
Period *
PeriodIntInt
(
mi_integer  Arg1, 
mi_integer  Arg2, 
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    Period * pRetVal;

    pRetVal = new_Period();

    pRetVal->start  = Arg1;
    pRetVal->finish = Arg2;

    Check_Period(pRetVal);

    return pRetVal;

}    

/*************************************************************************
**
** Function name:
**
**          Length
**
**    Description:
**
**      This returns the number of days in the interval.
**/
mi_integer
PeriodLength (
Period * Arg1,
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
	return (Arg1->finish - Arg1->start);
}
/*************************************************************************
**
** Function name:
**
**          Concat
**
** Description:
**
**          Takes two DateIntervals. Returns a new interval that is the
**         'convex hull' of the two date.
**
***************************************************************************
**/
Period *
PeriodConcat
(
Period * pdtArg1,
Period * pdtArg2,
MI_FPARAM *             Gen_fparam     /* Standard info - see DBDK docs.     */
)
{
    Period * pRetVal;

    pRetVal = PeriodIntInt(
				(((pdtArg1->start)>(pdtArg2->start))?(pdtArg2->start):(pdtArg1->start)),
				(((pdtArg1->finish)>(pdtArg2->finish))?(pdtArg1->finish):(pdtArg1->finish)),
				Gen_fparam
		    );

    Check_Period(pRetVal);

    return pRetVal;
}

/*************************************************************************
**
** Function name:
**
**   Gate_IntervalGetIntersect
**
** Description:
**
**    This is a wrapper function for the Intersect function. If the two
**  arguments do not have a proper intersection, then this returns a
**  NULL result.
**    
**/
Period *
PeriodGetIntersect (
Period * pArg1,
Period * pArg2,
MI_FPARAM     * Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    Period * pRetArg;
    mi_integer      nIntVal;

    pRetArg = new_Period();

    if ((nIntVal = PeriodInter(pArg1, pArg2, pRetArg, Gen_fparam) ) == MI_OK)
    	return (pRetArg);

	/*
	** The Inter function has returned an MI_ERROR. Therefore, there was
	** no overlap. Under these circumstances the right thing to do is to
	** return a NULL status. 
    **/

	mi_fp_setreturnisnull(Gen_fparam,0,MI_TRUE);
	return (Period *)NULL;

}
/*************************************************************************
**
** Function name:
**
**   PeriodGetUnion
**
** Description:
**
**    This is a wrapper function for the Union function.
**    
**/
Period *
PeriodGetUnion (
Period * pArg1,
Period * pArg2,
MI_FPARAM     * Gen_fparam  /* Standard info - see DBDK docs. */
)
{
    Period * pRetArg;
    mi_integer      nIntVal;

    pRetArg = new_Period();

    if (( nIntVal = PeriodUnion(pArg1, pArg2, pRetArg, Gen_fparam)) == MI_OK)
    	return (pRetArg);

	/*
	** The Union function has returned an MI_ERROR. Therefore, there was
	** no overlap. Under these circumstances the right thing to do is to
	** return a NULL status. 
    **/

	mi_fp_setreturnisnull(Gen_fparam,0,MI_TRUE);
	return (Period *)NULL;

}
/****************************************************************
**
** Function name:
**
**    PeriodBefore
**
** Description:
**
** Special Comments:
**
**    Returns mi_boolean iff First Period is BEFORE Second. That is,
**    if First->Finish < Second->Start
**
** Parameters:
**
** Return value:
**
**    mi_boolean
**
** History:
**
**    Apr 30, 1997 - Generated by BladeSmith Version 3.30.TG1.
**
** Identification:
**
**    Warning: Do not remove or modify this comment:
**        PeriodEqual FunctionId: fb03a432-c1ae-11d0-a365-00aa000a2652
**
*****************************************************************
*/
mi_boolean
PeriodBefore
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{

	mi_boolean	Gen_RetVal	=	MI_FALSE;

    if ((Argument1 == NULL) || (Argument2 == NULL))
		return MI_FALSE;

    /**
     **    Intervals are equal if they have the same start and end.
     **/
    if (Argument1->finish < Argument2->start)
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}
/****************************************************************
**
** Function name:
**
**    PeriodAfter
**
** Description:
**
** Special Comments:
**
**    Returns mi_boolean iff First Period is AFTER Second. That is,
**    if Second->Start > First->Finish
**
** Parameters:
**
** Return value:
**
**    mi_boolean
**
*****************************************************************
*/
mi_boolean
PeriodAfter
(
Period *    Argument1,
Period *    Argument2,
MI_FPARAM *    Gen_fparam  /* Standard info - see DBDK docs. */
)
{

	mi_boolean	Gen_RetVal	=	MI_FALSE;

    if ((Argument1 == NULL) || (Argument2 == NULL))
		return MI_FALSE;

    /**
     **    Intervals are equal if they have the same start and end.
     **/
    if (Argument1->start > Argument2->finish)
        Gen_RetVal = MI_TRUE;

    return Gen_RetVal;
}
/*************************************************************************
**
**      Function: new_period()
**
**   Description:
**
**      This creates a new Period, and does the appropriate checks.
**
**
*/

Period *
new_Period ()
{
	Period * pPeriod;
	MI_CONNECTION * Gen_Con;
    pPeriod = (Period *)mi_alloc( sizeof( Period ) );
    if( pPeriod == 0 )
    {
        /*
        ** Memory allocation has failed so issue
        ** the following message and quit.
        **
        **     "Memory allocation has failed in new_Period."
        */
		Gen_Con = mi_open ( NULL, NULL, NULL );
        DBDK_TRACE_ERROR( "new_Period", ERRORMESG2, 10 );
        /* not reached */
    }

	return pPeriod;
}

Period *
copy_Period ( Period * pPeriod )
{
	Period	*	pRetPeriod;

	pRetPeriod = new_Period();

	memcpy ( pRetPeriod, pPeriod, sizeof(Period) );
	return pRetPeriod;
}

/*************************************************************************
**
** Function name:
**
**           Check_Period
**
**   Description:
**
**           This function checks the correctness of the Period.
**          In the case of an error, this function throws an exception and
**          does not return.
**
**  
**/
void
Check_Period(
Period * pDI
)
{
    MI_CONNECTION * Gen_Con;           /* The current connection.            */

    if (pDI->start > pDI->finish)
    {
    	/* Get the current connection handle. */
    	Gen_Con = mi_open( NULL, NULL, NULL );
		mi_db_error_raise(Gen_Con, MI_EXCEPTION, "Period failed check");
/* not reached */
    }

}

mi_date
Period_Epoch ()
{
		return INT_MIN;
}

mi_date
Period_Forever()
{
		return INT_MAX;
}
/***********************************************************************
**  Function name:
**
**           Period_Start_is_Epoch
**
**   Description:
**
**      This function checks to see if the start of a Period is
**      set to the INT_MIN value, which indicates that it is not
**      bounded at that end.
*/
mi_boolean
Period_Start_is_Epoch ( Period * pPeriod )
{
	if ( pPeriod->start == Period_Epoch() ) 
		return MI_TRUE;

	return MI_FALSE;
}
/***********************************************************************
**  Function name:
**
**           Set_Period_Start_Epoch
**
**   Description:
**
**      This function sets the start of the Period to INT_MIN, which
**      conveys the fact that the period is unbounded at its start.
**
*/
void 
Set_Period_Start_Epoch_internal ( Period * pPeriod )
{
	pPeriod->start = Period_Epoch();
}
/*
** Remember: Do not modify the structure passed into the UDF. Always
** create a new copy and return that new copy.
*/
Period * 
Set_Period_Start_Epoch ( Period * pPeriod )
{
	Period	*	pRetPeriod;
	/* Remember: Do not modify Arg structure. Allocate memory for the UDT */
	/* copy data there, and modify it there.                              */
    pRetPeriod = copy_Period ( pPeriod );
	Set_Period_Start_Epoch_internal ( pRetPeriod );
	return pRetPeriod;
}
/***********************************************************************
**  Function name:
**
**           Period_Finish_is_Unbound
**
**   Description:
**
**      This function checks to see if the ending of the Period is
**      unbound.
**
*/
mi_boolean 
Period_Finish_is_Unbound ( Period * pPeriod )
{
	if ( pPeriod->finish == Period_Forever() ) 
		return MI_TRUE;

	return MI_FALSE;
}

/***********************************************************************
**  Function name:
**
**           Set_Period_Finish_Unbound
**
**   Description:
**
**      This function sets the finish of the Period to INT_MAX, which
**      conveys the fact that the period is unbounded at its finish.
**
*/
void 
Set_Period_Finish_Unbound_internal ( Period * pPeriod )
{
	pPeriod->finish=Period_Forever();
}

Period * 
Set_Period_Finish_Unbound ( Period * pPeriod )
{
	Period	*	pRetPeriod;
	/* Remember: Do not modify Arg structure. Allocate memory for the UDT */
	/* copy data there, and modify it there.                              */
    pRetPeriod = copy_Period ( pPeriod );
	Set_Period_Finish_Unbound_internal ( pRetPeriod );
	return pRetPeriod;
}


#ifdef __cplusplus

}

#endif
