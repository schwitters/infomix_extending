/*
** Title:          support.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         INFORMIX Software
** Created:        10/02/2000 14:18
** Description:    This is the generated support 'C' file.
** Comments:     
**                 This file contains all the support routines needed for the
**                 DataBlade.
**                 Changes should not be made to this file since this file is
**                 always regenerated.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Period.h"


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080010e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_sscanf
**
** Description:
**
**	This function converts formatted values.  The types converted are:
**
**		Type                    Format
**		==============================
**		gl_wchar_t                %W
**		gl_mchar_t                %C
**		mi_boolean                %b
**		mi_char                   %c
**		mi_date                   %D
**		mi_datetime               %T
**		mi_decimal/mi_numeric     %N
**		mi_double_precision       %lf
**		mi_int1                   %u1
**		mi_int8                   %8
**		mi_integer                %d
**		mi_interval               %I
**		mi_long                   %ld
**		mi_money                  %m
**		mi_real                   %f
**		mi_sint1                  %1
**		mi_smallint               %2
**		mi_string                 %s
**		mi_unsigned_integer       %x
**		mi_unsigned_smallint      %u2
**		mi_wchar                  %w
**
**	Conversion is performed from GLS text to the corresponding binary
**	representation.  The GLS text is assumed to be in the server locale.
**
**	Additional information about these data types may be found in
**	The Informix Guide to SQL: Syntax - Version 9.01.
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con           The database connection.
**	char *          Gen_Caller        Name of the calling function.
**	gl_mchar_t *    Gen_InData        The input string data.
**	mi_integer      Gen_InDataLen     The length of Gen_InData.
**	mi_integer      Gen_Width         Max length if data is text.
**	char *          Gen_Format        The data's format.
**	char *          Gen_Result        Place the result here.
**
** Return value:
**
**	gl_mchar_t *    The new scan position.
**
** History:
**
**	10/02/2000 - Generated by BladeSmith Version 4.00.TC2.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_sscanf FunctionId: 3AC0E360-5A81-11d0-A2E7-00AA0009BF87
**
********************************************************************************
*/
gl_mchar_t *
Gen_sscanf
(
MI_CONNECTION *            Gen_Con,                     /* The database connection.               */
char *                     Gen_Caller,                  /* Name of the calling function.          */
gl_mchar_t *               Gen_InData,                  /* The input string data.                 */
mi_integer                 Gen_InDataLen,               /* The length of Gen_InData.              */
mi_integer                 Gen_Width,                   /* Max length if data is text.            */
char *                     Gen_Format,                  /* The data's format.                     */
char *                     Gen_Result                   /* Place the result here.                 */
)
{
	gl_mchar_t *       Gen_In;                      /* Scanning ptr.                          */
	gl_mchar_t *       Gen_SaveIn;                  /* Save Gen_In here.                      */
	gl_mchar_t         Gen_NextChar;                /* Get the next char here.                */
	char *             Gen_InStart;                 /* Gen_In before advancement.             */
	gl_mchar_t *       Gen_Out;                     /* Place the GLS result here.             */
	mi_integer         Gen_ByteCount;               /* The number of bytes.                   */
	mi_integer         Gen_CharLen;                 /* Width of a character.                  */

	Gen_In        = Gen_InData;
	Gen_Out       = (gl_mchar_t *)Gen_Result;
	Gen_ByteCount = 0;

	/* Scan past non-format characters. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past and ignore white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format == '%' )
		{
			break;
		}

		/*
		**	The format character and the input string
		**	must match up to the format character.
		**	If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/* Check for no input data string. */
	if( *(char *)Gen_In == '\0' )
	{
		goto parse_error;
	}

	/* The following code now handles the various format types. */

	/* Check for an mi_string. */
	if( !strncmp( Gen_Format, "%s %n", 5 ) && Gen_Width )
	{
		if( '\"' != *Gen_In )
		{
			/*
			** Input parsing has failed so issue
			** the following message and quit.
			**
			** 	"Double-quoted string expected
			**	 in input in <Gen_Caller>."
			*/
			DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG7, 10 );

			/* not reached */
		}

		/* Advance past the leading quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Copy while there's sufficient room. */
		while( Gen_Width )
		{
			Gen_InStart = (char *)Gen_In;

			switch( *Gen_In )
			{
				/*
				** If '\"' is seen, check to see
				** if the next character is also
				** a '\"'. If so, '\"' is embedded.
				** Otherwise, it is EOS.
				*/
				case '\"':
					Gen_SaveIn = Gen_In;
					Gen_NextChar = *ifx_gl_mbsnext( Gen_In, 4 );
					Gen_In = Gen_SaveIn;
					if( Gen_NextChar == '\"' )
					{
						*Gen_Out++ = '\"';

						/* Advance past the first quote. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						/* Advance past the second space. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						break;
					}

					*Gen_Out = (char)'\0';

					/* Advance past the trailing quote. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					/* Advance past the trailing space. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					return Gen_In;

				case '\0':
					/*
					** Input parsing has failed so issue
					** the following message and quit.
					**
					** 	"Input string is not terminated with double-quote
					**	 in <Gen_Caller>."
					*/
					DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG9, 10 );

					/* not reached */

				default:
					Gen_CharLen = ifx_gl_mblen( Gen_In, 4);

					/* Make sure that there is enough space. */
					if( Gen_CharLen <= Gen_Width )
					{
						memcpy( Gen_Out, Gen_In, Gen_CharLen );
						Gen_Out += Gen_CharLen;
					}
					Gen_In  += Gen_CharLen;
					Gen_Width -= (char *)Gen_In - Gen_InStart;

					break;
			}
		}

		/*
		** Input string exceeded the string allocated
		** size so truncate the string.
		*/

		/*
		** Remove the last character and replace
		** with the string terminator.
		*/
		Gen_Out -= Gen_CharLen;

		/* Null terminate the output string. */
		*Gen_Out = (char)'\0';

		/* Advance to the trailing quote. */
		while( *Gen_In && *Gen_In != '"' )
		{
			/* Advance the character pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Check for trailing quote. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the trailing quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_integer. */
	else if( !strncmp( Gen_Format, "%d %n", 5 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */
		mi_integer   Gen_IntWidth;    /* Used to compute the width.      */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' integer. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_IntWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_IntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_IntWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a double value. */
	else if( !strncmp( Gen_Format, "%lf %n", 6 ) )
	{
		gl_mchar_t * Gen_DblPtr;     /* Scanning pointer.               */
		gl_mchar_t * Gen_DblPtr2;    /* Scanning pointer.               */
		mi_integer   Gen_DblWidth;   /* Keep track of the length.       */
		char         Gen_DblStr[80]; /* Hold the mi_double string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstod.
		*/
		for( Gen_DblPtr   = (gl_mchar_t *)Gen_DblStr,
		     Gen_DblPtr2  = Gen_In,
		     Gen_DblWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_DblWidth += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Copy the string and terminate. */
		memcpy( Gen_DblStr, Gen_DblPtr2, Gen_DblWidth );
		Gen_DblStr[Gen_DblWidth] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DblWidth == 0 )
		{
			goto parse_error;
		}

		/* Convert from text to a binary double value. */
		if( rstod( (char *)Gen_DblStr, (double *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for a float value. */
	else if( !strncmp( Gen_Format, "%f %n", 5 ) )
	{
		mi_double_precision Gen_dbl_number; /* Store an mi_float value here.   */
		mi_decimal          Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' float. */
		if( dectodbl( &Gen_dec_number, &Gen_dbl_number ) != 0 )
		{
			goto parse_error;
		}
		*(float *)Gen_Result = (float)Gen_dbl_number;

		/* Scan past the float value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a long value. */
	else if( !strncmp( Gen_Format, "%ld %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */
		mi_integer   Gen_LongWidth;   /* Used to compute the width.      */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' long. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_LongWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'		   ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_LongWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_LongWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an int8 value. */
	else if( !strncmp( Gen_Format, "%8 %n", 5 ) )
	{
		gl_mchar_t * Gen_Int8Ptr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_Int8Ptr2;    /* Scanning pointer.             */
		mi_integer   Gen_Int8Width;   /* Keep track of the length.     */
		mi_integer   Gen_Int8Ret;     /* ifx_int8cvasc return value.   */
		char         Gen_Int8Str[80]; /* Hold the mi_int8 string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by ifx_int8cvasc.
		*/
		for( Gen_Int8Ptr   = (gl_mchar_t *)Gen_Int8Str,
		     Gen_Int8Ptr2  = Gen_In,
		     Gen_Int8Width = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_Int8Width += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Copy the string and terminate. */
		memcpy( Gen_Int8Str, Gen_Int8Ptr2, Gen_Int8Width );
		Gen_Int8Str[Gen_Int8Width] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_Int8Width == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_int8 value from text to internal format. */
		Gen_Int8Ret = ifx_int8cvasc( Gen_Int8Str, strlen( Gen_Int8Str ),
			                     (ifx_int8_t *)Gen_Result );
		if( Gen_Int8Ret )
		{
			goto parse_error;
		}

		/* Scan past the int8 value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_Int8Width += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_int1 value. */
	else if( !strncmp( Gen_Format, "%u1 %n", 6 ) )
	{
		int Gen_Int1Result;

		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_Int1Result, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_int1 is [0, 255].
		*/
		if( Gen_Int1Result > 255 )
		{
			goto parse_error;
		}

		*(mi_int1 *)Gen_Result = Gen_Int1Result;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first blank. */
			if( ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an mi_smallint value. */
	else if( !strncmp( Gen_Format, "%2 %n", 5 ) )
	{
		int           Gen_SmallIntResult; /* The mi_smallint value.    */
		gl_mchar_t *  Gen_SmallIntPtr;    /* Scanning pointer.         */
		mi_integer    Gen_SmallIntWidth;  /* Keep track of the length. */
		mi_integer    Gen_ScanCount;      /* Number of bytes scanned.  */

		/* Use sscanf to scan the mi_smallint value. */
		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_SmallIntResult, &Gen_ScanCount ) )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_SmallIntPtr   = Gen_In,
		     Gen_SmallIntWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_SmallIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_smallint is
		** (+/-)32,767.
		*/
		if( Gen_SmallIntWidth > 6 )
		{
			goto parse_error;
		}

		/* Validate the value. */
		if( Gen_SmallIntResult < -32767 || 32767 < Gen_SmallIntResult )
		{
			goto parse_error;
		}

		/* Save the temporary value back into the result. */
		*(mi_smallint *)Gen_Result = Gen_SmallIntResult;

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_sint1 value. */
	else if( !strncmp( Gen_Format, "%1 %n", 5 ) )
	{
		int Gen_Int1Result;

		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_Int1Result, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_sint1 is [-127, 127].
		*/
		if( Gen_Int1Result < -127 || Gen_Int1Result > 127 )
		{
			goto parse_error;
		}

		*(int1 *)Gen_Result = Gen_Int1Result;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_unsigned_smallint value. */
	else if( !strncmp( Gen_Format, "%u2 %n", 6 ) )
	{
		int           Gen_USmallIntResult; /* The mi_smallint value.    */
		mi_integer    Gen_USmallIntWidth;  /* Keep track of the length. */
		mi_integer    Gen_ScanCount;       /* Number of bytes scanned.  */

		/* Use sscanf to scan the mi_unsigned_smallint value. */
		if( 1 != sscanf( (char *)Gen_In, "%d %n", &Gen_USmallIntResult, &Gen_ScanCount ) )
		{
			goto parse_error;
		}

		/* Ensure the number is not too wide. */
		for( Gen_USmallIntWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_USmallIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an mi_unsigned_smallint
		** is 0-65,535.
		*/
		if( Gen_USmallIntWidth > 6 )
		{
			goto parse_error;
		}

		/* Validate the value. */
		if( Gen_USmallIntResult < 0 || 65535 < Gen_USmallIntResult)
		{
			goto parse_error;
		}

		/* Save the temporary value back into the result. */
		*(mi_unsigned_smallint *)Gen_Result = Gen_USmallIntResult;

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/*
	** Check for a boolean value.  Only 'T' or 't'
	** (for True) and  'F' or 'f' (for False)  are
	** accepted.
	*/
	else if( !strncmp( Gen_Format, "%b %n", 5 ) )
	{
		if( *(char *)Gen_In == 'T' || *(char *)Gen_In == 't' )
		{
			*(char *)Gen_Result = 1;
		}
		else if( *(char *)Gen_In == 'F' || *(char *)Gen_In == 'f' )
		{
			*(char *)Gen_Result = 0;
		}
		else
		{
			goto parse_error;
		}

		Gen_ByteCount += sizeof(char);
		Gen_In += sizeof(char);

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an unsigned int value. */
	else if( !strncmp( Gen_Format, "%x %n", 5 ) )
	{
		mi_integer Gen_UIntWidth;  /* Used to compute the width.      */
		mi_decimal Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%u" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' unsigned integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the number and insure the number is not too wide. */
		for( Gen_UIntWidth = 0;
		     Gen_In < Gen_InData + Gen_InDataLen &&
			!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_UIntWidth;
		}

		/*
		** Check for a number that is too large.
		** The range of an unsigned integer is
		** (+/-)2,147,483,647.
		*/
		if( Gen_UIntWidth > 11 )
		{
			goto parse_error;
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a multibyte character of maximum length 4. */
	else if( !strncmp( Gen_Format, "%W %n", 5 ) )
	{
		/* Convert the multibyte character to gl_wchar_t. */
		Gen_ByteCount += ifx_gl_mbtowc( (gl_wchar_t *)Gen_Result, Gen_In, 4 );
		Gen_In        += ifx_gl_mbtowc( (gl_wchar_t *)Gen_Result, Gen_In, 4 );

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a wide-character. */
	/* Check for a multibyte character of max length GL_WCSIZE */
	else if( !strncmp( Gen_Format, "%w %n", 5 ) )
	{
		gl_wchar_t Gen_WideChar;
		int        Gen_NumBytes;

		/* Convert multibyte character to mi_wchar. */
		Gen_NumBytes = ifx_gl_mbtowc( (gl_wchar_t *) &Gen_WideChar, Gen_In, GL_WCSIZE );

		/* Check for an invalid character */
		if( Gen_NumBytes <= 0 )
		{
			goto parse_error;
		}

		/* Advance the input data pointer. */
		Gen_ByteCount += Gen_NumBytes;
		Gen_In        += Gen_NumBytes;

		/* Copy to the return result. */
		*((mi_wchar *)Gen_Result) = (mi_wchar) Gen_WideChar;

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_money value. */
	else if( !strncmp( Gen_Format, "%m %n", 5 ) )
	{
		gl_mchar_t *   Gen_MoneyPtr;     /* Scanning pointer.                */
		gl_mchar_t *   Gen_MoneyPtr2;    /* Scanning pointer.                */
		mi_lvarchar *  Gen_MoneyLV;      /* mi_lvarchar ptr to Gen_MoneyStr. */
		mi_money *     Gen_MoneyVal;     /* The binary money value.          */
		mi_integer     Gen_MoneyWidth;   /* Keep track of the length.        */
		char           Gen_MoneyStr[80]; /* Hold the mi_money string here.   */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by mi_money_to_binary.
		*/
		for( Gen_MoneyPtr   = (gl_mchar_t *)Gen_MoneyStr,
		     Gen_MoneyPtr2  = Gen_In,
		     Gen_MoneyWidth = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_MoneyWidth;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_MoneyStr, Gen_MoneyPtr2,
					(int)(Gen_In - Gen_MoneyPtr2) );
		Gen_MoneyStr[Gen_In - Gen_MoneyPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_MoneyWidth == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to mi_lvarchar. */
		Gen_MoneyLV = mi_string_to_lvarchar( Gen_MoneyStr );

		/* Check for an error in conversion. */
		if( Gen_MoneyLV == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to internal format. */
		Gen_MoneyVal = mi_money_to_binary( Gen_MoneyLV );

		/* Check for an error in conversion. */
		if( Gen_MoneyVal == NULL )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, Gen_MoneyVal, sizeof(mi_money) );

		/* ... and free the temporary money data values. */
		mi_free( Gen_MoneyLV );
		mi_free( Gen_MoneyVal );

		/* Scan past the money value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_numeric/mi_decimal value. */
	else if( !strncmp( Gen_Format, "%N %n", 5 ) )
	{
		gl_mchar_t * Gen_DecPtr;     /* Scanning pointer.                */
		gl_mchar_t * Gen_DecPtr2;    /* Scanning pointer.                */
		mi_decimal   Gen_DecVal;     /* The binary decimal value.        */
		mi_integer   Gen_DecIndex;   /* Keep track of the length.        */
		mi_integer   Gen_DecRet;     /* deccvasc return value.           */
		char         Gen_DecStr[80]; /* Hold the mi_decimal string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by deccvasc.
		*/
		for( Gen_DecPtr   = (gl_mchar_t *)Gen_DecStr,
		     Gen_DecPtr2  = Gen_In,
		     Gen_DecIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DecIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DecStr, Gen_DecPtr2,
					(int)(Gen_In - Gen_DecPtr2) );
		Gen_DecStr[Gen_In - Gen_DecPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DecIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_decimal value from text to internal format. */
		Gen_DecRet = deccvasc( Gen_DecStr, strlen( Gen_DecStr ), &Gen_DecVal );

		/* Check for an error in conversion. */
		if( Gen_DecRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DecVal, sizeof(mi_decimal) );

		/* Scan past the decimal value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'            ||
				 *Gen_In == 'E'            ||
				 *Gen_In == '.'            ||
				 *Gen_In == '+'            ||
				 *Gen_In == '-')           )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_date value. */
	else if( !strncmp( Gen_Format, "%D %n", 5 ) )
	{
		gl_mchar_t * Gen_DatePtr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_DatePtr2;    /* Scanning pointer.             */
		long         Gen_DateVal;     /* The binary date value.        */
		mi_integer   Gen_DateIndex;   /* Keep track of the length.     */
		mi_integer   Gen_RstrdateRet; /* rstrdate return value.        */
		char         Gen_DateStr[80]; /* Hold the mi_date string here. */
		int          Gen_NumBytes;    /* Number of bytes.              */

		/* The date value must be enclosed in quotes. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstrdate.
		*/
		for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
		     Gen_DatePtr2  = Gen_In,
		     Gen_DateIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the trailing quote. */
			if( *Gen_In == '"' )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_NumBytes = ifx_gl_mblen( Gen_In, 4 );
			Gen_In += Gen_NumBytes;

			/* Keep track of the length. */
			Gen_DateIndex += Gen_NumBytes;
			Gen_ByteCount += Gen_NumBytes;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
					(int)(Gen_In - Gen_DatePtr2) );
		Gen_DateStr[Gen_In - Gen_DatePtr2] = (char)'\0';

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Check for an empty string. */
		if( Gen_DateIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the date string to internal format. */
		Gen_RstrdateRet = rstrdate( Gen_DateStr, &Gen_DateVal );

		/* Check for an error in conversion. */
		if( Gen_RstrdateRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DateVal, sizeof(mi_date) );

		/* Scan past the date string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_datetime value. */
	else if( !strncmp( Gen_Format, "%T %n", 5 ) )
	{
		gl_mchar_t * Gen_DTPtr;      /* Scanning pointer.             */
		gl_mchar_t * Gen_DTPtr2;     /* Scanning pointer.             */
		mi_datetime  Gen_DTVal;      /* The binary date value.        */
		mi_integer   Gen_DTIndex;    /* Keep track of the length.     */
		int          Gen_DtcvascRet; /* dtcvasc return value.         */
		char         Gen_DTStr[80];  /* Hold the mi_date string here. */

		/* The date time value must be enclosed in quotes. */
		if( *Gen_In != '"' )
		{
			goto parse_error;
		}

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/*
		** Transfer the date value to a NULL terminated
		** buffer for conversion by dtcvasc.
		*/
		for( Gen_DTPtr   = (gl_mchar_t *)Gen_DTStr,
		     Gen_DTPtr2  = Gen_In,
		     Gen_DTIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the trailing quote. */
			if( *Gen_In == '"' )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DTIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DTStr, Gen_DTPtr2,
					(int)(Gen_In - Gen_DTPtr2) );
		Gen_DTStr[Gen_In - Gen_DTPtr2] = (char)'\0';

		/* Advance past the quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Check for an empty string. */
		if( Gen_DTIndex == 0 )
		{
			goto parse_error;
		}

 		/*
		** Set the  mi_datetime  qualifier.   It is
		** copied from the return value's qualifier.
		*/
		Gen_DTVal.dt_qual = ((mi_datetime *)Gen_Result)->dt_qual;

		/* Convert the mi_datetime value to internal format. */
		Gen_DtcvascRet = dtcvasc( Gen_DTStr, &Gen_DTVal );

		/* Check to insure that the conversion was successful. */
		if( Gen_DtcvascRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DTVal, sizeof(mi_datetime) );

		/* Scan past the datetime string. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Handle all other types using sscanf. */
	else
	{
		if( 1 != sscanf( (char *)Gen_In, Gen_Format, Gen_Out, &Gen_ByteCount ) )
		{
			goto parse_error;
		}

		/* Advance past the data. */
		Gen_In += Gen_ByteCount;

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Satisfy any remaining non-format characters in the format string. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past trailing white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/*
		**	The non-format character and the input data
		**	must match. If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*
	** Finally, scan past trailing spaces
	** and non-format characters.
	*/

	/* Scan past trailing white space in the data. */
	while( Gen_In < Gen_InData + Gen_InDataLen )
	{
		/* Stop at the first non-blank. */
		if( !ifx_gl_ismblank( Gen_In, 4 ) )
		{
			break;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}

	return Gen_In;

parse_error:

	/*
	** Input parsing has failed so issue
	** the following message and quit.
	**
	** 	"Input data format error in <Gen_Caller>."
	*/
	mi_db_error_raise ( Gen_Con, MI_EXCEPTION, "Input data error to Period/DT_Period");

	/* not reached */
	return NULL;
}
/* }}FUNCTION (#FF75) */


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080015e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_nstrwords
**
** Description:
**
**	This function counts the number of values in a formatted string.
**
** Parameters:
**
**	gl_mchar_t *       Gen_InData                   The data to scan.
**	mi_integer         Gen_InDataLen                Length of the data.
**
** Return value:
**
**	mi_integer                                      The new scan position.
**
** History:
**
**	10/02/2000 - Generated by BladeSmith Version 4.00.TC2.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_nstrwords FunctionId: 3AC0E361-5A81-11d0-A2E7-00AA0009BF87
**
********************************************************************************
*/
mi_integer
Gen_nstrwords
(
gl_mchar_t *               Gen_InData,                  /* The data to scan.                      */
mi_integer                 Gen_InDataLen                /* Length of the data.                    */
)
{
	mi_integer         Gen_WordCount;               /* The number of words present.           */
	gl_mchar_t *       Gen_In;                      /* Scanning pointer.                      */
	char *             Gen_DataCopy;                /* A NULL terminated copy.                */
	enum
	{
		DBDK_QUOTE,
		DBDK_ESCAPE,
		DBDK_WORD,
		DBDK_SPACE
	} Gen_state;       /* Parsing state.	*/

	/* Copy the data and NULL terminate it. */
	Gen_DataCopy = (char *)mi_alloc(Gen_InDataLen + 1);
	memcpy(Gen_DataCopy, Gen_InData, Gen_InDataLen);
	Gen_DataCopy[Gen_InDataLen] = (char)'\0';
	Gen_InData = (gl_mchar_t *)Gen_DataCopy;

	/* Begin counting the words. */
	Gen_WordCount = 0;

	/* Set the initial state. */
	Gen_state = DBDK_SPACE;

	/* Point to the beginning of the input text. */
	Gen_In = Gen_InData;

	do
	{
		switch ( Gen_state )
		{
			case DBDK_ESCAPE:
				Gen_state = DBDK_QUOTE;
				break;

			case DBDK_QUOTE:
				if( '\"' == *Gen_In )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_WORD:
				if( '\"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_SPACE:
				if( '\"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( !ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_WordCount++, Gen_state = DBDK_WORD;
				}
				break;
		}

		/* Advance the pointer. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}
	while( *Gen_In != '\0' );

	/* Free the copy of the data. */
	mi_free(Gen_DataCopy);

	return Gen_WordCount;
}
/* }}FUNCTION (#DJUM) */


/* {{FUNCTION(11190130-cf56-11d1-9ce6-080025e6b366) (CopySection) */
/*******************************************************************************
**
** Function name:
**
**	Gen_Trace
**
** Description:
**
**	This function writes trace information to the trace file.
**
**	Complete information about tracing may be found in
**	the INFORMIX-DataBlade API, User's Guide, Version 9.0.
**
**	To enable tracing, you must first create a trace class
**	by inserting a record into the systraceclasses system
**	catalog:
**
**		insert into informix.systraceclasses(name)
**		values('Period');
**
**	The name of the trace file must be set. If the file name
**	is not set, the server uses a default file name:
**	the session id followed by ".trc" in the /tmp directory.
**	Use "onstat -g ses" to get the session id.
**
**	The following code snippet may be used to set the name
**	of the output trace file from within your code.
**
**		mi_tracefile_set( "/yourpath/yourfile.trc" );
**
**	Alternately, the TraceSet_Period procedure may be
**	used from SQL to set the trace file name and trace threshold
**	level.  See this procedure for more details.
**
**	To insure that tracing text  actually  appears in the
**	output trace file, SERVER_LOCALE, CLIENT_LOCALE,  and
**	DB_LOCALE must be set in the environment to the
**	appropriate locale (e.g., "en_us.1252").
**
** Parameters:
**
**	MI_CONNECTION *    Gen_Con        The database connection.
**	char *             Gen_Caller     Call originated from this routine.
**	char *             Gen_FileName   Call originated in this file.
**	mi_integer         Gen_LineNo     Call originated on this line.
**	char *             Gen_MsgNo      ERRORMESG number.
**	char *             Gen_Class      Tracing class.
**	mi_integer         Gen_Threshold  Tracing threshold.
**	mi_integer         Gen_MsgType    MI_SQL | MI_MESSAGE | DBDK_TRACE.
**
** Return value:
**
**	None.
**
** History:
**
**	10/02/2000 - Generated by BladeSmith Version 4.00.TC2.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_Trace FunctionId: 59DEDB71-760B-11d0-A2EC-00AA0009BF87
**
********************************************************************************
*/
void
Gen_Trace
(
MI_CONNECTION *            Gen_Con,       /* The database connection.               */
char *                     Gen_Caller,    /* Call originated from this routine.     */
char *                     Gen_FileName,  /* Call originated in this file.          */
mi_integer                 Gen_LineNo,    /* Call originated on this line.          */
char *                     Gen_MsgNo,     /* ERRORMESG number.                      */
char *                     Gen_Class,     /* Tracing class.                         */
mi_integer                 Gen_Threshold, /* Tracing threshold.                     */
mi_integer                 Gen_MsgType    /* MI_SQL | MI_MESSAGE | DBDK_TRACE.      */
)
{
	MI_CONNECTION *    Gen_TraceCon;  /* The database connection.           */

	/* Route the message to the trace file? */
	if( Gen_MsgType & DBDK_TRACE )
	{
		/* Write the message to the trace file. */
		GL_DPRINTF( Gen_Class,
			    Gen_Threshold,
			    (
			        Gen_MsgNo,
			        "FUNCTION%s", Gen_Caller,      /* Substitute the caller here.    */
			        "FILENAME%s", Gen_FileName,    /* Substitute the file name here. */
			        "LINENO%d",   Gen_LineNo,      /* Substitute the line info here. */
			        MI_LIST_END                    /* Terminate the list!!           */
			    )
			  );
	}

	/* Mask off the mi_db_error_raise flags. */
	Gen_MsgType &= 0xffff;

	/* Route the message back to the user? */
	if( Gen_MsgType )
	{
		/*
		** Obtain a connection for mi_db_error_raise.
		** If available, use the connection that  has
		** already been established.
		*/
		if( Gen_Con == NULL )
		{
			/* No connection is available so open a new one. */
			Gen_TraceCon = mi_open( NULL, NULL, NULL );
		}
		else
		{
			Gen_TraceCon = Gen_Con;
		}

		/* If requested, also write the message to the user. */
		mi_db_error_raise ( Gen_TraceCon,              /* This is the connection handle. */
			                Gen_MsgType,               /* Route to the user.             */
			                Gen_MsgNo,                 /* Print this message.            */
			                "FUNCTION%s", Gen_Caller,  /* Substitute the caller here.    */
			                (char *)NULL );            /* Terminator.                    */

		/*
		** mi_db_error_raise may not return
		** and this line may not be reached.
		*/
	}
}
/* }}FUNCTION (#Q4FA) */


/*************************************************************************
**
**   These are a set of sub-routines to make working with the
**  ifx_int8_t a bit less painful. 
**
*/
mi_integer
ifx_int8mod ( ifx_int8_t * n8Val,
			  ifx_int8_t * n8Div,
			  ifx_int8_t * n8Result
)
{
	ifx_int8_t n8LocTmp;

	(void)ifx_int8div( n8Val, n8Div, &n8LocTmp);
	(void)ifx_int8mul( &n8LocTmp, n8Div, &n8LocTmp );
	(void)ifx_int8sub( n8Val, &n8LocTmp, n8Result );

	return MI_OK;
}

mi_integer
ifx_int8toInterval ( ifx_int8_t	 *	pint8Arg,
					 mi_interval *  pintRet
				   )
{
	mi_integer	nDays, nHrs, nMin, nSecs;
	mi_interval * pintVal;
	ifx_int8_t	n8TmpVal[3], n8DivVal;
	mi_char		pchBuf[64];		

	memcpy( &(n8TmpVal[1]), pint8Arg, sizeof(ifx_int8_t));
	/*
	** Seconds = Val % 60;
	*/
	(void)ifx_int8cvint( 60, &n8DivVal );
	(void)ifx_int8mod( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[2]));

	if ((ifx_int8toint( &(n8TmpVal[2]), &(nSecs))) != 0 )
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: Seconds derivation failed");
		/* not reached */
	}
	/*
	** Minutes = ((Val - Seconds ) / 60 ) % 60 
	*/
	(void)ifx_int8sub( &(n8TmpVal[1]), &(n8TmpVal[2]), &(n8TmpVal[1]));
	(void)ifx_int8div( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[1]));
	(void)ifx_int8mod( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[2]));

	if ((ifx_int8toint( &(n8TmpVal[2]), &(nMin))) != 0 )
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: Minutes derivation failed");
		/* not reached */
	}

	/*
	** Minutes = ((Val - Minutes - Seconds ) / 60 ) % 60 
	*/
	(void)ifx_int8sub( &(n8TmpVal[1]), &(n8TmpVal[2]), &(n8TmpVal[1]));
	(void)ifx_int8div( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[1]));
	(void)ifx_int8mod( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[2]));

	if ((ifx_int8toint( &(n8TmpVal[2]), &(nHrs))) != 0 )
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: Hours derivation failed");
		/* not reached */
	}
		/*
	** Days = (Val - Hours - Minutes - Seconds ) / 24
	*/
	(void)ifx_int8sub( &(n8TmpVal[1]), &(n8TmpVal[2]), &(n8TmpVal[1]));
	(void)ifx_int8cvint( 24, &n8DivVal );
	(void)ifx_int8div( &(n8TmpVal[1]), &n8DivVal, &(n8TmpVal[2]));

	if ((ifx_int8toint( &(n8TmpVal[2]), &(nDays))) != 0 )
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: Days derivation failed");
		/* not reached */
	}
	/*
	** Callibrate the mi_interval
	*/
	sprintf(pchBuf, "%d %d:%d:%d", nDays, nHrs, nMin, nSecs);
    if (( pintVal = mi_string_to_interval ( pchBuf,
		                                   "interval day(8) to second")) == NULL)
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: Interval Derivation failed");
	}
	memcpy( pintRet, pintVal, sizeof(mi_interval));

	return MI_OK;
}

/*
**
*/
mi_integer
ifx_invtoInt8 ( mi_interval *  pInvArg,
				ifx_int8_t	*  pint8Ret
			  )
{
	mi_char       * pchIntSize;
	mi_integer	  nDays, nHrs, nMin, nSec;
	ifx_int8_t	  n8TmpVal1, n8TmpVal2, n8TmpVal3;

	/*  
	**   OK. The hassle is that the datetime.h stuff doesn't present
	** any built-in facilities that do anything useful with the 
	** mi_interval,like extract stuff from it. So this code gets 
	** this stuff from scratch. 
	**
	**   Fortunately, the way INTERVAL strings work looks pretty easy.
	** In this case the format is "DAYS HRS:MIN:SEC". The size of the 
	** DT_Periop is the number of seconds in the interval.
	**
	*/
	if (( pchIntSize = mi_interval_to_string ( pInvArg )) == NULL )
	{
		mi_db_error_raise(NULL, MI_EXCEPTION,
					      "Error:  invalid interval");
		/* not reached */
	}
	if ( 4 != sscanf( (char *)pchIntSize, "%d %d:%d:%d", &nDays, &nHrs, &nMin, &nSec))
	{
		mi_db_error_raise( NULL, MI_EXCEPTION,
			               "Error: sscanf failed in ifx_invtoInt8");
	}

	(void)ifx_int8cvint( (mi_integer)0, pint8Ret);

	(void)ifx_int8cvint( (mi_integer)nDays, &n8TmpVal1);
	(void)ifx_int8cvint( (mi_integer)(24*60*60), &n8TmpVal2);
	(void)ifx_int8mul  ( &n8TmpVal1, &n8TmpVal2, &n8TmpVal3);
	(void)ifx_int8add  ( pint8Ret, &n8TmpVal3, pint8Ret );

	(void)ifx_int8cvint( (mi_integer)nHrs, &n8TmpVal1);
	(void)ifx_int8cvint( (mi_integer)(60*60), &n8TmpVal2);
	(void)ifx_int8mul  ( &n8TmpVal1, &n8TmpVal2, &n8TmpVal3);
	(void)ifx_int8add  ( pint8Ret, &n8TmpVal3, pint8Ret );

	(void)ifx_int8cvint( (mi_integer)nMin, &n8TmpVal1);
	(void)ifx_int8cvint( (mi_integer)(60), &n8TmpVal2);
	(void)ifx_int8mul  ( &n8TmpVal1, &n8TmpVal2, &n8TmpVal3);
	(void)ifx_int8add  ( pint8Ret, &n8TmpVal3, pint8Ret );

	(void)ifx_int8cvint( (mi_integer)nSec, &n8TmpVal1);
	(void)ifx_int8add  ( pint8Ret, &n8TmpVal1, pint8Ret );

	return MI_OK;
}

/*****************************************************************************
 * Function:         RtreeInfo
 *
 * Description:      Support function used to return requested Information
 *                   to R-tree.
 *
 * Arguments:
 *   dummy_obj     - NULL; only used to form unique func. signature
 *
 *   operation_ptr - ptr to string that represents the operation.
 *
 *   opclass_ptr   - ptr to string that represents the opclass name.
 *
 *   answer_ptr    - pointer to the pointer to the structure used to
 *                   return information to R-tree.
 *                   answer_ptr is a "pointer to a pointer" to make
 *                   the interface generic to support later operations
 *                   to implement which the blade might need to allocate
 *                   memory and return its address to R-tree.
 *                   For the operation "strat_func_substitutions",
 *                   memory is allocated  by R-tree.
 *
 * Support function slot no: 8
 *
 * Return values: MI_OK              - Success, operation supported.
 *                MI_ERROR           - Error.
 *                RLT_OP_UNSUPPORTED - operation not supported.
 *
 *****************************************************************************/

#define RLT_OP_UNSUPPORTED 1

UDREXPORT mi_integer
D_DT_RtreeInfo(
    mi_lvarchar  *dummy_obj,
    mi_lvarchar  *operation_ptr,
    mi_lvarchar  *opclass_ptr,
    mi_lvarchar  *answer_ptr,
    MI_FPARAM    *fp
    )
{
    mi_integer    status = MI_OK;
    mi_string    *operation;
    mi_string    *opclass;

    operation = mi_lvarchar_to_string(operation_ptr);
    opclass   = mi_lvarchar_to_string(opclass_ptr);

    if (operation == NULL || opclass == NULL)
    {
        status = MI_ERROR;
        goto bad;
    }

    /* Check for known opclass */
    if ( (strcmp(opclass,"period_ops") != 0) &&
		 (strcmp(opclass,"dt_period_ops") != 0 ))
    {
        status = MI_ERROR;  /* Unknown opclass */
        goto bad;
    }

    if (strcmp(operation,"strat_func_substitutions") == 0)
    {
        /*
         * Mapping from strategy function to be used on leaf (data) items
         * to the strategy function to use on internal index nodes
         */
        mi_integer *answer = NULL;

        if (answer_ptr == NULL)
            goto done; /* Operation is supported */

        /* Memory for 64 slots is allocated by R-tree. For later
         * operations, we might need to allocate the return
         * structure and set its address.
         */
        answer = (mi_integer*) mi_get_vardata((mi_lvarchar*)
                                              (mi_get_vardata(answer_ptr)));
        if (answer == NULL)
        {
            status = MI_ERROR;
            goto bad;
        }
		/*
		**  An abundance of optimizations are possible here. For
		** example, the Before and After Touches routines do not need
		** the full overlaps. It would be enough to find the entries
		** where the end of the entry overlaps. However, this is a
		** probably best left for Version 2.0.
		*/
                          /* LEAF                INTERNAL         */
        answer[0]  = 0;   /* OverlapTouches      OverlapTouches   */
        answer[1]  = 2;   /* Equal               ContainsTouches  */
        answer[2]  = 2;   /* ContainsTouches     ContainsTouches  */
        answer[3]  = 0;   /* WithinTouches       OverlapsTouches  */
        answer[4]  = 0;   /* OverlapTRetVal      OverlapsTouches  */
        answer[5]  = 2;   /* ContainsNTouches    ContainsTouches  */
        answer[6]  = 0;   /* WithinNTouches      OverlapsTouches  */
        answer[7]  = 0;   /* OverlapsNTouches    OverlapsTouches  */
        answer[8]  = 0;   /* OverlapsNTouchesRV  OverlapsTouches  */
		answer[9]  = 0;   /* BeforeTouches       OverlapsTouches  */
        answer[10] = 0;   /* AfterTouches        OverlapsTouches  */

     }
	else
	{
		       status = RLT_OP_UNSUPPORTED; /* operation not recognized */
	}
  done:
  bad:
    if (operation)
        mi_free(operation);
    if (opclass)
        mi_free(opclass);

    return status;


}


#ifdef __cplusplus

}

#endif


