/*
** Title:          idn_socket2
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        07/08/1998 08:52
** Description:    This is the generated 'C' file for the idn_socket2 DataBlade.
** Comments:       Generated for project idn_socket2.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "idn_socket2.h"

/* These are needed to support the socket stuff */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/param.h>
#include <errno.h>
 
/* This one is needed for fork() */
#include <unistd.h>
 
/* Function Prototype */
mi_integer idn_start_socket_server(struct sockaddr_in *, int *);

/* {{FUNCTION(90fa7ee0-167b-11d2-b574-00a024e37610) (MergeSection) */

    /****************************************************************
**
** Function name:
**
**	idnSock2Release
**
** Description:
**
**	Identifies the current release level.
**
** Special Comments:
**
**	Entrypoint for the SQL routine idnSock2Release () returns lvarchar.
**
** Parameters:
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	07/08/1998 - Generated by BladeSmith Version 3.60.TC1B1.
**
** Identification:
**
** NOTE:
**
**  BladeSmith will add and remove paramaters from the function prototype,
**	and will generate tracing calls.  ONLY EDIT code in blocks marked
**	Your_<section>.  Any other modifications will require manual merging.
**
*****************************************************************
*/
mi_lvarchar *idnSock2Release(MI_FPARAM *Gen_fparam)
{
	mi_lvarchar*    Gen_RetVal;       /* The return value. */
	MI_CONNECTION * Gen_Con;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_string	*cur_release = "idn_socket2.1.1";

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in idnSock2Release."
		*/
		DBDK_TRACE_ERROR( "idnSock2Release", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that idnSock2Release has been called.
	*/
	DBDK_TRACE_ENTER( "idnSock2Release" );


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	{

	Gen_RetVal = mi_string_to_lvarchar(cur_release);

	}
	/* ------ }}Your_Code (#JDLN) END ------ */

	/*
	** Write to the trace file indicating
	** that idnSock2Release has successfully exited.
	*/
	DBDK_TRACE_EXIT( "idnSock2Release" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#9FJ2) */



/* {{FUNCTION(26001b90-e8ee-11d1-b54f-00a024e37610) (MergeSection) */

    /****************************************************************
**
** Function name:
**
**	idnCallSocket2
**
** Description:
**
**      The first time this routine is called from within the current
**      virtual processor, it opens a socket, saves the port number,
**      and forks off a socket client. 
**
**      If this routine has already run once from within the current
**      virtual processor, the socket server and client are already running.
**      We know this is the case because we have stored the socket server's
**      port number in a static variable. (Static variables stay with the
**      virtual processor rather than with the UDR.) So, if the static
**      variable contains a port number, we just use it, and proceed to
**      carry out our small transaction with the running socket server
**	and (externally running) client.
**
** Special Comments:
**
**	Entrypoint for the SQL routine idnCallSocket2 (lvarchar) returns lvarchar.
**
** Parameters:
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	07/08/1998 - Generated by BladeSmith Version 3.60.TC1B1.
**
** Identification:
**
** NOTE:
**
**  BladeSmith will add and remove paramaters from the function prototype,
**	and will generate tracing calls.  ONLY EDIT code in blocks marked
**	Your_<section>.  Any other modifications will require manual merging.
**
*****************************************************************
*/
mi_lvarchar *idnCallSocket2
(
mi_lvarchar *           argstring,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_lvarchar*    Gen_RetVal;       /* The return value. */
	MI_CONNECTION * Gen_Con;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

#define BUFSIZE 100
#define SOCK2ADDR "$INFORMIXDIR/extend/idn_socket2.1.1"

        struct sockaddr_in sad;            /* socket server address       */
        struct sockaddr_in cad;            /* socket client address       */
        int alen;                          /* address length              */

        /* ************************************************************** **
        ** Note that the socket descriptors and the port are *static*     **
        ** variables. This contradicts the "safe guidelines" rule against **
        ** static variables, which is one reason this routine needs to    **
        ** run in a named VP. We use statics because we want the socket   **
        ** descriptors and the port to persist beyond the life of this    **
        ** execution of the udr.                                          **
        ** ************************************************************** **
        */
        static int sd, sd2;                /* socket descriptors          */
	static int socket_server_port = 0; /* socket server's port number */

        mi_string inbuf[BUFSIZE];          /* buffer for data from server */
        mi_string *outbuf;                 /* data sent to the server     */
        mi_integer n;                      /* number of bytes received    */
        mi_integer i;                      /* general purpose counter     */
        char errbuf[80];                   /* place to put error messages */
	char sock_client_cmd[1024];        /* cmd to start client prgm.   */

	char  *logfile = "/tmp/idn_sockserver.log"; /* path for socket log   */
	FILE  *fd;               /* file descriptor for logfile           */

	char *idnGetTime();

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in idnCallSocket2."
		*/
		DBDK_TRACE_ERROR( "idnCallSocket2", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that idnCallSocket2 has been called.
	*/
	DBDK_TRACE_ENTER( "idnCallSocket2" );


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
        {
 
        /* Start by opening the socket server log file */
        if ((fd = fopen(logfile, "ab")) == NULL)
        {
          sprintf(errbuf, "Unable to open socket server log file: %s",
	          logfile);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
        }

        if (socket_server_port == 0)
        {
            /* ***********************************************************
            ** socket server isn't initialized yet on this vp. start it,
            ** and also start the external socket client.
            ** ***********************************************************
            */
            /* start up the socket server */
            if ((socket_server_port = idn_start_socket_server(&sad, &sd)) < 0)
            {
                /* couldn't start socket server. bail out. */
                sprintf(errbuf, "Unable to start socket server.");
                mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
                /* not reached */
            }

            (void)fprintf(fd, "\n%s: Socket server started on port: %d\n",
                  idnGetTime(), socket_server_port);
            (void)fflush(fd);

            /* set the socket server port to listen */
            if (listen(sd, 1) < 0)
            {
               (void)fprintf(fd, "%s: listen failed.\nExiting.\n",
                             idnGetTime());
               (void)fflush(fd);
 
               sprintf(errbuf, "listen failed.");
               mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
               /* not reached */
            }
            else
            {
               (void)fprintf(fd, "%s: %d: Server is listening...\n", 
                     idnGetTime(), socket_server_port);
               (void)fflush(fd);
            }


            /* fire off the socket client */
            sprintf(sock_client_cmd, "cd %s; ./idnSock2Client %d",
                    SOCK2ADDR, socket_server_port);

            (void)fprintf(fd, "%s: Starting client with command:\n\t%s\n",
                  idnGetTime(), sock_client_cmd);
            (void)fflush(fd);
            if (system(sock_client_cmd) < 0)
            {
                /* couldn't start socket client. bail out. */
                sprintf(errbuf, "Unable to start socket client.");
                mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
                /* not reached */
            }

            /* ***********************************************************
            ** Set the socket server to wait for the client to check in.
            ** ***********************************************************
            */
            alen = sizeof(cad);

            if ((sd2 = accept(sd, (struct sockaddr *)&cad, &alen)) < 0)
            {
               i = 0;
               if (errno == EINTR)
               {
                 i++;
                 (void)fprintf(fd, "%s: %d: accept failed with EINTR.\n",
                               idnGetTime(), socket_server_port);
                 while ((i < 5) && (errno == EINTR))
                 {
                   i++;
                   (void)fprintf(fd, "%s: %d: retrying...\n",
                               idnGetTime(), socket_server_port);
                   sd2 = accept(sd, (struct sockaddr *)&cad, &alen);
                 }
               }

               if (errno != 0)
               {
                 (void)fprintf(fd, 
                           "%s: %d: accept failed with %d.\nExiting.\n", 
                           idnGetTime(), socket_server_port, errno);
                 (void)fflush(fd);

                 sprintf(errbuf, "accept failed.");
                 mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
                 /* not reached */
               }
            }

            memset(inbuf, 0, (size_t)BUFSIZE);
            n = recv(sd2, inbuf, BUFSIZE, 0);
            (void)fprintf(fd, 
                          "%s: %d: received %d bytes: %s\n", 
                          idnGetTime(), socket_server_port, n, inbuf);
            (void)fflush(fd);
 
            /* ****************************************************************
            ** Ok. Now the socket server has been started up for this VP, a
            ** socket client has been spawned as an external process, and we
            ** know the two are communicating. The socket client is waiting
            ** for a response to its ping; we'll pass it the text string that
            ** was input to our SQL routine.
            **
            ** The socket server and client will remain in this state after
            ** the UDR returns, so next time we call the UDR all we need to
            ** do is pass the text string to the socket client and get back
            ** its response.
            ** ****************************************************************
            */
        }

        outbuf = mi_lvarchar_to_string(argstring);
        if ((n = send(sd2, outbuf, strlen(outbuf), 0)) < 0)
        {
           (void)fprintf(fd, 
                         "%s: %d: send failed with %d.\nExiting.\n", 
                         idnGetTime(), socket_server_port, errno);
           (void)fflush(fd);

           sprintf(errbuf, "send failed.");
           mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
           /* not reached */
        }
        else
        {
           (void)fprintf(fd, 
                         "%s: %d: sent %d bytes to the socket client\n",
                         idnGetTime(), socket_server_port, strlen(outbuf));
           (void)fprintf(fd, 
                         "%s: %d: ...text sent: %s\n",
                         idnGetTime(), socket_server_port, outbuf);
           (void)fflush(fd);
        }

        memset(inbuf, 0, (size_t)BUFSIZE);
        n = recv(sd2, inbuf, BUFSIZE, 0);
        (void)fprintf(fd, 
                      "%s: %d: received %d bytes: %s\n", 
                      idnGetTime(), socket_server_port, n, inbuf);
        (void)fflush(fd);

        if (strcmp(inbuf, "Client shutting down.") == 0)
        {
            /* free up the server port */
            close(socket_server_port);
            socket_server_port = 0;
        }

        /* ********************************************************************
        ** Now all we need to do is put the returned string (inbuf) into an
        ** mi_lvarchar and return it.
        ** ********************************************************************
        */
        Gen_RetVal = mi_string_to_lvarchar(inbuf);
 
        }
	/* ------ }}Your_Code (#JPME) END ------ */

	/*
	** Write to the trace file indicating
	** that idnCallSocket2 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "idnCallSocket2" );

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#FJ5H) */

/* ***********************************************************************
** idn_start_socket_server
**
** Description: External routine to start the socket server. Returns 0 on
**              success, -1 on failure.
**
**              If it succeeds, this routine allocates a socket, returning
**              its port number.
** ***********************************************************************
*/
mi_integer
idn_start_socket_server(struct sockaddr_in *sad, int *sd)
{
 
    struct sockaddr_in sad_info; /* server address info            */
    int    size;             /* for sizeof argument to getsockname */
    int    one = 1;
 
    /* Create a socket */
    memset((char *)sad, 0, sizeof(*sad)); /* clear sockaddr structure */
    sad->sin_family = AF_INET;             /* set family to Internet   */
    sad->sin_addr.s_addr = htons(INADDR_ANY);  /* take any available port */
 
    *sd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (*sd < 0)
    {
        return -1;
    }

    /* set options to keep the socket alive an to reuse its address when */
    /* it's gone.                                                        */
    (void)setsockopt(*sd, SOL_SOCKET, SO_KEEPALIVE, (char *)&one, sizeof(one));
    (void)setsockopt(*sd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one));
 
    /* Bind it */
    if (bind(*sd, (struct sockaddr *)sad, sizeof(*sad)) < 0)
    {
        return -1;
    }
 
    /* Get the port number that the system assigned us */
    size = sizeof(sad_info);
    if (getsockname(*sd, (struct sockaddr *) &sad_info, &size) < 0)
    {
        return -1;
    }
 
    socket_server_port = sad_info.sin_port;
 
    return socket_server_port;
}

/* ***********************************************************************
** idnGetTime() 
**
** Simple utility to return a timestamp.
** ***********************************************************************
*/
char *
idnGetTime()
{
    time_t      t;
    char        *ret;
 
    t = time(NULL);
    ret = asctime(localtime(&t));
 
    /* get rid of new-line that unix adds! */
    ret[strlen(ret) - 1] = 0;
 
    return(ret);
}

#ifdef __cplusplus

}

#endif
