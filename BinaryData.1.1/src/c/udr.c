/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        08/23/1999 10:26
** Description:    This is a generated source file for the BinaryData DataBlade module.
** Comments:       Generated for project BinaryData.1.1
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <fcntl.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "BinaryData.h"


/* {{FUNCTION(40a768af-50d7-11d3-b680-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Procedure name:
**
**	WriteIt
**
** Description:
**
** Special Comments:
**
**
**	A stack size of 32,767 bytes  has  been  requested  for
**	the routine.  Normally, this is sufficient memory for most
**	invocations of your UDR.  If you intend, however, to  call
**	this routine recursively or other routines that use  large
**	or unknown stack sizes, you should use mi_call().  mi_call
**	checks to insure that sufficient stack space is available.
**	For  more  details  regarding  this   function,  look  in:
**	The  DataBlade  API Programmer's  Manual  (see Stack Space
**	Allocation in Chapter 11).
**	
** Parameters:
**
**	None
**
** History:
**
**	08/23/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT void
WriteIt
(

mi_bitvarying *              image,
MI_FPARAM *                  Gen_fparam       /* Standard info - see DBDK docs.          */
)
{
	MI_CONNECTION *      Gen_Con;         /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

        mi_integer      datalen;          /* length of the input */
        void            *databits;        /* the data */
        mi_integer      fd;               /* file descriptor */
        mi_integer      result;
        mi_string       *file_path;       /* write the file to here */

	/* ------ }}Your_Declarations (#0000) END ------             */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        file_path = (char *)mi_alloc(19);
        (void)strcpy(file_path, "/tmp/image_out.jpg");
 
        fd = mi_file_open(
                file_path,
                O_CREAT | O_TRUNC | O_WRONLY,
                0666);
 
        if (fd == MI_ERROR)
        {
                mi_db_error_raise(Gen_Con, MI_EXCEPTION,
                        "Unable to open output file!");
        }
 
        datalen = mi_get_varlen((mi_lvarchar *)image);
        databits = mi_get_vardata((mi_lvarchar *)image);
 
        result = mi_file_write(fd, databits, datalen);
        if (result != datalen)
        {
                mi_db_error_raise(Gen_Con, MI_EXCEPTION,
                        "Error writing to file!");
        }
 
        mi_file_close(fd);
        mi_free(file_path);

	/* ------ }}Your_Code (#6221) END ------ */

}
/* }}FUNCTION (#DATS) */



#ifdef __cplusplus

}

#endif
