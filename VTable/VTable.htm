<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<html>
<head>
	<title>VTable</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="keywords" content=" ">
	<meta name="description" content=" ">
	<meta name="author" content=" ">
	<link rel="stylesheet" href="/idn-secure/DataBlade/Include/tech_note.css">

</head>
<body bgcolor="#FFFFFF">

<!-- BEGIN VIRTUAL INCLUDE FOR TOP NAVIGATION BAR -->
<!--#include virtual="/informix/include/idn_top.htm"-->
<!-- END VIRTUAL INCLUDE FOR TOP NAVIGATION BAR   -->	

<!-- BEGIN VIRTUAL INCLUDE FOR DATABLADE BAR -->
<!--#include virtual="/idn/Include/f2k_leaf.htm"-->
<!-- END VIRTUAL INCLUDE FOR TOP DATABLADE BAR   -->	

<!-- BEGIN MAIN CONTENTS AREA. ENTER CONTENTS ONLY BELOW THIS POINT -->

<h2 align="center"><font color="#0000FF">VTable</font></h2>
<h3 align="center"><font color="#0000FF">
An Access Method For Managing Versioned Tables
</font></h3>

<hr>

<big> <em> <p>
For some applications, a &quot;versioned&quot; database table has advantages
over a standard one. Standard database tables can only maintain a single state
of the data that they contain, but versioned tables can simultaneously manage
multiple states. With a versioned table, you can create a snapshot of your
data at a point in time, and, later, query the table as it existed then. You
can undo changes back to any saved point. You can maintain multiple concurrent
versions of your data, each evolving independently from a common ancestor.</p>

<p>This paper describes &quot;VTable&quot;, which uses a primary access method,
together with a set of SPL routines, triggers, and tables, to support versioned
tables in IDS.</p>

</p> </em> </big>

<hr>

<a name="contents">
<h3><font color="#0000FF">Contents</font></h3>

<ul>
  <li><a href="#overview">Overview</a></li>
    <li><a href="#architect">Architecture</a></li>
  <ul>
    <li><a href="#database_tables">Tables</a></li>
    <li><a href="#spl_routines">SPL Routines</a></li>
    <li><a href="#access_method">Access Method</a></li>
    <li><a href="#triggers">Triggers</a></li>
  </ul>
  <li><a href="#requirements">Software Requirements</a></li>
  <li><a href="#start">Getting Started</a></li>
  <ul>
    <li><a href="#download">Download the distribution</a></li>
    <li><a href="#install">Install VTable</a></li>
    <li><a href="#register">Register VTable to a database</a></li>
    <li><a href="#build">Build a new shared object</a></li>
  </ul>
  <li><a href="#udrs">User Defined Routines (UDRs)</a></li>
  <ul>
    <li><a href="#current_lineage">current_lineage</a> </li>
    <li><a href="#current_state">current_state</a> </li>
    <li><a href="#set_state">set_state</a> </li>
    <li><a href="#state_close">state_close</a> </li>
    <li><a href="#state_create">state_create</a> </li>
    <li><a href="#state_delete">state_delete</a> </li>
    <li><a href="#state_description">state_description</a> </li>
    <li><a href="#state_is_closed">state_is_closed</a> </li>
    <li><a href="#state_is_open">state_is_open</a> </li>
    <li><a href="#state_open">state_open</a> </li>
    <li><a href="#versioned_table_create">versioned_table_create</a> </li>
  </ul>
  <li><a href="#references">References</a></li>
</ul>

<hr>

<a name="overview">
<h3><font color="#0000FF">Overview</font></h3>
<blockquote>

  <p>VTable is an access method that extends IDS with the ability to maintain
  versioned tables. A versioned table is one that may present multiple views
  of the data that it contains, based on previously defined &quot;states&quot;.
  </p>

  <p>When a user connects to the database, a default table state is assigned,
  and that user will see versioned tables as they appear for that state. The
  user can work with the default state for versioned tables, or can request
  a different one by setting the state for her session using the 
  <font face="courier">set_state()</font> command.</p>

  <p>Users can also create new states that branch from existing ones. In this
  manner, versioned tables can evolve along several parallel paths, with each
  path serving a different purpose.</p>

  <p>Note that if your database contains more than one versioned table, 
  <em><strong>all</strong></em> of the versioned tables move in lock step with
  respect to states. When you create a new state, or set your session to work 
  with a specific state, the state applies to all of the versioned tables 
  defined for your database.</p>

  <p>This document will present an overview of VTable. Readers interested in
  understanding the utility in more detail should download the distribution
  and examine the registration scripts and the source code. All user-callable
  routines are written in SPL, the source for which is contained in the
  registration script (<font face="courier">register.sql</font>). The code
  to support the access method is written in C, and is in the 
  <font face="courier">src/c</font> directory.</p>
  

</blockquote>

<hr>

<a name="architect">
<h4><font color="0000FF">Architecture</font></h4>

<blockquote>

<p>VTable consists of:
</p>
<ul>
  <li><a href="#database_tables">Database tables</li></li>
  <li><a href="#spl_routines">A collection of SPL routines</a></li>
  <li><a href="#access_method">A &quot;Primary Access Method&quot; developed
    with the Virtual Table Interface (VTI)</a></li>
  <li><a href="#triggers">A collection of triggers</a></li>
</ul> 

  <hr>

  <a name="database_tables">
  <h4><font color="0000FF">Database Tables</font></h4>

  <p>When VTable is registered to a database, three database tables are
  created:</p>

  <ul>
    <li><strong>STATES</strong> holds information about the states that have
    been defined for versioned tables.</li>

    <li><strong>SESSIONS</strong> holds information about user sessions that
    are working with versioned tables.</li>

    <li><strong>VERSIONED_TABLES</strong> holds information about versioned
    tables that exist in the database.</li>
  </ul>

  <p>In addition, two database tables are created when you create a new
  versioned table using <font face="courier">versioned_table_create()</font>.
  <font face="Courier">versioned_table_create</font> takes the name of an
  existing table, and builds:</p>

  <ol>
    <li>A &quot;virtual&quot; table as the version-enabled mirror of the base
    table.</li>
    <li> A &quot;deletes&quot; table.</li>
    <li>An &quot;adds&quot; table.</li>
  </ol>

  <p>For example, if you have a base table named "mytable", then
  <font face="courier">versioned_table_create(&quot;mytable&quot;)</font>
  will produce:</p>

  <ul>
    <li><font face="courier">v_mytable</font></li>
    <li><font face="courier">v_mytable_add</font></li>
    <li><font face="courier">v_mytable_del</font></li>
  </ul>


  <p>&quot;<font face="courier">v_mytable</font>&quot; is the new 
  &quot;versioned&quot; table, and should
  be the target table for all user sessions. All of the other tables are
  managed by the VTable routines, and should not be updated manually.</p>

  <p>The SQL text for creating the <font face="courier">STATES, 
  SESSIONS</font>, and <font face="courier">VERSIONED_TABLES</font> tables
  can be found near the beginning of the <font face="courier">register.sql
  </font> script. The text that creates the versioned table and its 
  &quot;add&quot; and &quot;delete&quot; companion tables is in the SPL
  code for the <font face="courier">versioned_table_create</font> routine,
  which is elsewhere in <font face="courier">register.sql</font>.</p>

  <hr>

  <a name="spl_routines">
  <h4><font color="0000FF">SPL Routines</font></h4>

  <p>All of the VTable functions and procedures that are called directly by
  users were written using SPL. This includes the list defined under
  <a href="#udrs">User Defined Routines</a> above. The complete definition
  for each SPL routine can be found in the <font face="courier">register.sql
  </font> script.</p>

  <hr>

  <a name="access_method">
  <h4><font color="0000FF">Access Method</font></h4>

  <p>A Primary Access Method is a set of functions that the database server
  can call to access data that may not reside in an Informix table. Typically,
  Primary Access Methods are used to allow SQL queries to be run against data
  that is stored outside the database. An access method could be written, for
  example, to read a formatted flat file and present its fields as database
  columns.</p>

  <p>The VTable access method works a little differently. Instead of accessing
  external data and presenting it as an Informix database table, VTable
  intercepts queries that are sent to a versioned table, and rewrites them
  to take the user's session state into account. In doing so, VTable refers to
  the &quot;adds&quot; table and the &quot;deletes&quot; table, as well as
  the base table, and returns results that are appropriate to the user
  session that sent the query.</p>

  <p>Query rewriting is performed in the 
  &quot;<font face="courier">vt_beginscan</font>&quot; function, which is part
  of the VTable access method code. Please refer to the C code if you are
  interested in seeing exactly how this works.</p>

  <hr>
  
  <a name="triggers">
  <h4><font color="0000FF">Triggers</font></h4>

  <p>In addition to creating &quot;add&quot; and &quot;delete&quot; tables
  to manage changes to versioned tables, 
  <font face="courier">versioned_table_create()</font> defines a set of
  triggers that fire whenever an insert, update, or delete is performed on
  a versioned table. These triggers make sure that the appropriate information
  is recorded in the &quot;adds&quot; or &quot;deletes&quot; table for the
  versioned table.</p>

  <p>The text that defines the triggers can be found in the 
  <font face="courier">ins_trig_dll</font> SPL routine in the 
  <font face="courier">register.sql</font> script.
  <font face="courier">ins_trig_ddl</font> is called by 
  <font face="courier">versioned_table_create()</font> when you
  create a new versioned table.</p>

<a href="#contents">Contents</a>

</blockquote>

<hr>

<a name="requirements">
<h3><font color="#0000FF">Software Requirements</font></h3>

<blockquote>

  <p><strong>VTable</strong> has been tested with the following
  configurations:</p>

  <dl>
	<dt>UNIX:</dt>
	<dd>
	<ul>
		<li>Solaris OS version 5.7
		<li>IDS 9.21.UC2
	</ul>
	</dd>

	<dt>NT:</dt>
	<dd>
	<ul>
		<li>NT 4.0 with Service Pack 5
		<li>IDS 9.21.TC2
	</ul>
	</dd>
  </dl>

  <a href="#contents">Contents</a>

</blockquote>

<hr>
 
<a name="start">
<h3><font color="#0000FF">Getting Started</font></h3>

<blockquote>

  <a name="download">
  <h4><font color="0000FF">Download the distribution</font></h4>

  <p>Download the <strong>VTable.zip</strong>
  distribution file, and extract the contents.</p>

  <p>The VTable files are extracted into a directory hierarchy under
  the directory <strong>VTable</strong>.</p>

  <hr>

  <a name="install">
  <h4><font color="0000FF">Install</font></h4>

  <p>On Unix, login as user informix, or, on NT, log on as a user who is a
  member of the &quot;informix-admin&quot; group. Set your INFORMIXDIR 
  environment variable to the name of the Informix server in which you wish
  to install VTable.</p>

  <p>Create a &quot;VTable&quot; directory in your server's &quot;extend&quot;
  directory:</p>

  <blockquote>
    % mkdir $INFORMIXDIR/extend/VTable
  </blockquote>

  <p>The &quot;VTable&quot; directory into which the distribution files were
  extracted contains a &quot;scripts&quot; directory and a &quot;src&quot;
  directory tree. Copy all of the files from the &quot;scripts&quot; directory
  to your new $INFORMIXDIR/extend/VTable directory.</p>

  <p>Next, locate the appropriate VTable.bld file for your environment. The
  Solaris version is in &quot;src/solaris-sparc&quot;, and the NT version is
  in &quot;WinNT-i386&quot;. Copy the appropriate version of VTable.bld to
  &quot;$INFORMIXDIR/extend/VTable&quot;.</p>

  <p><strong>IMPORTANT:</strong> If you are using NT, you MUST set the 
  &quot;read-only&quot; property of the VTable.bld file or the bladelet will
  fail to load at runtime.<p>

  <p>There are two methods you can use to set the &quot;Read-only&quot;
  attribute:</p>

  <ol>
    <li>Use the &quot;Explore&quot; utility to locate the file, highlight it,
    and select &quot;File&quot; and &quot;Properties&quot; from the menu bar.
    Check the &quot;read-only&quot; attribute, select &quot;Apply&quot; and
    &quot;Exit&quot;.</li>

    <p>
    <li>Use the command line in a shell. For example, from an KSH window:<br>
      <p><font face="courier">% attrib +r $INFORMIXDIR/extend/VTable/VTable.bld
      </font></p>
    </p>
    
  </ol>

  <hr>

  <a name="build">
  <h4><font color="0000FF">Building a new shared object</font></h4>

  <p>The distribution for VTable comes with pre-built shared
  object libraries for Solaris 2.7 and NT 4.0. If you are on a different
  platform, or if you make modifications to the source code, 
  you must recompile for your platform using the instructions provided 
  below.</p>

  <p>The source and make files of VTable are located under the 
  &quot;VTable/src&quot; directory. </p>

  <p><strong>NT:</strong></p>

  <blockquote>

    <p>On NT, C language database extensions are built using Microsoft Visual
    Studio. For IDS release 9.21, you should use Visual Studio version 6.0.</p>

    <p>Use the &quot;VTable_NT.mak&quot; file to build the bladelet on NT. You
    will need to modify the makefile to provide the correct path for the 
    Microsoft Visual Studio libraries and include files on your machine. See
    the definitions for &quot;CPP_PROJ&quot; and &quot;LINK32_FLAGS&quot; in
    the makefile for these entries.</p>

    <p>Once &quot;VTable_NT.mak&quot; has been modified for your environment,
    build the VTable.bld file with the following command:</p>

    <blockquote>
      <p>$ nmake -f VTable_NT.mak</p>
    </blockquote>

    <p>If the build succeeds, a new copy of VTable.bld is placed in the
    &quot;WinNT-i386&quot; directory.</p>

  </blockquote>

  <p><strong>UNIX:</strong></p>

  <blockquote>

    <p>On Solaris, VTable was built and tested with version 5.0 of the standard
    Sun C compiler. The Unix makefile for VTable is designed to use the 
    standard compiler for each platform. It should not be necessary to modify
    the makefile on Unix.</p>

    <p>To build VTable on UNIX, first set your TARGET environment 
    variable to the location/filename of the platform-specific make include
    file. On Solaris, this is "$INFORMIXDIR/incl/dbdk/makeinc.solaris". </p>

    <p>Navigate to the &quot;src&quot; directory, and build the VTable shared
    object with this command:</p>

    <blockquote>

      <p>% make -f VTable_Unix.mak</p>

    </blockquote>

    <p>The linker will display a list of unresolved symbols that include 
    several DataBlade API functions (mi_alloc, mi_file_seek, etc.) and a few
    standard C library routines (sprintf, stcmpr). These modules will be
    dynamically loaded at runtime, so the fact that they are unresolved 
    during the build is not an error.</p>


  </blockquote>

  <p>Detailed instructions for building UNIX and NT shared object libraries can 
  be found on the &quot;DataBlade Developer&quot; corner of the Informix IDN
  web site <a href="http://www.informix.com/idn">
  http://www.informix.com/idn</a></p>

  <hr>

  <a name="register">
  <h4><font color="0000FF">Registering VTable in a database</font></h4>

  <p>Once VTable has been installed on a server, it can
  be registered to databases that run under that server.</p>

  <p>On both Unix and NT, VTable is registered by running an SQL script.
  Navigate to your $INFORMIXDIR/extend/VTable directory, and enter the
  following command, where &quot;myDb&quot; is the name of your target
  database:</p>

  <blockquote>

    <p>% dbaccess -e myDb register</p>

  </blockquote>

  <p>The &quot;register.sql&quot; script creates the access method, the
  support tables, functions, and triggers for VTable.</p>

</blockquote>

<a href="#contents">Contents</a>
<hr>

<a name="udrs">
<h3><font color="#0000FF">User Defined Routines (UDRs)</font></h3>

<blockquote>

  <a name="current_lineage">
  <h4>CURRENT_LINEAGE</h4>

  <p>Returns the lineage for the state currently associated with a session.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE current_lineage();</p>

    <p>(expression)</p>

    <blockquote>
      <p>0,1,7</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="current_state">
  <h4>CURRENT_STATE</h4>

  <p>Returns the state currently associated with a session.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE current_state();</p>

    <p>(expression)</p>

    <blockquote>
      <p>7</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="set_state">
  <h4>SET_STATE</h4>

  <p>Takes an integer representing the ID for an existing state, and sets the
  current session to work from that state.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE set_state(2);</p>

    <p>Routine executed.</p>


  </blockquote>
  <hr>

  <a name="state_close">
  <h4>STATE_CLOSE</h4>

  <p>Takes a state ID as input, and marks the state as closed. New states can
  only be branched from closed states.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_close(2);</p>

    <p>Routine executed.</p>

  </blockquote>
  <hr>

  <a name="state_create">
  <h4>STATE_CREATE</h4>

  <p>Takes an integer representing the ID of an existing state, and a text
  string containing a description for a new state. Creates a new state that
  branches from the one specified. The existing state must be
  &quot;closed&quot;, and must either be owned by the current user, or
  marked &quot;public&quot;.</p>

  <p>Returns the id of the new state.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_create(2, &quot;Temporary state for 
    unit testing&quot;);</p>

    <p>(expression)</p>

    <blockquote>
      <p>5</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="state_delete">
  <h4>STATE_DELETE</h4>

  <p>Takes the ID of an existing state and deletes it. Only &quot;leaf
  nodes&quot; can be deleted. A leaf node is a state that is not an element
  in the lineage of another state.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_delete(5);</p>

    <p>Routine executed.</p>

  </blockquote>
  <hr>

  <a name="state_description">
  <h4>STATE_DESCRIPTION</h4>

  <p>Takes the id of an existing state. Returns the &quot;description&quot;
  text that was supplied when the state was created.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_description(5);</p>

    <p>(expression)</p>

    <blockquote>
      <p>Temporary branch for unit testing</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="state_is_closed">
  <h4>STATE_IS_CLOSED</h4>

  <p>Takes the id of an existing state. Returns &quot;true&quot; if that state
  is closed, or &quot;false&quot; if it is not.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_is_closed(3);</p>

    <p>(expression)</p>

    <blockquote>
      <p>t</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="state_is_open">
  <h4>STATE_IS_OPEN</h4>

  <p>Takes the id of an existing state. Returns &quot;true&quot; if that state
  is open, or &quot;false&quot; if it is not.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_is_open(3);</p>

    <p>(expression)</p>

    <blockquote>
      <p>f</p>
    </blockquote>


  </blockquote>
  <hr>

  <a name="state_open">
  <h4>STATE_OPEN</h4>

  <p>Takes the id of a closed state, and marks it open.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE state_open(3);</p>

    <p>Routine executed.</p>

  </blockquote>
  <hr>

  <a name="versioned_table_create">
  <h4>VERSIONED_TABLE_CREATE</h4>

  <p>Takes the name of an existing database table, and creates a new
  versioned table for it. The table must exist, must not already be
  versioned, and must contain a primary key column.</p>

  <p>Returns the ID for the new versioned table.</p>

  <p>Note: The table name parameter must be entered in lower case.</p>

  <p><strong>Syntax</strong></p>

  <blockquote>

    <p>&gt; EXECUTE PROCEDURE versioned_table_create(&quot;mytable&quot;);</p>

    <p>(expression)</p>

    <blockquote>
      <p>1</p>
    </blockquote>

  </blockquote>

</blockquote>
<a href="#contents">Contents</a>
<hr>

<a name="references">
<h3><font color="#0000FF">References</font></h3>

<blockquote>

  <p>For more information on topics related to VTable, please refer to the
  following sources:</p>

  <ul>
    <li>&quot;The Virtual Table Interface&quot;, on the &quot;DataBlade
    Developers&quot; corner of the IDN web site.</li>

    <li>&quot;Virtual-Table Interface Programmer's Manual&quot;</li>

    <li>&quot;Informix Guide to SQL: Syntax&quot;</li>
  </ul>

  <p>Informix manuals can be downloaded in PDF format from the Informix
  web site.</p>

</blockquote>


<!-- END MAIN CONTENTS AREA. ENTER CONTENTS ONLY ABOVE THIS POINT -->

<!-- BEGIN CUSTOM FOOTER -->
<hr><p>Last modified on <b><!--#echo var="LAST_MODIFIED" --></b>.
Please send your comments or questions concerning this page to
<a href="mailto:idn-foundation@informix.com?subject=Comments on 
<!--#echo var="DOCUMENT_URI" -->"><nobr>idn-foundation@informix.com</nobr></a>.
</p><hr>
<!-- END CUSTOM FOOTER -->

<!-- BEGIN VIRTUAL INCLUDE FOR THE FOOTER -->
<!--#include virtual="/informix/include/abs_footeralone.htm"-->
<!-- END VIRTUAL INCLUDE FOR THE FOOTER -->



</body>
</html>
