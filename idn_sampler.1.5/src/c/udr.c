/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        08/24/1999 15:23
** Description:    This is a generated source file for the idn_sampler DataBlade module.
** Comments:       Generated for project idn_sampler.1.4
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <fcntl.h>      /* For IDN_LogMsg() */
#include <errno.h>      /* For IDN_LogMsg() */


/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "idn_sampler.h"

/* Needed for some of the semi-public functions we'll use */
#include <minmdur.h>
#include <memdur.h>
#include <minmprot.h>   /* Prototypes for semi-public functions */
#include <time.h>       /* For IDN_Now()    */

/* Some UDRs in this file use the __myErrors__ trace class for simple
** trace output.
**
** DPRINTF messages will be output if the level for the trace class,
** set with IDN_Debug() is greater than or equal to TRC_THRESH.
*/
#define TRC_CLASS "__myErrors__"
#define TRC_THRESH 20
 
/**************************************************************
** IDN_EOT_Reg support
***************************************************************
*/
#define MESG_SIZE 256
typedef struct error_mesg
{
    MI_EVENT_TYPE evtype;               /* MI_MESSAGE, MI_EXCEPTION, MI_SQL */
    mi_string     sqlcode[6];           /* 5 character code */
    mi_string     mesg[MESG_SIZE];      /* 255 char message */
} error_mesg_t;
 
/**************************************************************
** IDN_FuncCache support
***************************************************************
*/
typedef struct func_cache
{
    MI_CONNECTION *conn;
    MI_FUNC_DESC  *func_ptr;
} func_cache_t;
 
 
mi_lvarchar * IDN_EOT_Reg ARGS((MI_FPARAM * Gen_fparam));
MI_CALLBACK_STATUS idn_eot_cb ARGS((MI_EVENT_TYPE type,
                MI_CONNECTION *client_conn, void *server_info, void *unused));
MI_CALLBACK_STATUS idn_exception_cb ARGS((MI_EVENT_TYPE type,
                MI_CONNECTION *conn, void *server_info, void *user_data));
mi_integer idn_cb_test_create ARGS((MI_CONNECTION *conn));
mi_integer idn_cb_test_insert ARGS((MI_CONNECTION *conn, mi_string *str));


/* {{FUNCTION(411f20a0-980d-11d1-b50f-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_SetNow
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_SetNow (lvarchar) returns datetime year to second.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_datetime
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Jan 23, 1998 - Generated by BladeSmith Version 3.50.TC1  
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_datetime *IDN_SetNow
(
mi_lvarchar     *datetime_in,  /* datetime string to convert */
MI_FPARAM *     Gen_fparam     /* Standard info - see DBDK docs. */
)
{
        MI_CONNECTION * Gen_Con;           /* The connection handle.  */
        mi_datetime   * Gen_RetVal;        /* The return value.  */
 
        /* callback function prototype */
        MI_CALLBACK_STATUS MI_PROC_CALLBACK IDN_SetNow_Callback
                ARGS((MI_EVENT_TYPE type, MI_CONNECTION *conn,
                void *server_data, void *user_data));
 
        MI_CALLBACK_HANDLE *cback;     /* callback handle */
        mi_integer      user_data = 0; /* 0 == ok, -1 == error */
 
        /* Get the current connection handle. */
        Gen_Con = mi_open( NULL, NULL, NULL );
 
        /* Verify that the connection has been established. */
        if( Gen_Con == 0 )
        {
                /*
                ** Opening the current connection has failed
                ** so issue the following message and quit.
                **
                **      "Connection has failed in IDN_SetNow."
                */
                DBDK_TRACE_ERROR( "IDN_SetNow", ERRORMESG1, 10 );
 
                /* not reached */
        }
 
        /*
        ** Write to the trace file indicating
        ** that IDN_SetNow has been called.
        */
        DBDK_TRACE_ENTER( "IDN_SetNow" );
 
        /*
        ** Register the callback. The callback function will ignore any
        ** errors except "-7521", which is the sqlcode that means an
        ** invalid datetime string was passed to mi_datetime_to_binary().
        **
        ** If the error is -7521, then the callback will set the "user_data"
        ** flag to -1. We check that flag after the API call, and bail out
        ** if it's < 0.
        */
 
        cback = mi_register_callback(Gen_Con, MI_Exception,
                IDN_SetNow_Callback, (void *)&user_data, NULL);
 
        if (cback == (MI_CALLBACK_HANDLE *) NULL)
        {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                "Unable to register callback IDN_SetNow_Callback.");
        }
 
        /* Convert the mi_lvarchar that was input into an mi_datetime */
        /* If there are any problems doing the conversion, our callback */
        /* should fire. */
 
        Gen_RetVal = mi_datetime_to_binary(datetime_in);
        if (user_data < 0)
        {
            mi_db_error_raise(NULL,MI_EXCEPTION,
                "mi_datetime_to_binary() call failed.");
        }
        /*
        ** Write to the trace file indicating
        ** that IDN_Now has successfully exited.
        */
        DBDK_TRACE_EXIT( "IDN_SetNow" );
 
        /* Return the function's return value. */
        return Gen_RetVal;
}
/* }}FUNCTION (#68S6) */

/*
** IDN_SetNow_Callback()
**
** This callback routine is meant to catch an MI_Exception condition
** triggered by passing a bad date value to mi_datetime_to_binary().
** Since that API call has no return status, this is the only way to
** intercept an error.
**
*/
MI_CALLBACK_STATUS
IDN_SetNow_Callback(type, conn, ius_info, user_data)
MI_EVENT_TYPE           type;
MI_CONNECTION           *conn;
void                    *ius_info;
void                    *user_data;
{
        mi_integer      sqlcode;
        mi_integer      *status_flag = user_data;
 
        if (mi_error_sqlcode(ius_info, &sqlcode) != MI_OK)
        {
                *status_flag = -1;
                return MI_CB_CONTINUE;
        }
 
        /* The error we're interested in is -7521 */
        if (sqlcode == -7521)
        {
                *status_flag = -1;
                return MI_CB_EXC_HANDLED;
        }
 
        /* Let the server handle this one */
        return MI_CB_CONTINUE;
}


/* {{FUNCTION(ecc4c661-798d-11d1-9c2d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_FuncExec
**
** Description:
**
**      Executes another UDR using mi_routine_get() and mi_routine_exec().
**      This simple case executes the built-in Equal UDR; but it is intended
**      to show how you might execute functions in another DataBlade module.
**
**      The way this function does it is somewhat inefficient. Each time
**      the function  is called, it gets a connection and the function
**      descriptor, free'ing both at the end.  Note that it is expensive
**      to get the function descriptor and free it each time the function
**      is called.
**
** We could optimize it a couple ways:
**
**      - Cache it in the MI_FPARAM. In fact, create a structure
**        to cache the MI_CONNECTION handle and the MI_FUNC_DESC descriptor.
**
**      - Cache the functions descriptors at the session level. FuncCache
**        shows how to do that.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_FuncExec (integer,integer) returns boolean.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Dec 20, 1997 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_FuncExec
(
mi_integer      arg1,
mi_integer      arg2,
MI_FPARAM *     Gen_fparam  /* Standard info - see DBDK docs. */
)
{
        MI_CONNECTION   *conn=NULL;
        mi_integer      bool_ret;       /* return result: MI_TRUE or MI_FALSE */
 
        MI_FUNC_DESC    *funcdesc=NULL; /* returned by mi_routine_get() */
        MI_DATUM        funcresult;     /* function return value */
        mi_integer      funcerror;      /* mi_routine_exec error status */
 
        mi_string       *funcsig="equal(int,int)", /* function we'll execute */
                        *r="IDN_FuncExec";
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering function", r));
 
        /* ===== Open a connection ======================================= */
        if ((conn = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
                {
                mi_db_error_raise(NULL, MI_EXCEPTION, 
                                  "FuncExec: mi_open failed");
                return MI_ERROR;
                }
 
        /* ===== Get the function descriptor ============================= */
        if((funcdesc=mi_routine_get(conn, 0, funcsig)) == (MI_FUNC_DESC *)NULL)
                {
                mi_db_error_raise(NULL,MI_EXCEPTION, "mi_routine_get() failed");
                return MI_ERROR;
                }
 
        DPRINTF(TRC_CLASS, TRC_THRESH,
                ("%s: got function descriptor for '%s'", r, funcsig));
 
        /* ===== Execute the function ==================================== */
        funcresult = mi_routine_exec(conn, funcdesc, &funcerror, arg1, arg2);
        if(funcerror == MI_ERROR)
                {
                mi_db_error_raise(NULL,MI_EXCEPTION, "mi_routine_exec failed");
                return MI_ERROR;
                }
 
        bool_ret = (mi_integer) funcresult;
 
        DPRINTF(TRC_CLASS,1,
                ("%s: equal(%d,%d)=%s", r, arg1, arg2,
                        bool_ret == MI_TRUE ? "MI_TRUE":"MI_FALSE"));
 
        /* ===== Free the MI_FUNC_DESC descriptor ========================== */
        mi_routine_end(conn, funcdesc);
 
        /* ===== Close the connection ====================================== */
        mi_close(conn);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function", r));
 
        return bool_ret;

}
/* }}FUNCTION (#3N0D) */




/* {{FUNCTION(8f0c6a90-890d-11d1-b501-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_Now
**
** Description:
**
**      This routine gets the current date and time from the OS,
**      converts it to an mi_datetime, and returns it.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_Now () returns datetime year to second.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_datetime
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Jan 09, 1998 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_datetime *IDN_Now(MI_FPARAM *Gen_fparam)
{
        MI_CONNECTION * Gen_Con;           /* The connection handle.  */
        mi_datetime   * Gen_RetVal;        /* The return value.  */
 
        struct tm       tm_ptr;            /* Date/Time structure */
        time_t          secs;              /* Time in seconds */
        mi_char         datebuff[32];      /* Buffer for text format date */
        mi_char         iusbuff[20];       /* Buffer for ius format date  */
        mi_char         yearbuff[5];       /* Buffer for 4-digit year     */
        mi_lvarchar   * date_lv;           /* Date/Time in an mi_lvarchar */
        mi_integer      i, j;              /* Loop counters               */
 
        /* Get the current connection handle. */
        Gen_Con = mi_open( NULL, NULL, NULL );
 
        /* Verify that the connection has been established. */
        if( Gen_Con == 0 )
        {
                /*
                ** Opening the current connection has failed
                ** so issue the following message and quit.
                **
                **      "Connection has failed in IDN_Now."
                */
                DBDK_TRACE_ERROR( "IDN_Now", ERRORMESG1, 10 );
 
                /* not reached */
        }
 
        /*
        ** Write to the trace file indicating
        ** that IDN_Now has been called.
        */
        DBDK_TRACE_ENTER( "IDN_Now" );
 
        /* get the seconds since January 1, 1970 */
        if ((secs = time((time_t)NULL)) == (time_t) -1)
        {
            mi_db_error_raise(NULL,MI_EXCEPTION, "time() failed.");
            /* not reached */
        }
        /* reformat into a text buffer */
        if (ctime_r(&secs, datebuff, 26) == NULL)
        {
            mi_db_error_raise(NULL,MI_EXCEPTION, "ctime_r() failed.");
            /* not reached */
        }
 
        /* now convert it to a tm structure */
        if (strptime(datebuff, "%a %b %d %H:%M:%S %Y", &tm_ptr) == NULL)
        {
            mi_db_error_raise(NULL,MI_EXCEPTION, "strptime() failed.");
            /* not reached */
        }
 
        /* convert it to the format that IUS wants (yyyy-mm-dd hh:mi:ss)  */
        /* ...but first, get the 4-digit year. &tm_ptr->tm_year is only 2! */
        j=0;
        for (i=20; i<24; i++)
        {
            yearbuff[j] = datebuff[i];
            j++;
        }
        yearbuff[j] = '\0';
 
        if (sprintf(iusbuff, "%s-%02d-%02d %02d:%02d:%02d",
            yearbuff,
            tm_ptr.tm_mon+1, /* January is 0, not 1 */
            tm_ptr.tm_mday,
            tm_ptr.tm_hour,
            tm_ptr.tm_min,
            tm_ptr.tm_sec) < 0)
        {
            mi_db_error_raise(NULL,MI_EXCEPTION, "sprintf() failed.");
            /* not reached */
        }
        /* convert the character string to an mi_lvarchar */
        date_lv = mi_string_to_lvarchar(iusbuff);
 
        /* and, finally, convert the mi_lvarchar to an mi_datetime */
        Gen_RetVal = mi_datetime_to_binary(date_lv);
 
        /*
        ** Write to the trace file indicating
        ** that IDN_Now has successfully exited.
        */
        DBDK_TRACE_EXIT( "IDN_Now" );
 
        /* Return the function's return value. */
        return Gen_RetVal;
}
/* }}FUNCTION (#KK06) */




/* {{FUNCTION(ecc4c660-798d-11d1-9c2d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_Debug
**
** Description:
**
**      Turns on outputting trace messages to an external file.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_Debug (int) returns int.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Dec 20, 1997 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_Debug
(
mi_integer      level,
MI_FPARAM *     Gen_fparam  /* Standard info - see DBDK docs. */
)
{
        mi_string       trace_set[30];
 
        (void) memset(trace_set, 0, sizeof(trace_set));
        sprintf(trace_set, "%s %d", TRC_CLASS, level);
 
        if(mi_tracelevel_set(trace_set) == MI_ERROR)
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "mi_tracelevel_set failed!");
 
        return 0;
}

/* }}FUNCTION (#8ACT) */


/* {{FUNCTION(ecc4c663-798d-11d1-9c2d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Procedure name:
**
**	IDN_LogMsg
**
** Description:
**
**      Outputs messages to an external file.
**
** Special Comments:
**
**
**	A stack size of 32,767 bytes  has  been  requested  for
**	the routine.  Normally, this is sufficient memory for most
**	invocations of your UDR.  If you intend, however, to  call
**	this routine recursively or other routines that use  large
**	or unknown stack sizes, you should use mi_call().  mi_call
**	checks to insure that sufficient stack space is available.
**	For  more  details  regarding  this   function,  look  in:
**	The  DataBlade  API Programmer's  Manual  (see Stack Space
**	Allocation in Chapter 11).
**	
** Parameters:
**
**	None
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Dec 20, 1997 - Generated by BladeSmith Version 3.50.TC1
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT void
IDN_LogMsg
(

mi_lvarchar *                filename,
mi_lvarchar *                message,
MI_FPARAM *                  Gen_fparam   /* Standard info - see DBDK docs.  */
)
{
        mi_integer      fd,        /* file descriptor */
                        ret,       /* return status from mi_file_* functions */
                        error;     /* mi_file_errno() errno return */
        mi_string       pathname[256],    /* mi_lvarchar_to_buffer() result */
                        *msg_str,         /* mi_lvarchar_to_string() result */
                        *newline = "\n",  /* output new line */
                        msg_error[150],   /* errno error message */
                        *p;
 
        if( mi_get_varlen(filename) >= sizeof(pathname) )
                {
                mi_db_error_raise(NULL,MI_EXCEPTION,
                        "Path name exceeded 255 characters!");
                return;
                }
 
        mi_var_to_buffer(filename, pathname);
        msg_str = mi_lvarchar_to_string(message);
 
        fd = mi_file_open (pathname, O_WRONLY | O_APPEND | O_CREAT, 0644);
        if (fd == MI_ERROR)
                {
 
                error=mi_file_errno();
                switch(error)
                        {
                        /*  Include your favorite errors from */
                        /*  /usr/include/sys/errno.h.         */
                        case ENOENT:
                                p="No such file or directory";
                                break;
                        case EACCES:
                                p="Permission denied";
                                break;
                        case EISDIR:
                                p="Pathname is a directory instead of file";
                                break;
                        default:
                                p="Unhandled errno case";
                                break;
                        }
 
                sprintf(msg_error,
                  "IDN_LogMsg: mi_file_open() failed for '%s' -- %s (errno=%d)",
                   pathname, p, error);
 
                mi_db_error_raise(NULL,MI_EXCEPTION, msg_error);
                return; /* not reached */
                }
 
        ret = mi_file_write (fd, msg_str, strlen(msg_str));
        if(ret == MI_ERROR)
                {
 
                error=mi_file_errno();
                switch(error)
                        {
                        case ENOSPC:
                                p="No space left on device";
                                break;
                        default:
                                p="Unhandled errno case";
                                break;
                        }
 
                sprintf(msg_error,
                "IDN_LogMsg: mi_file_write() failed for '%s' -- %s (errno=%d)",
                 pathname, p, error);
                mi_db_error_raise(NULL,MI_EXCEPTION, msg_error);
                return; /* not reached */
                }
 
        ret = mi_file_write (fd, newline, strlen(newline));
        if(ret == MI_ERROR)
                {
                mi_db_error_raise(NULL,MI_EXCEPTION, 
                   "mi_file_write() failed for newline!");
                return;
                }
 
        mi_file_close(fd);
        mi_free(msg_str);      /* mi_lvarchar_to_string() allocated result */
 
        return;
}
/* }}FUNCTION (#BBO4) */




/* {{FUNCTION(5872e0d2-ce1a-11d1-a050-0060975bf50b) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_GetAnyLevel
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_Debug (lvarchar) returns int.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_GetAnyLevel
(

mi_lvarchar *                trace_class,
MI_FPARAM *                  Gen_fparam    /* Standard info - see DBDK docs. */
)

{
        mi_string       tc_name[20]; /* systraceclasses.name is a char(18) */
 
        memset (tc_name, 0, sizeof(tc_name));
 
        if( mi_get_varlen(trace_class) >= sizeof(tc_name) )
                {
                mi_db_error_raise(NULL,MI_EXCEPTION,
                        "Trace class name exceeds 18 characters!");
                return MI_ERROR;
                }
        else
                mi_var_to_buffer(trace_class, tc_name);
 
        return MI_TFLEV(tc_name);

}
/* }}FUNCTION (#F7I1) */




/* {{FUNCTION(05ed4520-b222-11d1-9c4e-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_SessionId
**
** Description:
**
**      Returns the client's session id.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_SessionId () returns int.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Mar 02, 1998 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_SessionId(MI_FPARAM *Gen_fparam)

{
        MI_CONNECTION   *conn=NULL;
        mi_integer      result;
        mi_string       *r="IDN_SessionId";
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering UDR", r));
 
        conn = mi_open (NULL,NULL,NULL);
        if(conn == (MI_CONNECTION *)NULL)
                {
                mi_db_error_raise(NULL, MI_EXCEPTION, "mi_open failed!");
                /* not reached */
                }
 
        result = mi_get_id(conn, MI_SESSION_ID);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: session id=%d", r, result));
 
        mi_close(conn);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving UDR", r));
 
        return result;

}
/* }}FUNCTION (#L0FI) */




/* {{FUNCTION(5872e0d1-ce1a-11d1-a050-0060975bf50b) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_SetAnyLevel
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_Debug (lvarchar,int) returns int.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_SetAnyLevel
(
mi_lvarchar     *trace_class,
mi_integer      level,
MI_FPARAM *     Gen_fparam  /* Standard info - see DBDK docs. */
)
{
        mi_string       tc_name[20], /* systraceclasses.name is a char(18) */
                        trace_set[30];
 
        memset (tc_name, 0, sizeof(tc_name));
 
        if( mi_get_varlen(trace_class) >= sizeof(tc_name) )
                {
                mi_db_error_raise(NULL,MI_EXCEPTION,
                        "Trace class name exceeds 18 characters!");
                return MI_ERROR;
                }
        else
                mi_var_to_buffer(trace_class, tc_name);
 
        (void) memset(trace_set, 0, sizeof(trace_set));
        sprintf(trace_set, "%s %d", tc_name, level);
 
        if(mi_tracelevel_set(trace_set) == MI_ERROR)
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "mi_tracelevel_set failed!");
 
        return 0;
}

/* }}FUNCTION (#6C5O) */




/* {{FUNCTION(6e5fed00-b2de-11d1-9c4e-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_Debug_GetLevel
**
** Description:
**
**      Returns the level set by IDN_Debug.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_Debug () returns int.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Mar 03, 1998 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_Debug_GetLevel(MI_FPARAM *Gen_fparam)

{
        return MI_TFLEV(TRC_CLASS);
}
/* }}FUNCTION (#ARAI) */




/* {{FUNCTION(05ed4521-b222-11d1-9c4e-000000000000) (MergeSection) */

/*******************************************************************************
**
** Procedure name:
**
**	IDN_EasyTrace
**
** Description:
**
**      Shows an easy way to output trace messages.
**
** Special Comments:
**
**
**	A stack size of 32,767 bytes  has  been  requested  for
**	the routine.  Normally, this is sufficient memory for most
**	invocations of your UDR.  If you intend, however, to  call
**	this routine recursively or other routines that use  large
**	or unknown stack sizes, you should use mi_call().  mi_call
**	checks to insure that sufficient stack space is available.
**	For  more  details  regarding  this   function,  look  in:
**	The  DataBlade  API Programmer's  Manual  (see Stack Space
**	Allocation in Chapter 11).
**	
** Parameters:
**
**	None
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Mar 01, 1998 - Generated by BladeSmith Version 3.50.TC1
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT void
IDN_EasyTrace
(

mi_lvarchar *                message,

mi_integer                   threshold,
MI_FPARAM *                  Gen_fparam       /* Standard info - see DBDK docs.          */
)
{
        mi_string       *msg_str,       /* mi_lvarchar_to_string() result */
                        trace_set[20],
                        *r="IDN_EasyTrace";
 
        mi_integer      trace_level=20;
 
        mi_lvarchar     *return_result;
 
        /***********************************************************************
        ** The first time this UDR is called, probably tracing will be off,
        ** so the "entering UDR" message won't be output.
        **
        ** One way to turn tracing on before calling this UDR for the first
        ** time is to execute IDN_Debug() in the IDN Sampler, which lets you
        ** set the level for the __MyErrors__ trace class to anything you want.
        ***********************************************************************/
        DPRINTF(TRC_CLASS, threshold, ("%s: entering UDR", r));
 
        /**********************************************************************
        ** If the current level for 'TRC_CLASS' is 0, set it to 'trace_level'.
        ** This won't change the level if you set it to a non-zero value using
        ** IDN_Debug().
        ***********************************************************************/
        if (MI_TFLEV(TRC_CLASS) == 0)
                {
                memset (trace_set, 0, sizeof(trace_set));
                sprintf(trace_set, "%s %d", TRC_CLASS, trace_level);
 
                if(mi_tracelevel_set(trace_set) == MI_ERROR)
                        mi_db_error_raise(NULL, MI_EXCEPTION,
                                "mi_tracelevel_set failed!");
 
                /************************************************************
                ** A debug message gets output if trace_level >= threshold
                *************************************************************/
                DPRINTF(TRC_CLASS, threshold,
                        ("%s: Trace level for '%s' changed from 0 to %d.",
                        r, TRC_CLASS, trace_level));
                }
 
        /**********************************************************************
        ** Where do messages get output?
        **
        ** If we don't explicitly set the name of the tracefile with
        ** mi_tracefile_set, a default file is created in /tmp named
        **
        **      {sessionid}.trc
        **
        ** Where {sessionid} is your Informix session id. You can find
        ** out this session id with IDN_SessionId().
        ***********************************************************************/
 
        msg_str = mi_lvarchar_to_string(message);
 
        DPRINTF(TRC_CLASS, threshold,
                ("%s: message='%s', threshold=%d", r, msg_str, threshold));
 
        mi_free(msg_str);      /* mi_lvarchar_to_string() allocated result */
 
        DPRINTF(TRC_CLASS, threshold, ("%s: leaving UDR", r));
 
        return;

}
/* }}FUNCTION (#6JLS) */




/* {{FUNCTION(605c3800-9777-11d1-9c33-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_EOT_Reg
**
** Description:
**
**      Register the end-of-transaction callback.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_EOT_Reg () returns lvarchar.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Dec 23, 1997 - Generated by BladeSmith Version 3.50.TC1
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *IDN_EOT_Reg(MI_FPARAM *Gen_fparam)
{
        mi_lvarchar     *return_msg=NULL;
        mi_string       status_msg[256],
                        *r="IDN_EOT_Reg";
 
        MI_CALLBACK_HANDLE      *cback=NULL;
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering function",r));
 
        /* Register the MI_EVENT_END_XACT callback handler. */
        cback = mi_register_callback (
                NULL,                   /* register on NULL conn handle  */
                MI_EVENT_END_XACT,      /* event = end of transaction    */
                idn_eot_cb,             /* function server will dispatch */
                NULL,                   /* user buffer (not used)        */
                NULL);                  /* not used */
 
        if(cback == (MI_CALLBACK_HANDLE *) NULL)
                {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "IDN_EOT_Reg: mi_register_callback failed!");
                return (mi_lvarchar *)NULL;
                }
 
        strncpy(status_msg,
                "EOT callback registered; event output will be in idn_cb_test",
                sizeof(status_msg)-1);
        return_msg = mi_string_to_lvarchar(status_msg);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function\n",r));
 
        return return_msg;
}
 
/*
** NAME
**      idn_eot_cb()
**
** DESCRIPTION
**      End-of-transaction callback.
**
** RETURN VALUE
**      MI_CB_CONTINUE
*/
 
MI_CALLBACK_STATUS
idn_eot_cb (MI_EVENT_TYPE type, MI_CONNECTION *client_conn,
                void *server_info, void *unused)
{
        MI_CALLBACK_STATUS      retval=MI_CB_CONTINUE;
        MI_TRANSITION_TYPE      xact_type;
        mi_string               xact_str[30],
                                *r="idn_eot_cb";
 
        /* Variables for inserting record into audit table */
        MI_CONNECTION           *conn=NULL;     /* for mi_exec */
        MI_CALLBACK_HANDLE      *cback=NULL;    /* for MI_Exception handler */
        error_mesg_t            error;          /* filled in by MI_Exception */
        mi_integer              status;
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering callback",r));
 
        if(type != MI_EVENT_END_XACT)
                {
                DPRINTF(TRC_CLASS, TRC_THRESH,
                        ("%s: Callback called with inappropriate event %d",
                                r, type));
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "EOT callback called with inappropriate event!");
                return retval;
                }
 
        /* =========== Find out how the transaction ended =========== */
        xact_type = mi_transition_type(server_info);
        switch (xact_type)
                {
                case MI_NORMAL_END:
                        strncpy(xact_str,
                                "Transaction Committed",
                                sizeof(xact_str)-1 );
                        break;
                case MI_ABORT_END:
                        /* Inserting status into a table will succeed, then
                        ** get rolled back with all other changes for the
                        ** transaction.
                        **
                        ** It makes more sense to output abort state to an
                        ** external file using DPRINTF or the mi_file_*
                        ** routines.
                        **
                        ** The insert is left in here for demo purposes.
                        */
                        strncpy(xact_str,
                                "Transaction Aborted",
                                sizeof(xact_str)-1 );
                        break;
                default:
                        strncpy(xact_str,
                                "Unhandled Transaction Type",
                                sizeof(xact_str)-1 );
                        break;
                }
 
        /* =========== Insert a record into our audit table ===========
        **
        **  1.  Need to get a connection because the MI_CONNECTION handle
        **      passed in to an end-of-transaction callback is NULL.
        **  2.  Register an MI_Exception callback for the insert.
        **  3.  Insert the record by calling idn_cb_test_insert()
        **  4.  If the insert failed because the table doesn't exist,
        **      the MI_Exception callback returns MI_CB_EXC_HANDLED
        **      and control is returned to this callback function.
        **
        **      - Create the table by calling idn_cb_test_create()
        **      - Insert the record by calling idn_cb_test_insert()
        */
 
        /*  1.  Get a connection. */
        conn = mi_open(NULL,NULL,NULL);
        if(conn== (MI_CONNECTION *)NULL)
                {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "idn_eot_cb: mi_open failed!");
                return retval;
                }
 
        /* 2. Register the MI_Exception callback handler. */
        cback = mi_register_callback(conn, MI_Exception, idn_exception_cb,
                (void *)&error, NULL);
        if (cback == (MI_CALLBACK_HANDLE *) NULL)
                {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "idn_eot_cb: mi_register_callback failed!");
                return retval;
                }
 
        /*  3.  Insert the record by calling idn_cb_test_insert() */
        status = idn_cb_test_insert(conn, xact_str);
        if(status == MI_OK)
                {
                DPRINTF(TRC_CLASS, TRC_THRESH,
                        ("%s: insert succeeded without any exceptions.",r));
                }
 
        /*  4.  Insert failed and we got control back. */
        else if(strncmp(error.sqlcode, "42000", 5) == 0)
                {
                status = idn_cb_test_create(conn);
                if(status != MI_OK)
                        {
                        mi_db_error_raise(NULL, MI_EXCEPTION,
                                "Can't create idn_cb_test table!");
                        return retval;
                        }
 
                DPRINTF(TRC_CLASS, TRC_THRESH,
                        ("%s: idn_cb_test table created.",r));
 
                /* retry the insert */
                status = idn_cb_test_insert(conn, xact_str);
                if(status != MI_OK)
                        {
                        mi_db_error_raise(NULL, MI_EXCEPTION,
                           "Second attempt inserting into idn_cb_test failed!");
                        return retval;
                        }
 
                DPRINTF(TRC_CLASS, TRC_THRESH,
                ("%s: second attempt inserting into idn_cb_test succeeded.",r));
                }
 
        else /* Something else happened that we aren't prepared to handle */
                {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "Can't insert into idn_cb_test!");
                return retval;
                }
 
        /* clean up and return */
 
        (void) mi_query_finish(conn);
        (void) mi_unregister_callback(conn, MI_Exception, cback);
        (void) mi_close(conn);
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function\n",r));
 
        return retval;
}
 
mi_integer
idn_cb_test_insert(MI_CONNECTION *conn, mi_string *str)
{
        mi_string       query[256],
                        *r="idn_cb_test_insert";
        mi_integer      status;
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering function",r));
 
        /* Build the query */
        sprintf(query,
                "insert into idn_cb_test values \
                (current, %d, %d, '%s');",
                mi_get_id(conn, MI_SESSION_ID),
                mi_get_id(conn, MI_STATEMENT_ID),
                str);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: query to execute='%s'",r, query));
 
        /* Do the insert. */
        (void) mi_query_finish(conn);
        status = mi_exec(conn, query, MI_QUERY_NORMAL);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: query status=%d",r, status));
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function\n",r));
 
        return status;
}
 
mi_integer
idn_cb_test_create(MI_CONNECTION *conn)
{
        mi_string       query[256],
                        *r="idn_cb_test_create";
        mi_integer      status;
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering function",r));
 
        strncpy(query,
                "create table idn_cb_test \
                (dtime      datetime year to second, \
                sess_id     int, \
                stmt_id     int, \
                description lvarchar);",
                sizeof(query)-1);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: query to execute='%s'",r, query));
 
        (void) mi_query_finish(conn);
        status = mi_exec(conn, query, MI_QUERY_NORMAL);
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function\n",r));
 
        return status;
}
 
/*
** NAME
**      idn_exception_cb()
**
** DESCRIPTION
**      Stores MI_Exception information in the user-provided error buffer.
**
** RETURN VALUE
**      MI_CB_EXC_HANDLED       If "insert" fails because the table
**                              doesn't exist:
**                                      sqlcode:     42000
**                                      isam error:  111
**
**      MI_CB_CONTINUE          Any other error.
*/
 
MI_CALLBACK_STATUS
idn_exception_cb (MI_EVENT_TYPE type, MI_CONNECTION *conn,
                void *server_info, void *user_data)
{
        MI_CALLBACK_STATUS retval;
        MI_ERROR_DESC   *p=NULL;        /* ptr to multiple messages buffer */
        error_mesg_t    *user_info;
        mi_string       *s,
                        *r="idn_exception_cb";
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering callback",r));
 
        user_info = ((error_mesg_t *)user_data);
 
        /* Initialize error_mesg_t buffer */
        user_info->evtype = type;
        user_info->mesg[0] = '\0';
        user_info->sqlcode[0] = '\0';
 
        if(type != MI_Exception)
                {
                sprintf(user_info->mesg,
                        "%s called with wrong event type %d.", r, type);
                DPRINTF(TRC_CLASS, TRC_THRESH,
                        ("%s: mesg=%s", r, user_info->mesg));
                return MI_CB_CONTINUE;
                }
 
        /* Store the first (SQL) error message */
        p=(MI_ERROR_DESC *)server_info;
        mi_error_sql_state(p, user_info->sqlcode, 6);
        mi_errmsg(p, user_info->mesg, MESG_SIZE-1);
        DPRINTF(TRC_CLASS, TRC_THRESH,
                ("%s: sqlcode=%s, mesg=%s",
                r,
                user_info->sqlcode,
                user_info->mesg));
 
        /* Get and skip the second (isam) error message.
        ** Under other circumstances, you might want to pay
        ** attention to the second message; for example, for
        ** smart blob errors. In our case, we are specifically
        ** interested in SQL code 42000.
        */
        p=mi_error_desc_next((MI_ERROR_DESC *)server_info);
 
        if (strncmp(user_info->sqlcode, "42000", 5) == 0 )
                retval = MI_CB_EXC_HANDLED;
        else
                retval = MI_CB_CONTINUE;
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving callback\n",r));
 
        return retval;
}

/* }}FUNCTION (#HQTA) */




/* {{FUNCTION(ecc4c662-798d-11d1-9c2d-000000000000) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	IDN_FuncCache
**
** Description:
**      Executes another UDR using mi_routine_get() and mi_routine_exec().
**      This simple case executes the built-in Equal UDR; but it is intended
**      to show how you might execute functions in another DataBlade module.
**
**      FuncCache is an optimized version of FuncExec.
**
**      mi_routine_get() is somewhat expensive. If you have a UDR that calls
**      it a lot, you can avoid the overhead by caching the pointers to the
**      connection handle and to the MI_FUNC_DESC in the MI_FPARAM.
**
** Special Comments:
**
**	Entrypoint for the SQL routine IDN_FuncCache (integer,integer) returns boolean.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	arg1    integer value
**      arg2    integer value
**
** Return value:
**
**	mi_integer boolean result ('t' or 'f')
**
** History:
**
**	08/24/1999 - Generated by BladeSmith Version 4.00.TC1B.
**      Dec 20, 1997 - Generated by BladeSmith Version 3.50.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer IDN_FuncCache
(
mi_integer      arg1,
mi_integer      arg2,
MI_FPARAM *     Gen_fparam  /* Standard info - see DBDK docs. */
)
{
        mi_integer      bool_ret;                       /* MI_TRUE / MI_FALSE */
        mi_string       *funcsig="equal(int,int)",      /* function to execute*/
                        *r="IDN_FuncCache";
 
        MI_DATUM        funcresult;             /* function return value */
        mi_integer      funcerror;              /* mi_routine_exec status */
 
        func_cache_t    *fstate=NULL;   /* Stores conn and routine pointers */
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: entering function", r));
 
        /* Initialize return value to NULL. */
        mi_fp_setreturnisnull(Gen_fparam, 0, MI_TRUE);
 
        /* Fetch the pointer from the MI_FPARAM. */
        fstate = (func_cache_t *) mi_fp_funcstate(Gen_fparam);
 
        /* mi_fp_funcstate() returns NULL on UDR Invocation #1.
        ** So we know it is time to allocate the fstate structure
        ** with a PER_COMMAND duration using mi_dalloc().
        */
        if(fstate==(func_cache_t *) NULL)
        {
                /* Allocate fstate structure */
                fstate=
                (func_cache_t *) mi_dalloc(sizeof(func_cache_t),PER_COMMAND);
 
                /* Get a connection handle */
                fstate->conn=mi_open(NULL,NULL,NULL);
                if(fstate->conn == NULL)
                {
                        mi_db_error_raise(NULL, MI_EXCEPTION,
                                "IDN_FuncCache: mi_open failed!");
                        return MI_ERROR; /* not reached */
                }
 
                /* Get the function descriptor */
                fstate->func_ptr=mi_routine_get(fstate->conn, 0, funcsig);
                if(fstate->func_ptr == NULL)
                {
                        mi_db_error_raise(NULL,MI_EXCEPTION,
                                "mi_routine_get() failed");
                        return MI_ERROR; /* not reached */
                }
 
                /* Store the fstate pointer in the MI_FPARAM */
                mi_fp_setfuncstate(Gen_fparam, (void *) fstate);
 
                DPRINTF(TRC_CLASS, 1,
                        ("%s: allocated and stored fstate", r));
 
        } /* END if fstate NULL */
        else
                DPRINTF(TRC_CLASS, 1, ("%s: got fstate from MI_FPARAM", r));
 
        /* Go ahead and execute the function */
        funcresult = mi_routine_exec(fstate->conn, fstate->func_ptr,
                &funcerror, arg1, arg2);
        if(funcerror == MI_ERROR)
        {
                mi_db_error_raise(NULL, MI_EXCEPTION,
                        "mi_routine_exec() failed");
                return MI_ERROR; /* not reached */
        }
 
        /* Get the return value. */
        bool_ret = (mi_boolean) funcresult;
 
        DPRINTF(TRC_CLASS,1,
                ("%s: equal(%d,%d)=%s", r, arg1, arg2,
                        bool_ret == MI_TRUE ? "MI_TRUE":"MI_FALSE"));
 
        DPRINTF(TRC_CLASS, TRC_THRESH, ("%s: leaving function", r));
 
        /* Initialize return value to not-NULL. */
        mi_fp_setreturnisnull(Gen_fparam, 0, MI_FALSE);
 
        return bool_ret;
}
/* }}FUNCTION (#JV1F) */



#ifdef __cplusplus

}

#endif
