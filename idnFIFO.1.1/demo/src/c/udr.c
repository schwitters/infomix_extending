/*
** Title:          idn_fifo
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        09/15/1998 09:44
** Description:    This is the generated 'C' file for the idn_fifo DataBlade.
** Comments:       Generated for project idn_fifo.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "idn_fifo.h"
#include <unistd.h>
#include <fcntl.h>

/* {{FUNCTION(e2d03d91-4cb3-11d2-b5aa-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	idnCallFIFO
**
** Description:
**
**      Builds a temp file name and opens it as a named pipe on which to
**      receive input from the external program. Sends a text string, along
**      with the name of this pipe, to the "well-known FIFO", the named pipe
**      that the external program reads. Gets back a text string and returns
**      it to the client.
**
** Special Comments:
**
**	Entrypoint for the SQL routine idnCallFIFO (lvarchar) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	09/15/1998 - Generated by BladeSmith Version 3.60.TC2  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/


UDREXPORT 
mi_lvarchar *idnCallFIFO
(

mi_lvarchar *           textString,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.          */
	mi_lvarchar      *Gen_RetVal;       /* The return value.              */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_string   *server_fifo = "/tmp/idn_fifo.tmp"; /* server FIFO name */
	mi_integer  server_fd;               /* fd for server FIFO   */
	mi_integer  client_secs;             /* unique part of fifo name */
	mi_string   client_fifo[BUFSIZ];     /* client FIFO name     */
	mi_integer  client_fd;               /* fd for client FIFO   */

	mi_string   *outstring;
	mi_string   outbuf[BUFSIZ];
	mi_string   inbuf[BUFSIZ];           /* read into this buffer */
	mi_integer  n;

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* get a unique integer to use in the client's fifo name */
	client_secs = time((time_t)0);

	/* build the client's fifo name */
	sprintf(client_fifo, "/tmp/idn_client-%d.tmp", client_secs);

	/* create it */
	if (mkfifo(client_fifo, (mode_t) 0666) < 0)
	{
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		  "Unable to create client fifo.");
		/* not reached */
	}

	/* open it for reading */
	client_fd = open(client_fifo, O_RDWR, 0666); 
	/* client_fd = mi_file_open(client_fifo, O_RDWR, 0666); */
	if (client_fd == MI_ERROR)
	{
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		  "Unable to open client fifo.");
		/* not reached */
        }

	/* open the server's fifo */
	/* server_fd = open(server_fifo, O_WRONLY, 0666); */
	server_fd = open(server_fifo, O_WRONLY, 0666);
	if (server_fd == MI_ERROR)
	{
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		  "Unable to open server fifo.");
		/* not reached */
        }

	/* get the output string */
	if ((outstring = mi_lvarchar_to_string(textString)) == NULL)
	{
		(void)unlink(client_fifo);
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		  "mi_lvarchar_to_string() failed.");
		/* not reached */
        }
	
	/* build the output buffer (client_secs + output string) and send it */
	sprintf(outbuf, "%d %s", client_secs, outstring);

	mi_free(outstring); /* done with this now */
	n = write(server_fd, outbuf, strlen(outbuf));
	/* n = mi_file_write(server_fd, outbuf, strlen(outbuf)); */
	if (n != strlen(outbuf))
	{
		(void)unlink(client_fifo);
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		  "write() failed.");
		/* not reached */
        }

	/* now let's wait a second for the server */
	mi_yield();

	/* read the response. */
	memset(inbuf, 0, BUFSIZ);
	n = read(client_fd, inbuf, BUFSIZ);
	/* n = mi_file_read(client_fd, inbuf, BUFSIZ); */
	inbuf[n] = '\0';

	/* put the response in an mi_lvarchar and return it */
	Gen_RetVal = mi_string_to_lvarchar(inbuf);

	/* Close and remove the client fifo */
	close(client_fd);
	/* mi_file_close(client_fd); */
	(void)unlink(client_fifo);

	/* ------ }}Your_Code (#4U7I) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#25CK) */


#ifdef __cplusplus

}

#endif
