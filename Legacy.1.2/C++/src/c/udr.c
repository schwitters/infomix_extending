/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        08/23/1999 12:48
** Description:    This is a generated source file for the idn_LegacyCPP DataBlade module.
** Comments:       Generated for project idn_LegacyCPP.1.2
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "idn_LegacyCPP.h"


/* {{FUNCTION(a8a4573a-5980-11d3-b68a-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	cppTraceOn
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine cppTraceOn () returns integer.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/23/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer cppTraceOn(MI_FPARAM *Gen_fparam)

{
	MI_CONNECTION *      Gen_Con;         /* The connection handle.       */
	mi_integer           Gen_RetVal;      /* The return value.            */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	/* ------ }}Your_Declarations (#0000) END ------             */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        /*
        ** Turn on tracing. We'll use the quick-and-dirty default
        ** trace class (__myErrors__), and set the level to 20.
        */
        if (mi_tracelevel_set("__myErrors__ 20") == MI_ERROR)
        {
                return MI_ERROR;
        }
 
        if (mi_tracefile_set("/tmp/LegacyCPP.trc") == MI_ERROR)
        {
                return MI_ERROR;
        }

	Gen_RetVal = 0;

	/* ------ }}Your_Code (#NSG9) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#TSR2) */




/* {{FUNCTION(a8a45739-5980-11d3-b68a-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	cppRoutine
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine cppRoutine (integer) returns lvarchar.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	08/23/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *cppRoutine
(

mi_integer                   cpp_input,
MI_FPARAM *                  Gen_fparam       /* Standard info - see DBDK docs.          */
)
{
	mi_lvarchar *        Gen_RetVal;      /* The return value.                       */
	MI_CONNECTION *      Gen_Con;         /* The connection handle.                  */
	mi_integer           Gen_ReturnSize;  /* Return value is this size.              */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	gl_mchar_t *       Gen_RetData;   /* Store the return data here.        */
	/* ------ }}Your_Declarations (#SVG2) END ------             */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        /*
        ** Write to the trace file indicating
        ** that cppRoutine has been called.
        */
         DPRINTF( "__myErrors__", 20, ("entering cppRoutine..."));

        /*
        ** Allocate the return value.  It must be
        ** allocated if it is a UDT or type whose
        ** size is greater than 4 bytes.
        */
        /*
        ** Our C++ routine takes an integer and returns a text string. We
        ** need to convert that string to an mi_lvarchar and return it to
        ** the server.
        */
 
        /*
        ** Call the C++ routine
        */
        DPRINTF( "__myErrors__", 20, ("...calling call_cplusplus()"));
 
        Gen_RetVal =
          mi_string_to_lvarchar((mi_string *)(call_cplusplus(cpp_input)));
        if( Gen_RetVal == NULL)
        {
                /*
                ** Memory allocation has failed so issue
                ** the following message and quit.
                **
                **      "Memory allocation has failed in cppRoutine."
                */
                DBDK_TRACE_ERROR( "cppRoutine", ERRORMESG2, 10 );
 
                /* not reached */
        }
 
        /*
        ** Write to the trace file indicating
        ** that cppRoutine has successfully exited.
        */
        DPRINTF( "__myErrors__", 20, ("leaving cppRoutine..."));
 
	/* ------ }}Your_Code (#1941) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#GS5F) */



#ifdef __cplusplus

}

#endif
