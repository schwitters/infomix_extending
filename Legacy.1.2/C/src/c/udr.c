/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        08/23/1999 12:03
** Description:    This is a generated source file for the idn_LegacyC DataBlade module.
** Comments:       Generated for project idn_LegacyC.1.2
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "idn_LegacyC.h"


/* {{FUNCTION(a8a45736-5980-11d3-b68a-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	cRoutine
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine cRoutine (integer) returns lvarchar.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_lvarchar
**
** History:
**
**	08/23/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_lvarchar *cRoutine
(

mi_integer                   c_input,
MI_FPARAM *                  Gen_fparam       /* Standard info - see DBDK docs.          */
)
{
	mi_lvarchar *        Gen_RetVal;      /* The return value.            */
	MI_CONNECTION *      Gen_Con;         /* The connection handle.       */
	mi_integer           Gen_ReturnSize;  /* Return value is this size.   */

	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	/* ------ }}Your_Declarations (#SVG2) END ------             */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        /*
        ** Write to the trace file indicating
        ** that cRoutine has been called.
        */
         DPRINTF( "__myErrors__", 20, ("entering cRoutine..."));

        /*
        ** Our C routine takes an integer and returns a text string. We
        ** need to convert that string to an mi_lvarchar and return it to
        ** the server.
        */
 
        /*
        ** Call the C routine
        */
        DPRINTF( "__myErrors__", 20, ("...calling call_c()"));
 
        Gen_RetVal =
          mi_string_to_lvarchar((mi_string *)(call_c(c_input)));
        if( Gen_RetVal == NULL)
        {
                /*
                ** Memory allocation has failed so issue
                ** the following message and quit.
                **
                **      "Memory allocation has failed in cRoutine."
                */
                DBDK_TRACE_ERROR( "cRoutine", ERRORMESG2, 10 );
 
                /* not reached */
        }
 
        /*
        ** Write to the trace file indicating
        ** that cRoutine has successfully exited.
        */
        DPRINTF( "__myErrors__", 20, ("leaving cRoutine..."));
 

	/* ------ }}Your_Code (#P7CH) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#MU54) */




/* {{FUNCTION(a8a45737-5980-11d3-b68a-00a024e37610) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	cTraceOn
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine cTraceOn () returns integer.
**
**      A stack size of 32,767 bytes  has  been  requested  for
**      the routine.  Normally, this is sufficient memory for most
**      invocations of your UDR.  If you intend, however, to  call
**      this routine recursively or other routines that use  large
**      or unknown stack sizes, you should use mi_call().  mi_call
**      checks to insure that sufficient stack space is available.
**      For  more  details  regarding  this   function,  look  in:
**      The  DataBlade  API Programmer's  Manual  (see Stack Space
**      Allocation in Chapter 11).
**
** Parameters:
**
**	None
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/23/1999 - Generated by BladeSmith Version 4.00.TC1B.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer cTraceOn(MI_FPARAM *Gen_fparam)

{
	MI_CONNECTION *      Gen_Con;         /* The connection handle.                  */
	mi_integer           Gen_RetVal;      /* The return value.                       */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	/* ------ }}Your_Declarations (#0000) END ------             */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        /*
        ** Turn on tracing. We'll use the quick-and-dirty default
        ** trace class (__myErrors__), and set the level to 20.
        */
        if (mi_tracelevel_set("__myErrors__ 20") == MI_ERROR)
        {
                return MI_ERROR;
        }
 
        if (mi_tracefile_set("/tmp/LegacyC.trc") == MI_ERROR)
        {
                return MI_ERROR;
        }

        Gen_RetVal = 0;

	/* ------ }}Your_Code (#RQ8B) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#D6UN) */



#ifdef __cplusplus

}

#endif
