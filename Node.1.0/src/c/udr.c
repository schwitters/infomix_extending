/*
** Title:          udr.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix Software, Inc.
** Created:        04/12/1999 12:42
** Description:    This is a generated source file for the Node DataBlade module.
** Comments:       Generated for project Node.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Node.h"


/* {{FUNCTION(759491c3-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeAncestors
**
** Description:
**
**	This  function  is an iterator function.   As such,  it  must  be
**	registered using SQL as an iterator function:
**
**	     create function Ancestors( args )
**	      	returns Node
**	       	with
**	       	(
**	              	iterator
**	       	)
**	       	external name "yourpath/Node.bld(NodeAncestors)"
**	       	language C
**	     end function;
**
**	Iterator functions are called with state information.   There are
**	three  states:  SET_INIT,  SET_RETONE,  and SET_END.   This state
**	information  is  passed  in via the Gen_fparam  argument  to  the
**	function  and placed in Gen_IteratorState.   During the  SET_INIT
**	state,   the   iterator  function  must  perform   any   required
**	initialization.   Typically, this means allocating memory to hold
**	any  information  that  is needed across calls to  the  function.
**	This  allocated  memory must be stored back  into  Gen_fparam  by
**	calling  mi_fp_setfuncstate  and  can  be  retrieved  by  calling
**	mi_fp_funcstate.  Values passed back from this state are ignored.
**
**	Following  initialization,  the function is repeatedly called  in
**	the SET_RETONE state.   The return value returned from this state
**	is  passed back to the user.   The function is called  repeatedly
**	until  the  iterator function signals that no more data is to  be
**	passed back.  The iterator function *MUST* call:
**
**		mi_fp_setisdone( Gen_fparam, MI_TRUE );
**
**	to conclude looping.   Failing to call this function will  result
**	in infinite looping!
**
**	Finally, the iterator function is called in the SET_END state and
**	the  function  is given a chance to perform any cleanup  that  is
**	required.  Values passed back from this state are ignored.
**
**	N.B.: If mi_db_error_raise is called during the processing of the
**	iterator function,  the function  is not  called in  the  SET_END
**	state. Resources allocated using mi_dalloc on a PER_COMMAND basis
**	are freed for you but all other resources should be  freed before
**	calling mi_db_error_raise.
**
**
** Special Comments:
**
**	Entrypoint for the SQL routine Ancestors (Node) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeAncestors
(

mi_bitvarying *         node,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{


	int             Gen_IteratorState;              /* This is the iteration state.           */
	MI_CONNECTION * Gen_Con = NULL;                 /* The current connection.                */
	mi_bitvarying * Gen_RetVal = 0;                 /* NodeAncestors's return value.          */

	/* ------ {{Your_StateInfoDeclaration (PreserveSection) BEGIN ------ */

		struct _StateInfo
		{
			MI_CONNECTION * Conn;           /* The current connection.                */
			mi_bitvarying *          StateInfo;      /* Private state information.             */
		} * Gen_StateInfo;                      /* NodeAncestors's state information.     */

	/* ------ }}Your_StateInfoDeclaration (#0JN8) END ------ */

	/* ------ {{Your_AutoVariable_Declarations (PreserveSection) BEGIN ------ */

		MI_MEMORY_DURATION md;
		Node * retNode;
		mi_unsigned_integer c, v;

	/* ------ }}Your_AutoVariable_Declarations (#0000) END ------ */

	/* Get the iteration state. */
	Gen_IteratorState = mi_fp_request( Gen_fparam );

	/*
	** Based  on the iteration  state,
	** calculate the iterator's return
	** value.
	*/
	switch( Gen_IteratorState )
	{
		case SET_INIT:			/* Initialize */

			/*
			** Get the current connection handle.
			** This connection handle is held in
			** the state information for the duration
			** of the running of NodeAncestors.
			*/
			Gen_Con = mi_open( NULL, NULL, NULL );

			/* Verify that the connection has been established. */
			if( Gen_Con == 0 )
			{
				/*
				** Opening the current connection has failed
				** so issue the following message and quit.
				**
				** 	"Connection has failed in NodeAncestors."
				*/
				DBDK_TRACE_ERROR( "NodeAncestors", ERRORMESG1, 10 );

				/* not reached */
			}

			/* ------ {{Your_InitializationCode (PreserveSection) BEGIN ------ */
			{
				/*
				** Allocate the  state  information.   Both
				** the   private  state   information   and
				** connection are stored here.
				*/
				Gen_StateInfo = (struct _StateInfo *)
								   mi_dalloc( sizeof( struct _StateInfo ), PER_COMMAND );
				if( Gen_StateInfo == NULL )
				{
					DBDK_TRACE_ERROR( "NodeAncestors", ERRORMESG2, 10 );
				}

				/* Save the connection. */
				Gen_StateInfo->Conn = Gen_Con;

				/* Make copy of input node as private state information. */
				md = mi_switch_mem_duration(PER_COMMAND);
				Gen_StateInfo->StateInfo = (mi_bitvarying *) mi_var_copy(node);
				mi_switch_mem_duration(md);

			}
			/* ------ }}Your_InitializationCode (#MNP6) END ------ */

			if( Gen_StateInfo->StateInfo == NULL )
			{
				DBDK_TRACE_ERROR( "NodeAncestors", ERRORMESG2, 10 );
			}

			/* Register the private state info in Gen_fParam. */
			mi_fp_setfuncstate( Gen_fparam, Gen_StateInfo );

			break;

		case SET_RETONE:		/* Iterate */

			/*
			** Before  using,  insure  that  the  state
			** information  is valid. It might  not  be
			** if the function has not been  called  as
			** an iterator.
			*/
			Gen_StateInfo = (struct _StateInfo *)mi_fp_funcstate( Gen_fparam );
			if( Gen_StateInfo == NULL )
			{
				DBDK_TRACE_ERROR( "NodeAncestors", ERRORMESG2, 10 );
			}

			/* Retrieve the connection. */
			Gen_Con = Gen_StateInfo->Conn;



			/* ------ {{Your_SetReturnCode (PreserveSection) BEGIN ------ */
			{

				
				Gen_RetVal = Gen_StateInfo->StateInfo;

				/* Point to the data values that are to be compared. */
				retNode = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

				c = retNode->count;
				v = retNode->data[1];

				/* If input node is a root node, indicate set is done */
				if (v == 0)
				{
					mi_fp_setisdone( Gen_fparam, MI_TRUE );
				}
				/* If input node is length 2, return root node */
				else if (c == 2)
				{
					retNode->data[1] = 0;
				}
				else
				{
					retNode->count = c - 1;
				}
			}

			/* ------ }}Your_SetReturnCode (#6MM0) END ------ */


			/* Check for a NULL return value. */
			if( Gen_RetVal == 0 )
			{
				mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
			}
			else
			{
				mi_fp_setreturnisnull( Gen_fparam, 0, MI_FALSE );
			}

			return ( Gen_RetVal );

		case SET_END:			/* Conclude */

			/* Get the state information. */
			Gen_StateInfo = (struct _StateInfo *)mi_fp_funcstate( Gen_fparam );

			if( Gen_StateInfo != NULL )
			{
				/* Retrieve the connection. */
				Gen_Con = Gen_StateInfo->Conn;


				/* Close the open connection. */
				mi_close( Gen_Con );

				/* ------ {{Your_SetFinalCode (PreserveSection) BEGIN ------ */
				{
					/* Free the private state information. */
					if( Gen_StateInfo->StateInfo != NULL )
					{
						mi_var_free( Gen_StateInfo->StateInfo );
					}
				}
				/* ------ }}Your_SetFinalCode (#000J) END ------ */

				/* Free the state information. */
				mi_free( Gen_StateInfo );
			}

			break;

		default:

			/* Get the state information. */
			Gen_StateInfo = (struct _StateInfo *)mi_fp_funcstate( Gen_fparam );

			if( Gen_StateInfo != NULL )
			{
				/* Retrieve the connection. */
				Gen_Con = Gen_StateInfo->Conn;
			}

			/*
			** This is an invalid state so issue
			** the following message and quit.
			**
			** 	"Invalid iterator state used in NodeAncestors."
			*/
			DBDK_TRACE_ERROR( "NodeAncestors", ERRORMESG17, 10 );

			/* not reached */

			break;
	}

	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	return ( 0 );
}
/* }}FUNCTION (#H3C4EK8R) */



/* {{FUNCTION(759491bf-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeGetMember
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine GetMember (Node,integer) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	06/21/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeGetMember
(

Node *                  node,

mi_integer              element,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	mi_unsigned_integer c;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the input data value. */
	inVal = (Node *)mi_get_vardata( (mi_lvarchar *)node );

	c = inVal->count;

	if (element > (mi_integer) c)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
		Gen_RetVal = 0;
	}
	else if (element < 1)
	{
		mi_db_error_raise(Gen_Con,MI_SQL,"UNOD4",NULL);
	}
	else
	{
		Gen_RetVal = (mi_integer) inVal->data[element-1];
	}

	/* ------ }}Your_Code (#23FU) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#KSH0RV6C) */





/* {{FUNCTION(759491c2-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIsChild
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IsChild (Node,Node) returns boolean.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeIsChild
(

mi_bitvarying *         node1,

mi_bitvarying *         node2,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal1;       /* Pointer to the first value.        */
	Node *          inVal2;       /* Pointer to the second value.       */
	mi_unsigned_integer i, c1, c2, v1, v2;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the data values that are to be compared. */
	inVal1 = (Node *)mi_get_vardata( (mi_lvarchar *)node1 );
	inVal2 = (Node *)mi_get_vardata( (mi_lvarchar *)node2 );

	/* Get the lengths and second values of the two UDTs. */
	c1 = inVal1->count;
	c2 = inVal2->count;
	v1 = inVal1->data[1];
	v2 = inVal2->data[1];
	
	/* Handle case where node1 is a root node. */
	if (v1 == 0)
	{
		Gen_RetVal = MI_FALSE;
	}
	
	/* Handle case where node2 is a root node. */
	else if (v2 == 0)
	{
		v1 = inVal1->data[0];
		v2 = inVal2->data[0];
		if ((v1 == v2) && (c1 == c2))
			Gen_RetVal = MI_TRUE;
		else
			Gen_RetVal = MI_FALSE;
	}
	else if (c1 == c2)
	{
		Gen_RetVal = MI_FALSE;
	}
	else if (c1 == (c2 + 1))
	{
		for (i=0; i < c2; i++)
		{
			v1 = inVal1->data[i];
			v2 = inVal2->data[i];
			if (v1 != v2) {Gen_RetVal = MI_FALSE; break;}
		}
		if (i == c2) {Gen_RetVal = MI_TRUE;}
	}
	else /* c1 < c2 */
	{
		Gen_RetVal = MI_FALSE;
	}
	/* ------ }}Your_Code (#GOD2) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#7UDRV85U) */




/* {{FUNCTION(759491be-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeLength
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Length (Node) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeLength
(

mi_bitvarying *         node,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	
	inVal = (Node *)mi_get_vardata((mi_lvarchar *) node);

	/* If root node, return 1, else return count */
	if (inVal->data[1]==0)
		Gen_RetVal = 1;
	else
		Gen_RetVal = inVal->count;

	/* ------ }}Your_Code (#992V) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#P14OFGCQ) */



/* {{FUNCTION(759491bc-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIncrCnt
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Increment (Node,integer) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	06/21/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeIncrCnt
(

Node *                  node,

mi_integer              element,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;       /* The return value wrapper.          */
	Node *          Gen_OutData;      /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	mi_unsigned_integer c;
	mi_integer i, varlen;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the input data value. */
	inVal = (Node *)mi_get_vardata( (mi_lvarchar *)node );
	c = inVal->count;

	if (element < 1)
	{
		mi_db_error_raise(Gen_Con,MI_SQL,"UNOD4",NULL);
	}
	else if (element == 1)
	{
		varlen = sizeof(Node) + sizeof(mi_unsigned_integer);
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen);
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeIncrCnt."
			*/
			DBDK_TRACE_ERROR( "NodeIncrCnt", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = 2;
		Gen_OutData->data[0] = inVal->data[0] + 1;
		Gen_OutData->data[1] = 0;
	}
	else if ( element <= (mi_integer) c )
	{
		varlen = sizeof(Node) + (element-1) * sizeof(mi_unsigned_integer);
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen);
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeIncrCnt."
			*/
			DBDK_TRACE_ERROR( "NodeIncrCnt", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = element;

		for (i=0; i<(element-1); i++)
		{
			Gen_OutData->data[i] = inVal->data[i];
		}

		Gen_OutData->data[i] = inVal->data[i]+1;
	}
	else
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
		Gen_RetVal = (mi_bitvarying *)NULL;
	}

	/* ------ }}Your_Code (#P37L) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#ACTO8HVV) */




/* {{FUNCTION(759491c1-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIsParent
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IsParent (Node,Node) returns boolean.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeIsParent
(

mi_bitvarying *         node1,

mi_bitvarying *         node2,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal1;       /* Pointer to the first value.        */
	Node *          inVal2;       /* Pointer to the second value.       */
	mi_unsigned_integer i, c1, c2, v1, v2;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the data values that are to be compared. */
	inVal1 = (Node *)mi_get_vardata( (mi_lvarchar *)node1 );
	inVal2 = (Node *)mi_get_vardata( (mi_lvarchar *)node2 );

	/* Get the lengths and the second values of the two UDTs. */
	c1 = inVal1->count;
	c2 = inVal2->count;
	v1 = inVal1->data[1];
	v2 = inVal2->data[1];


	/* Handle case where node2 is a root node. */
	if (v2 == 0)
	{
		Gen_RetVal = MI_FALSE;
	}
	
	/* Handle case where node1 is a root node. */
	else if (v1 == 0)
	{
		v1 = inVal1->data[0];
		v2 = inVal2->data[0];
		if ((v1 == v2) && (c1 == c2))
			Gen_RetVal = MI_TRUE;
		else
			Gen_RetVal = MI_FALSE;
	}
	else if (c1 == c2)
	{
		Gen_RetVal = MI_FALSE;
	}
	else if (c1 == (c2 - 1))
	{
		for (i=0; i < c1; i++)
		{
			v1 = inVal1->data[i];
			v2 = inVal2->data[i];
			if (v1 != v2) {Gen_RetVal = MI_FALSE; break;}
		}
		if (i == c1) {Gen_RetVal = MI_TRUE;}
	}
	else /* c1 > c2 */
	{
		Gen_RetVal = MI_FALSE;
	}

	/* ------ }}Your_Code (#QA8C) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#TFK2BR5G) */




/* {{FUNCTION(759491c0-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeGetParent
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine GetParent (Node) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeGetParent
(

mi_bitvarying *         node,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;       /* The return value wrapper.          */
	Node *          Gen_OutData;      /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	mi_unsigned_integer c, v, i;
	mi_integer varlen;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the input data value. */
	inVal = (Node *)mi_get_vardata( (mi_lvarchar *)node );

	c = inVal->count;
	v = inVal->data[1];

	/* If input node is a root node, return NULL */
	if (v == 0)
	{
		mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
		Gen_RetVal = (mi_bitvarying *)NULL;
	}
	/* If input node is length 2, return root node */
	else if (c == 2)
	{
		varlen = mi_get_varlen( (mi_lvarchar *)node );
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen);
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeGetParent."
			*/
			DBDK_TRACE_ERROR( "NodeGetParent", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = 2;
		Gen_OutData->data[0] = inVal->data[0];
		Gen_OutData->data[1] = 0;
	}
	else
	{
		varlen = mi_get_varlen( (mi_lvarchar *)node );
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen - sizeof(mi_unsigned_integer));
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeGetParent."
			*/
			DBDK_TRACE_ERROR( "NodeGetParent", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = c - 1;
		for (i=0; i<(c-1); i++)
		{
			Gen_OutData->data[i] = inVal->data[i];
		}	
	}
	/* ------ }}Your_Code (#A6RT) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#5847V08Q) */




/* {{FUNCTION(759491bd-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIncr
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Increment (Node) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeIncr
(

mi_bitvarying *         node,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;       /* The return value wrapper.          */
	Node *          Gen_OutData;      /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	mi_unsigned_integer c, i;
	mi_integer varlen;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the data values that are to be compared. */
	inVal = (Node *)mi_get_vardata( (mi_lvarchar *)node );

	c = inVal->count;

	varlen = mi_get_varlen( (mi_lvarchar *)node );
	Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen);
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeIncr."
		*/
		DBDK_TRACE_ERROR( "NodeIncr", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to where the return value is to be placed. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	Gen_OutData->count = c;

	for (i=0; i<c; i++)
	{
		Gen_OutData->data[i] = inVal->data[i];
	}

	if (inVal->data[1] == 0)
		Gen_OutData->data[0] = inVal->data[0]+1;
	else
		Gen_OutData->data[c-1] = inVal->data[c-1]+1;

	/* ------ }}Your_Code (#D181) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#DPP353MB) */


/* {{FUNCTION(f7e39282-096e-11d3-b61a-e54f83e83151) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIsDescendant
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IsDescendant (Node,Node) returns boolean.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	05/13/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeIsDescendant
(

mi_bitvarying *                  node1,

mi_bitvarying *                  node2,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal1;       /* Pointer to the first value.        */
	Node *          inVal2;       /* Pointer to the second value.       */
	mi_unsigned_integer i, c1, c2, v1, v2;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the data values that are to be compared. */
	inVal1 = (Node *)mi_get_vardata( (mi_lvarchar *)node1 );
	inVal2 = (Node *)mi_get_vardata( (mi_lvarchar *)node2 );

	/* Get the lengths and second values of the two UDTs. */
	c1 = inVal1->count;
	c2 = inVal2->count;
	v1 = inVal1->data[1];
	v2 = inVal2->data[1];
	
	/* Handle case where node1 is a root node. */
	if (v1 == 0)
	{
		Gen_RetVal = MI_FALSE;
	}
	
	/* Handle case where node2 is a root node. */
	else if (v2 == 0)
	{
		v1 = inVal1->data[0];
		v2 = inVal2->data[0];
		if (v1 == v2)
			Gen_RetVal = MI_TRUE;
		else
			Gen_RetVal = MI_FALSE;
	}
	else if (c1 == c2)
	{
		Gen_RetVal = MI_FALSE;
	}
	else if (c1 > c2)
	{
		for (i=0; i < c2; i++)
		{
			v1 = inVal1->data[i];
			v2 = inVal2->data[i];
			if (v1 != v2) {Gen_RetVal = MI_FALSE; break;}
		}
		if (i == c2) {Gen_RetVal = MI_TRUE;}
	}
	else /* c1 < c2 */
	{
		Gen_RetVal = MI_FALSE;
	}
	/* ------ }}Your_Code (#SHLG) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#CMFODJS9) */


/* {{FUNCTION(f7e39280-096e-11d3-b61a-e54f83e83151) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeIsAncestor
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine IsAncestor (Node,Node) returns boolean.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	05/13/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/

UDREXPORT 
mi_integer NodeIsAncestor
(

mi_bitvarying *                  node1,

mi_bitvarying *                  node2,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal1;       /* Pointer to the first value.        */
	Node *          inVal2;       /* Pointer to the second value.       */
	mi_unsigned_integer i, c1, c2, v1, v2;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the data values that are to be compared. */
	inVal1 = (Node *)mi_get_vardata( (mi_lvarchar *)node1 );
	inVal2 = (Node *)mi_get_vardata( (mi_lvarchar *)node2 );

	/* Get the lengths and the second values of the two UDTs. */
	c1 = inVal1->count;
	c2 = inVal2->count;
	v1 = inVal1->data[1];
	v2 = inVal2->data[1];


	/* Handle case where node2 is a root node. */
	if (v2 == 0)
	{
		Gen_RetVal = MI_FALSE;
	}
	
	/* Handle case where node1 is a root node. */
	else if (v1 == 0)
	{
		v1 = inVal1->data[0];
		v2 = inVal2->data[0];
		if (v1 == v2)
			Gen_RetVal = MI_TRUE;
		else
			Gen_RetVal = MI_FALSE;
	}
	else if (c1 == c2)
	{
		Gen_RetVal = MI_FALSE;
	}
	else if (c1 < c2)
	{
		for (i=0; i < c1; i++)
		{
			v1 = inVal1->data[i];
			v2 = inVal2->data[i];
			if (v1 != v2) {Gen_RetVal = MI_FALSE; break;}
		}
		if (i == c1) {Gen_RetVal = MI_TRUE;}
	}
	else /* c1 > c2 */
	{
		Gen_RetVal = MI_FALSE;
	}
	/* ------ }}Your_Code (#AEOA) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#86F3INTB) */


/* {{FUNCTION(f01aa460-0a0d-11d3-b61b-fcf719df698e) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeNewLevel
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine NewLevel (Node) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	07/02/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeNewLevel
(

mi_bitvarying *         node,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;       /* The return value wrapper.          */
	Node *          Gen_OutData;      /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal;       /* Pointer to the input value.        */
	mi_unsigned_integer c, v, i;
	mi_integer varlen;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Point to the input data value. */
	inVal = (Node *)mi_get_vardata( (mi_lvarchar *)node );

	c = inVal->count;
	v = inVal->data[1];

	/* If input node is a root node n.0, return n.1 */
	if (v == 0)
	{
		varlen = mi_get_varlen( (mi_lvarchar *)node );
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen);
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeNewLevel."
			*/
			DBDK_TRACE_ERROR( "NodeNewLevel", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = 2;
		Gen_OutData->data[0] = inVal->data[0];
		Gen_OutData->data[1] = 1;
	}
	else
	{
		varlen = mi_get_varlen( (mi_lvarchar *)node );
		Gen_RetVal = (mi_bitvarying *)mi_new_var(varlen + sizeof(mi_unsigned_integer));
		if( Gen_RetVal == 0)
		{
			/*
			** Memory allocation has failed so issue
			** the following message and quit.
			**
			** 	"Memory allocation has failed in NodeNewLevel."
			*/
			DBDK_TRACE_ERROR( "NodeNewLevel", ERRORMESG2, 10 );

			/* not reached */
		}

		/* Point to where the return value is to be placed. */
		Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

		Gen_OutData->count = c + 1;
		for (i=0; i < c ; i++)
		{
			Gen_OutData->data[i] = inVal->data[i];
		}
		Gen_OutData->data[c] = 1;
	}
	/* ------ }}Your_Code (#7FGA) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#G7142NA2) */


/* {{FUNCTION(f01aa462-0a0d-11d3-b61b-fcf719df698e) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeGraft
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Graft (Node,Node,Node) returns Node.
**
** Parameters:
**
** Return value:
**
**	Node
**
** History:
**
**	05/14/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  Only edit code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
********************************************************************************
*/
UDREXPORT mi_bitvarying * NodeGraft
(

mi_bitvarying *         node1,

mi_bitvarying *         node2,

mi_bitvarying *         node3,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;       /* The return value wrapper.          */
	Node *          Gen_OutData;      /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	Node *          inVal1;       /* Pointer to the first value.        */
	Node *          inVal2;       /* Pointer to the second value.       */
	Node *          inVal3;       /* Pointer to the third value.       */
	mi_unsigned_integer i, c, l1, l2, l3;
	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;


	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	if ( NodeIsAncestor(node1, node3, Gen_fparam) == MI_FALSE)
		mi_db_error_raise( Gen_Con, MI_SQL, "UNOD3", NULL);

	/* Point to the input data values. */
	inVal1 = (Node *)mi_get_vardata( (mi_lvarchar *)node1 );
	inVal2 = (Node *)mi_get_vardata( (mi_lvarchar *)node2 );
	inVal3 = (Node *)mi_get_vardata( (mi_lvarchar *)node3 );

	/* Get the lengths of the UDTs. */
	l1 = NodeLength(node1, Gen_fparam);
	l2 = NodeLength(node2, Gen_fparam);
	l3 = NodeLength(node3, Gen_fparam);

	/* Compute the size of the return node. */
	c = l2 + (l3 - l1);

	/* Allocate the return value. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Node ) + (c-1) * sizeof(mi_unsigned_integer) );
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeGraft."
		*/
		DBDK_TRACE_ERROR( "NodeGraft", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to where the return value is to be placed. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Set the count for the return value. */
	Gen_OutData->count = c;

	/* Set the initial data elements for the return value. */

	for (i=0; i<l2; i++)
	{
		Gen_OutData->data[i] = inVal2->data[i];
	}

	/* Set the grafted data elements for the return value. */
	for (i=l2; i<c; i++)
	{
		Gen_OutData->data[i] = inVal3->data[l1 + (i - l2)];
	}

	/* ------ }}Your_Code (#DB43) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#O3GPSRF2) */



#ifdef __cplusplus

}

#endif
