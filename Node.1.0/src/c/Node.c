/*
** Title:          Node.c
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix Software, Inc.
** Created:        04/12/1999 12:42
** Description:    This is a generated source file for the Node DataBlade module.
** Comments:       Generated for project Node.1.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Node.h"


/* {{FUNCTION(759491b1-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_sendrecv.
**
** Parameters:
**
**	mi_bitvarying *                   Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_sendrecv *                     The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeSend FunctionId: 759491b1-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_sendrecv *
NodeSend
(
mi_bitvarying *         Gen_param1,       /* The UDT value                      */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	Node *          Gen_InData;       /* Pointer to the UDT value.          */
	Node *          Gen_OutData;      /* Pointer to the packet data.        */
	mi_sendrecv *   Gen_RetVal;       /* The return value.                  */
	mi_integer      Gen_vl_nitems;    /* Number of items.                   */
	mi_integer      Gen_vl_itemno;    /* Dummy index.                       */
	mi_integer      Gen_vl_len;       /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeSend."
		*/
		DBDK_TRACE_ERROR( "NodeSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems = (Gen_vl_len - offsetof( Node, data ))
			 / sizeof( Gen_InData->data );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var(
			sizeof( Node )
		        + (Gen_vl_nitems - 1)
			  * sizeof( Gen_InData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeSend."
		*/
		DBDK_TRACE_ERROR( "NodeSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/*
	** Handle the fixed elements of the UDT.
	*/
	
	/* Prepare the value for Gen_OutData->count. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->count, (mi_integer )Gen_InData->count  );
	
	
	/*
	** Handle the variable elements of the UDT.
	*/
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno], (mi_integer )Gen_InData->data[Gen_vl_itemno]  );
	}

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* }}FUNCTION (#B0M23N2L) */




/* {{FUNCTION(759491b2-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_bitvarying.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_bitvarying *                                 The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeReceive FunctionId: 759491b2-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_bitvarying *
NodeReceive
(
mi_sendrecv *           Gen_param1,       /* The UDT value.                     */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;          /* The current connection.            */
	mi_bitvarying *                   Gen_RetVal;   /* The return value.    */
	Node *          Gen_InData;       /* Packet data.                       */
	Node *          Gen_OutData;      /* Output UDT value.                  */
	mi_integer      Gen_vl_nitems;    /* Number of data items.              */
	mi_integer      Gen_vl_itemno;    /* Index thru the items.              */
	mi_integer      Gen_vl_len;       /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeReceive."
		*/
		DBDK_TRACE_ERROR( "NodeReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len
			  - offsetof( Node, data ))
			 / sizeof( Gen_OutData->data );

	/* Allocate room for the UDT. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Node )
		      +	(Gen_vl_nitems - 1)
			* sizeof( Gen_OutData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeReceive."
		*/
		DBDK_TRACE_ERROR( "NodeReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Copy the attribute value(s) from the transmission parcel. */

	/*
	** Handle the fixed elements of the UDT.
	*/
	
	/* Prepare the value for Gen_OutData->count. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->count, (mi_integer *)&Gen_OutData->count  );
	
	
	/*
	** Handle the variable elements of the UDT.
	*/
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno], (mi_integer *)&Gen_OutData->data[Gen_vl_itemno]  );
	}

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#6DJ26L1F) */




/* {{FUNCTION(759491b7-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_bitvarying.
**
** Parameters:
**
**	mi_bitvarying *                   Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_bitvarying *                                 The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeImportBinary FunctionId: 759491b7-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_bitvarying *
NodeImportBinary
(
mi_bitvarying *         Gen_param1,       /* The input value.                   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	mi_bitvarying *                   Gen_RetVal;   /* The return result.   */
	Node *          Gen_InData;       /* The UDT input value.               */
	Node *          Gen_OutData;      /* The transfer data.                 */
	mi_integer      Gen_vl_nitems;    /* The number of items.               */
	mi_integer      Gen_vl_itemno;    /* Index thru the items.              */
	mi_integer      Gen_vl_len;       /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeImportBinary."
		*/
		DBDK_TRACE_ERROR( "NodeImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len
			  - offsetof( Node, data ))
			 / sizeof( Gen_OutData->data );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var(
			sizeof( Node )
		        + (Gen_vl_nitems - 1)
			  * sizeof( Gen_OutData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeImportBinary."
		*/
		DBDK_TRACE_ERROR( "NodeImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/*
	** Handle the fixed elements of the UDT.
	*/
	
	/* Prepare the value for Gen_OutData->count. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->count, (mi_integer *)&Gen_OutData->count  );
	
	
	/*
	** Handle the variable elements of the UDT.
	*/
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno], (mi_integer *)&Gen_OutData->data[Gen_vl_itemno]  );
	}

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* }}FUNCTION (#90N1QUKT) */




/* {{FUNCTION(759491b8-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_bitvarying.
**
** Parameters:
**
**	mi_bitvarying *                   Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_bitvarying *                                 The exported UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeExportBinary FunctionId: 759491b8-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_bitvarying *
NodeExportBinary
(
mi_bitvarying *         Gen_param1,       /* The UDT value.                     */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	mi_bitvarying * Gen_RetVal;       /* The return value.                  */
	Node *          Gen_InData;       /* The transfer data.                 */
	Node *          Gen_OutData;      /* The output data.                   */
	mi_integer      Gen_vl_nitems;    /* The number of items.               */
	mi_integer      Gen_vl_itemno;    /* Index thru the items.              */
	mi_integer      Gen_vl_len;       /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeExportBinary."
		*/
		DBDK_TRACE_ERROR( "NodeExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems = (Gen_vl_len
			  - offsetof( Node, data ))
			 / sizeof( Gen_InData->data );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var(
			sizeof( Node )
		        + (Gen_vl_nitems - 1)
			  * sizeof( Gen_InData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeExportBinary."
		*/
		DBDK_TRACE_ERROR( "NodeExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/*
	** Handle the fixed elements of the UDT.
	*/
	
	/* Prepare the value for Gen_OutData->count. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->count, (mi_integer )Gen_InData->count  );
	
	
	/*
	** Handle the variable elements of the UDT.
	*/
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno], (mi_integer )Gen_InData->data[Gen_vl_itemno]  );
	}

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#N7ULQ8KT) */




/* {{FUNCTION(759491b9-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
**	This function returns zero if the two UDT values are equal and
**	a non-zero value otherwise.
**
** Special Comments:
**
**	Compares two variable-length opaque types
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                        The comparison result.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeCompare FunctionId: 759491b9-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_integer
NodeCompare
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	Node *          Gen_Value1;       /* Pointer to the first value.        */
	Node *          Gen_Value2;       /* Pointer to the second value.       */

	/* Additional local variable declarations. */
	mi_unsigned_integer i, c1, c2, v1, v2;
	mi_integer result;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeCompare."
		*/
		DBDK_TRACE_ERROR( "NodeCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the data values that are to be compared. */
	Gen_Value1 = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );
	Gen_Value2 = (Node *)mi_get_vardata( (mi_lvarchar *)Gen_param2 );

	/* Get the lengths of the two UDTs. */
	c1 = Gen_Value1->count;
	c2 = Gen_Value2->count;

	if (c1 == c2)
	{
		for (i=0; i < c1; i++)
		{
			v1 = Gen_Value1->data[i];
			v2 = Gen_Value2->data[i];
			if (v1 < v2) {result = -1; break;}
			if (v1 > v2) {result = 1; break;}
		}
		if (i == c1) {result = 0;}
	}
	else if (c1 < c2)
	{
		for (i=0; i < c1; i++)
		{
			v1 = Gen_Value1->data[i];
			v2 = Gen_Value2->data[i];
			if (v1 < v2) {result = -1; break;}
			if (v1 > v2) {result = 1; break;}
		}
		if (i == c1) {result = -1;}
	}
	else /* c1 > c2 */
	{
		for (i=0; i < c2; i++)
		{
			v1 = Gen_Value1->data[i];
			v2 = Gen_Value2->data[i];
			if (v1 < v2) {result = -1; break;}
			if (v1 > v2) {result = 1; break;}
		}
		if (i == c2) {result = 1;}
	}

	/* Close the connection. */
	mi_close( Gen_Con );

	return result;
}
/* }}FUNCTION (#E86HVL0R) */




/* {{FUNCTION(759491ba-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Compares two variable-length opaque types for equality
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeEqual FunctionId: 759491ba-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeEqual
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == NodeCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#NDRP8FJJ) */




/* {{FUNCTION(759491bb-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Compares two variable-length opaque types for non-equality
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/12/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeNotEqual FunctionId: 759491bb-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeNotEqual
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != NodeCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#ISSNE73S) */







/* {{FUNCTION(759491b3-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type Node to its internal representation.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_lvarchar.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                     The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeInput FunctionId: 759491b3-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_lvarchar *
NodeInput
(
mi_lvarchar *           Gen_param1,                     /* Pointer to the input text.             */
MI_FPARAM *             Gen_fparam                      /* Standard info - see DBDK docs.         */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	Node *          Gen_OutData;                    /* Pointer to the output data.            */
	mi_integer      Gen_UDTSize;                    /* Size of the UDT in bytes.              */
	mi_integer      Gen_vl_nitems;                  /* Number of variable length items.       */
	mi_lvarchar *   Gen_RetVal;                     /* The return value.                      */

	mi_unsigned_integer	pArr[512];
	char * inStr, * pCh, * pStart;
	int i=0;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeInput."
		*/
		DBDK_TRACE_ERROR( "NodeInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Convert input to null-terminated string. */
	inStr = mi_lvarchar_to_string(Gen_param1);
	pCh = inStr;

	/* Step over spaces at beginning of input string. */
	while (*pCh == ' ') pCh++;

	/* Set start pointer to current character position. */
	pStart = pCh;

	/* Step through the input string loading array with integers. */
	while (*pCh)
	{
		switch (*pCh)
		{
		case '0' :
		case '1' :
		case '2' :
		case '3' :
		case '4' :
		case '5' :
		case '6' :
		case '7' :
		case '8' :
		case '9' :
			break;

		case '.':
			*pCh = '\0';

			/* Check for zero length string before doing 'atoi' */
			if ((strlen(pStart) == 0))
				mi_db_error_raise(Gen_Con,MI_SQL,"UNOD1",NULL);
			
			pArr[i] = atoi(pStart);

			/* Only allow a trailing zero for root nodes */
			if ((pArr[i] == 0))
				mi_db_error_raise(Gen_Con,MI_SQL,"UNOD1",NULL);
			
			i++;
			pStart = pCh +1;
			break;

		default:
			mi_db_error_raise(Gen_Con,MI_SQL,"UNOD2",NULL);
			break;
		}
		pCh++;
	}

	/* Check for zero length string before doing 'atoi' */
	if ((strlen(pStart) == 0))
		mi_db_error_raise(Gen_Con,MI_SQL,"UNOD1",NULL);

	pArr[i] = atoi(pStart);

	/* Only allow a trailing zero for root nodes */
	if ((pArr[i] == 0) && (i != 1))
		mi_db_error_raise(Gen_Con,MI_SQL,"UNOD1",NULL);

	/* Handle the case where the input string contains a single integer. */
	if (i==0)
	{
		i++;
		pArr[i]=0;
	}

	/* Set Gen_vl_nitems to the number of integers in pArr. */
	Gen_vl_nitems = i + 1;

	/*
	/* Set the size of the opaque type into Gen_UDTSize.
	/* It must hold the Node structure plus the integers
	/* extracted from the input string.
	*/
	Gen_UDTSize = sizeof(Node) + (Gen_vl_nitems - 1) * sizeof(mi_unsigned_integer);

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = mi_new_var( Gen_UDTSize );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeInput."
		*/
		DBDK_TRACE_ERROR( "NodeInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (Node *)mi_get_vardata( Gen_RetVal );

	/*
	** Handle the fixed elements of the UDT.
	*/
	
	/* Get the mi_unsigned_int value for count. */
	Gen_OutData->count = Gen_vl_nitems;	
	
	/*
	** Handle the variable elements of the UDT.
	*/
	for (i=0; i < Gen_vl_nitems; i++)
	{
		Gen_OutData->data[i] = pArr[i];
	}

	/* Free the null-terminated input string. */
	mi_free( inStr );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#N8DB8FKU) */




/* {{FUNCTION(759491b4-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type Node to its external representation.
**
**	Data can be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_lvarchar.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                     The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeOutput FunctionId: 759491b4-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_lvarchar *
NodeOutput
(
mi_lvarchar *           Gen_param1,                     /* The UDT value.                         */
MI_FPARAM *             Gen_fparam                      /* Standard info - see DBDK docs.         */
)
{
	MI_CONNECTION * Gen_Con;                        /* The current connection.                */
	mi_integer      Gen_CharLen;                    /* Estimate maximum length.               */
	Node *          Gen_InData;                     /* Pointer to the input data.             */
	char *          Gen_OutData;                    /* Pointer to the output data.            */
	mi_lvarchar *   Gen_RetVal;                     /* The return result.                     */
	mi_integer      Gen_DataLen;                    /* The data length.                       */
	mi_integer      Gen_vl_nitems;                  /* The number of items.                   */
	mi_integer      Gen_vl_itemno;                  /* Index thru the items.                  */
	mi_integer      Gen_vl_len;                     /* The length.                            */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in NodeOutput."
		*/
		DBDK_TRACE_ERROR( "NodeOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Node *)mi_get_vardata( Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems = Gen_InData->count;

	/* Compute the maximum length of the text representation. */
	Gen_CharLen         =   1              /* Leave room for the NULL terminator. */
	               + 12             /* Add the length for count. */
	               +                  Gen_vl_nitems * 12                         /* Add the length for data. */
		            ;

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in NodeOutput."
		*/
		DBDK_TRACE_ERROR( "NodeOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/*
	** Handle the variable elements of the UDT.
	*/
	sprintf( Gen_OutData, "%u", Gen_InData->data[0] );
	Gen_OutData += strlen( Gen_OutData );

	for( Gen_vl_itemno = 1; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		sprintf( Gen_OutData, ".%u", Gen_InData->data[Gen_vl_itemno] );
		Gen_OutData += strlen( Gen_OutData );
	}

	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#9DTVHDOP) */

/* {{FUNCTION(759491b5-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_bitvarying.
**
** Parameters:
**
**	mi_impexp *     Gen_param1;       Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_bitvarying *                                 The constructed UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeImportText FunctionId: 759491b5-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_bitvarying *
NodeImportText
(
mi_impexp *             Gen_param1,                     /* The import text.                       */
MI_FPARAM *             Gen_fparam                      /* Standard info - see DBDK docs.         */
)
{
	mi_bitvarying *                   Gen_RetVal;                           /* The return value.                 */

	Gen_RetVal = (mi_bitvarying *)NodeInput((mi_lvarchar *)Gen_param1, Gen_fparam);

	return Gen_RetVal;
}
/* }}FUNCTION (#7VD3ISQP) */




/* {{FUNCTION(759491b6-f0ed-11d2-b5f0-f1283acf36d6) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type Node returns mi_impexp.
**
** Parameters:
**
**	mi_bitvarying *                   Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_impexp *                       The exported UDT value.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeExportText FunctionId: 759491b6-f0ed-11d2-b5f0-f1283acf36d6
**
********************************************************************************
*/

UDREXPORT
mi_impexp *
NodeExportText
(
mi_bitvarying *         Gen_param1,       /* The UDT value.                     */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	mi_impexp *     Gen_RetVal;       /* The return result.                 */

	Gen_RetVal = (mi_impexp *)NodeOutput((mi_lvarchar *)Gen_param1, Gen_fparam);

	return Gen_RetVal;
}
/* }}FUNCTION (#RSCCJSQP) */


/* {{FUNCTION(19359135-f8f5-11d2-b600-c548d9897adc) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeLessThan
**
** Description:
**
**	Determine if one UDT value is less than another.
**
** Special Comments:
**
**	Compares two variable-length opaque types
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeLessThan FunctionId: 19359135-f8f5-11d2-b600-c548d9897adc
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeLessThan
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 == NodeCompare(
				Gen_param1, Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#RPQSV73B) */


/* {{FUNCTION(19359137-f8f5-11d2-b600-c548d9897adc) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeLessThanOrEqual
**
** Description:
**
**	Determine if one UDT value is less than or equal to another.
**
** Special Comments:
**
**	Compares two variable-length opaque types
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeLessThanOrEqual FunctionId: 19359137-f8f5-11d2-b600-c548d9897adc
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeLessThanOrEqual
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 > NodeCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#L16QHIGR) */


/* {{FUNCTION(19359136-f8f5-11d2-b600-c548d9897adc) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeGreaterThan
**
** Description:
**
**	Determine if one UDT value is greater than another.
**
** Special Comments:
**
**	Compares two variable-length opaque types
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeGreaterThan FunctionId: 19359136-f8f5-11d2-b600-c548d9897adc
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeGreaterThan
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 == NodeCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* }}FUNCTION (#BTO8EJ19) */


/* {{FUNCTION(19359138-f8f5-11d2-b600-c548d9897adc) (MergeSection) */

/*******************************************************************************
**
** Function name:
**
**	NodeGreaterThanOrEqual
**
** Description:
**
**	Determine if one UDT value is greater than or equal to another.
**
** Special Comments:
**
**	Compares two variable-length opaque types
**
** Parameters:
**
**	mi_bitvarying * Gen_param1;       The first UDT value to compare.
**	mi_bitvarying * Gen_param2;       The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;       Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                        The comparison result.
**
** History:
**
**	04/22/1999 - Generated by BladeSmith Version 3.70.TC1.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    NodeGreaterThanOrEqual FunctionId: 19359138-f8f5-11d2-b600-c548d9897adc
**
********************************************************************************
*/

UDREXPORT
mi_boolean
NodeGreaterThanOrEqual
(
mi_bitvarying *         Gen_param1,       /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,       /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 < NodeCompare( Gen_param1,
			Gen_param2, Gen_fparam ) );
}
/* }}FUNCTION (#VDGHAAAA) */



#ifdef __cplusplus

}

#endif
