/*
** Title:          vti_demo
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         Informix
** Created:        08/21/1998 09:00
** Description:    This is the generated 'C' file for the vti_demo DataBlade.
** Comments:       Generated for project vti_demo.2.0
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "vti_demo.h"

/* ***************************************************************************
** For vti. Note that since we're outside the "Your_Code" blocks, BladeSmith
** won't preserve these additional #include directives. If you regenerate
** code, you'll have to add them again manually. 
** ***************************************************************************
*/
#include <miami.h>
#include <minmdur.h>

/* to support the FIFO stuff */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <stdlib.h>

#define SERVER_FIFO "/tmp/idn_ext_fifo.tmp"

/*
** global function prototypes
*/
mi_integer demo_get_rowlength( MI_AM_TABLE_DESC * );
mi_real  scancost_table_support( mi_real, MI_AM_QUAL_DESC * );
mi_integer demo_read_buffer( mi_integer, mi_string *, mi_integer );
mi_integer demo_parse_qd( MI_AM_QUAL_DESC *, MI_ROW_DESC *, char * );
mi_integer demo_get_constval( MI_AM_QUAL_DESC *, MI_ROW_DESC *, mi_char * );

/* {{FUNCTION(120cce7b-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_open
**
** Description:
**
**	Open the external data server's FIFO file, if not already open, and
**	allocate a user data structure. Create and open the client's FIFO,
**	if that isn't already open.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_open (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_open
(

mi_pointer *            td,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_integer	i;              /* counter                         */
	demo_data_t	*demo_data;     /* user_data structure             */
	mi_char		*dirname;       /* location for a table            */
	MI_ROW_DESC	*rd;            /* row descriptor                  */
	MI_TYPE_DESC	*typedesc;      /* type descriptor                 */
	mi_char		*typename;      /* type name                       */
	mi_string	name[BUFSIZ];   /* temp buffer for building names  */
        mi_string       errbuf[80];     /* for mi_db_error_raise()         */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	  ("================= Entering demo_am_open() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	
	/* *******************************************************************
	** Allocate the demo_data structure.
	** *******************************************************************
	*/
	demo_data = (demo_data_t *) mi_dalloc(sizeof(demo_data_t),
	               PER_STATEMENT);
	if (! demo_data)
	{
	  mi_db_error_raise(NULL, MI_EXCEPTION, 
            "am_open failed at mi_dalloc()");
	  /* not reached */
	}

	/* Open the external data manager's FIFO */
	demo_data->ext_fd = open(SERVER_FIFO, O_RDWR, 0666);
	if (demo_data->ext_fd < 0)
        {
          sprintf(errbuf, 
             "Unable to open server FIFO in am_open, errno is %d", errno);
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
	}

	/* Create and open the client FIFO */
        strcpy(name, tempnam("/tmp", "vtiFF"));

        if (mkfifo(name, (mode_t) 0666) < 0)
        {
	  /* ok, give up. */
          sprintf(errbuf, "Unable to create FIFO for the udr: %s\n",
                          name);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
          return -1;
        }

        demo_data->fifo_path = (char *)mi_dalloc(strlen(name) + 1,
            PER_STATEMENT);
        strcpy(demo_data->fifo_path, name);

        demo_data->fifo_fd = open(demo_data->fifo_path, O_RDWR, 0666);
        if (demo_data->fifo_fd < 0)
        {
          sprintf(errbuf, "Unable to open FIFO for udr: %s\n",
                          demo_data->fifo_path);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
          return -1;
        }
        
	demo_data->data = NULL;

	/* Get the column information */
	rd = mi_tab_rowdesc((MI_AM_TABLE_DESC *)td);
	demo_data->ncols = mi_column_count(rd);

	for (i = 0; i < demo_data->ncols; i++)
	{
	  if (! (typedesc = mi_column_typedesc(rd, i)))
	  {
		Gen_RetVal = MI_ERROR;
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		"am_open failed at mi_column_typedesc()");
		/* not reached */
		return Gen_RetVal;
	  }

	  if (! (typename = mi_type_typename(typedesc)))
	  {
		Gen_RetVal = MI_ERROR;
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		"am_open failed at mi_column_typename()");
		/* not reached */
		return Gen_RetVal;
	  }
	
          /* The demo only supports integer and character types */
	  if (! strncmp(typename, "integer", (size_t)7))
	  {
                demo_data->col_type[i] = DEMO_INT;
	  }
	  else if (! strncmp(typename, "char", (size_t)4))
	  {
		demo_data->col_type[i] = DEMO_CHAR;
	  }
	  else
	  {
		Gen_RetVal = MI_ERROR;
		mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		"Column type is neither DEMO_INT nor DEMO_CHAR");
		/* not reached */
		return Gen_RetVal;
	  }
	}

	/* *******************************************************************
	** Get the pathname for the file containing the table 
	**
	** IMPORTANT: 
	**
	** In this example we're using the mi_tab_spaceloc() value as
	** part of our path. However, this value COULD contain spaces
	** and other illegal pathname characters -- it's just the value
	** that was used when the space was created using "onspaces",
	** and that could be any text string. E.g., 
	**
	**     onspaces -c -x -dc1 -l "3rd shelf from the left"
	**
	** In the demo, we only use legal filename characters in our
	** extspace name, so this strategy works.
	** *******************************************************************
	*/
	dirname = mi_tab_spaceloc((MI_AM_TABLE_DESC *)td);
	if (!dirname || !*dirname)
	{
		dirname = "/tmp";
	}
	sprintf(name, "%s/%s-%d", dirname, mi_tab_name((MI_AM_TABLE_DESC *)td), 
		mi_tab_partnum((MI_AM_TABLE_DESC *)td));
	demo_data->tab_path = (char *)mi_dalloc(strlen(name) + 1, 
          PER_STATEMENT);
	strcpy(demo_data->tab_path, name);

	demo_data->data = NULL;
	mi_tab_setuserdata((MI_AM_TABLE_DESC *)td, demo_data);

	DPRINTF("vti_demo", 20, 
	  ("================= Leaving demo_am_open() ==================="));

	Gen_RetVal = MI_OK;

	/* ------ }}Your_Code (#9RIG) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#1D6S) */




/* {{FUNCTION(120cce79-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_scancost
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_scancost (pointer,pointer) 
**	returns real.
**
**	Estimates the cost of a function call based on the number of 
**	qualifications. This is completely inadequate for a "real"
**	application, but it does give the optimizer *something* to
**	work with.
**
** Parameters:
**
** Return value:
**
**	mi_real
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/
UDREXPORT mi_real *demo_am_scancost
(

mi_pointer *            td,
mi_pointer *            qd,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
	mi_real*        Gen_RetVal;       /* The return value. */
	MI_CONNECTION * Gen_Con;          /* The connection handle. */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_real         *cost;

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_scancost() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	cost = (mi_real *)mi_dalloc(sizeof(mi_real), PER_STATEMENT);
 
	*cost = 1.0;
 
	*cost = scancost_table_support(*cost, (MI_AM_QUAL_DESC *)qd) * 100;
	Gen_RetVal = cost;

	/* ------ }}Your_Code (#JL3H) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_scancost() ==================="));

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#AIK5) */




/* {{FUNCTION(120cce74-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_endscan
**
** Description:
**
**	For the demo, close and remove the fifo that was used to collect
**	qualifying rows and unlink it.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_endscan (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_endscan
(

mi_pointer *            sd,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */
	fifo_t          *fifo_str;        /* fifo for returned rows  */

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */
	
	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_endscan() ==================="));

	fifo_str = mi_scan_userdata((MI_AM_SCAN_DESC *)sd);

	close(fifo_str->fifo_fd);
	unlink(fifo_str->fifo_path);

	Gen_RetVal = 0;

	/* ------ }}Your_Code (#NI6T) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_endscan() ==================="));

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#B3D8) */




/* {{FUNCTION(120cce7a-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_create
**
** Description:
**
**	Implements the am_create purpose function.
**
**	For the demo, this function will:
**
**	  o Verify that the request only includes legal column types 
**	    (integer and fixed-length character strings)
**
**	  o Get the filename for the external file that will hold the
**	    table. The table name and storage number are in the table
**	    descriptor; these are combined to form a filename.
**
**	  o Get the file location. If "in <extspacename>" was included in
**	    the SQL "CREATE TABLE" statement, then that name is used. If
**	    not, we'll check the environment variable $VTIDEMODIR and use
**	    that value. If $VTIDEMODIR is not set, we'll use /tmp.
**
**	  o Send this information, along with a "create table" directive,
**	    to the external data manager, using its "well-known" FIFO
**          file. Note that am_create is unusual in that it gets called
**	    before am_open (see the Control Flow section of the VTI
**	    Programmer's Manual). Because of this, it needs to create
**	    its own FIFO for the external data manager to send to, and
**	    it needs to delete (unlink) it when done. (Most of the
**	    VTI Purpose Functions will use a FIFO that's created by the 
**	    am_open routine and deleted by am_close.)
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_create (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_create
(

mi_pointer *            td,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	MI_ROW_DESC	*rd;          /* row descriptor, init'd by server */
	mi_integer	ncol;         /* number of columns in a row       */
	mi_integer      rowlen;       /* length of the row                */
	mi_string       *dirname;     /* directory location of file       */
	mi_char		pathname[100];/* path to file holding table data  */
        mi_integer      c_secs;       /* unique identifier part of fifo name */
        mi_string       c_fifo[BUFSIZ];  /* client fifo pathname             */
	mi_integer      c_fd;            /* client fifo file handle          */
	mi_integer      s_fd;            /* server fifo file handle          */
	mi_char		sendbuf[BUFSIZ]; /* buffer for passing to ext server */
	mi_char		retbuf[BUFSIZ];  /* buffer for receiving response    */
        mi_integer      slen;            /* send buffer length               */
        mi_integer      n;               /* number of bytes read             */
        mi_string       errbuf[80];      /* buffer for error messages        */
        mi_integer      retries;         /* retry counter for reads          */

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_create() ==================="));

	rd   = mi_tab_rowdesc((MI_AM_TABLE_DESC *)td);
	ncol = mi_column_count(rd);

	/* Our demo is hard-coded to a maximum of 10 columns */
	if (ncol > 10)
	{
	    Gen_RetVal = MI_ERROR;
            sprintf(errbuf, 
                   "Error: Too many columns specified (%d). Max = 10", ncol);
	    mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	    /* not reached */
	    return Gen_RetVal;
	}

	rowlen = demo_get_rowlength((MI_AM_TABLE_DESC *)td);

        /* ...and there's a hard-coded limit of 500 characters per row */
	if ((rowlen > 500) || (rowlen < 0))
	{
	  Gen_RetVal = MI_ERROR;
            sprintf(errbuf, 
                   "Error: Row is too long: %d. Max = 500", rowlen);
	    mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	    /* not reached */
	    return Gen_RetVal;
	}

	/* *****************************************************************
	** Get the pathname for the file containing the table 
	**
	** IMPORTANT: 
	**
	** In this example we're using the mi_tab_spaceloc() value as
	** part of our path. However, this value COULD contain spaces
	** and other illegal pathname characters -- it's just the value
	** that was used when the space was created using "onspaces",
	** and that could be any text string. E.g., 
	**
	**     onspaces -c -x -dc1 -l "3rd shelf from the left"
	**
	** In the demo, we only use legal filename characters in our
	** extspace name.
	** 
	** *****************************************************************
	** If there's no extspace name, and if $VTIDEMODIR is undefined, 
	** we'll use /tmp 
	** *****************************************************************
	*/
	dirname = mi_tab_spaceloc((MI_AM_TABLE_DESC *)td);
	if (!dirname || !*dirname)
	{
		if ((dirname = (mi_string *)getenv("VTIDEMODIR")) == NULL)
		{
			dirname = (mi_string *)mi_alloc(5);
			strcpy(dirname, "/tmp");
		}
	}
	sprintf(pathname, "%s/%s-%d", dirname, 
		mi_tab_name((MI_AM_TABLE_DESC *)td), 
		mi_tab_partnum((MI_AM_TABLE_DESC *)td));

        /* ******************************************************************
        ** Send the pathname for the new file (table) to the external data
        ** server.
        **
        ** First, build the client FIFO name, create it, open it.
        ** ******************************************************************
        */
        c_secs = time((time_t)0); /* unique identifier for fifo name */
 
        sprintf(c_fifo, "/tmp/idn_client-%d.tmp", c_secs);
 
        if (mkfifo(c_fifo, (mode_t) 0666) < 0)
        {
          sprintf(errbuf, "Unable to create client FIFO.");
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
        }
 
        c_fd = open(c_fifo, O_RDWR, 0666);
        if (c_fd < 0)
        {
          sprintf(errbuf, "Unable to open client FIFO.");
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
        }
 
        /* ******************************************************************
        ** Next, open the server's FIFO.
        ** ******************************************************************
        */
        s_fd = open(SERVER_FIFO, O_RDWR, 0666);
        if (s_fd < 0)
        {
          sprintf(errbuf, "Unable to open server FIFO.");
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
        }
        
	/* ******************************************************************
	** Build the "Create Table" transaction and send it
	** to the external data manager.
	** ******************************************************************
	*/
	/* 01 == CREATE_TABLE */
	sprintf(sendbuf, "%s 01 %s", c_fifo, pathname);

	slen = strlen(sendbuf) + 1;
	n = write(s_fd, sendbuf, slen);
	if (n != slen)
	{
	  sprintf(errbuf, "Error when sending CREATE TABLE transaction.");
	  mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	  /* not reached */
	}

	/* And read the response */
	n = retries = 0;
	while ((n == 0) && (retries < 10)) /* pick a rational number */
	{
	    retries ++;
	    /* Give the external server a moment to respond */
	    mi_yield();

	    n = demo_read_buffer(c_fd, retbuf, 0);
	    retbuf[n] = '\0';
        }

        if (n == 0)
        {
          sprintf(errbuf,
                 "Unable to receive a response from the data manager.");
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
        }

        if (strcmp(retbuf, "ERROR") == 0)
        {
          sprintf(errbuf,
                 "External data manager reports error creating table.");
          mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
          /* not reached */
        }
	/* *******************************************************************
	** That's all there is to this transaction. Close the client
	** FIFO and remove it.
	** *******************************************************************
	*/

	close(c_fd);
	unlink(c_fifo);

	Gen_RetVal = 0;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_create() ==================="));

	/* ------ }}Your_Code (#305C) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#CEEU) */




/* {{FUNCTION(120cce77-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_stats
**
** Description:
**
**	Implements the am_stats purpose function.
**
**	Ask the external data server for a count of the number of rows in
**	the table. Use that information to update the table statistics.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_stats (pointer,pointer) returns
**	int.
**
**	NOTE: According to the VTI Programmer's Manual, the am_stats
**	purpose function is unique in that it gets called by itself, without
**	am_open having first been called, and without subsequently calling
**	am_close. It therefore has to take care of all the overhead of
**	opening and closing the FIFOs used to communicate with the external
**	data manager.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_stats
(

mi_pointer *            td,               /* table descriptor */
mi_pointer *            sd,               /* stats descriptor */
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_integer        rowlen;             /* length of a row             */
	mi_integer        count = 0;          /* count of rows in table      */
	demo_data_t       *demo_data;         /* td's user data              */
	mi_string         sendbuf[BUFSIZ];    /* buffer to send to ext mgr   */
	mi_string         retbuf[BUFSIZ];     /* buffer to receive from ext  */
	mi_integer        buflen;             /* length of the buffer        */
	mi_integer        n;                  /* bytes read/written          */
	mi_string         errbuf[100];        /* place to put error message  */
	mi_integer        retries;            /* read retries                */
        mi_integer      c_secs;       /* unique identifier part of fifo name */
	mi_string	name[BUFSIZ];    /* temp buffer for building names   */
	mi_string       *dirname;     /* directory location of file       */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_stats() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Get the userdata, and initialize it */
	demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);
	if (!demo_data->data) /* first one, so initialize data space */
        {
          if ((demo_data->data = (MI_DATUM *)mi_dalloc(sizeof(MI_DATUM),
	       PER_STATEMENT)) == NULL)
          {
            mi_db_error_raise(Gen_Con, MI_EXCEPTION,
              "Error: Unable to allocate data space in am_stats.");
            /* not reached */
            return MI_ERROR;
          }
        }
 
        /* Open the external data server's FIFO, if not already done */
        if (demo_data->ext_fd == 0)
        {
          demo_data->ext_fd = open(SERVER_FIFO, O_RDWR, 0666);
          if (demo_data->ext_fd < 0)
          {
            sprintf(errbuf,
               "Unable to open server FIFO in am_stats, errno is %d", errno);
            mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
            /* not reached */
          }
        }
 
        /* Create and open the client FIFO */
        c_secs = time((time_t)0);
        sprintf(name, "/tmp/vtidemo_udr-%d-%d", c_secs, rand_r(&c_secs));
 
        if (mkfifo(name, (mode_t) 0666) < 0)
        {
          /* try again - sometimes rand_r() gives me a dup */
          c_secs--;
          sprintf(name, "/tmp/vtidemo_udr-%d-%d", c_secs, rand_r(&c_secs));
          if (mkfifo(name, (mode_t) 0666) < 0)
          {
            /* ok, give up. */
            sprintf(errbuf, "Unable to create FIFO for udr: %s\n", name);
            mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
            /* not reached */
  	    return -1;
	  }
	}

        demo_data->fifo_path = (char *)mi_dalloc(strlen(name) + 1,
                               PER_STATEMENT);
        strcpy(demo_data->fifo_path, name);
 
        demo_data->fifo_fd = open(demo_data->fifo_path, O_RDWR, 0666);
        if (demo_data->fifo_fd < 0)
        {
          sprintf(errbuf, "Unable to open client FIFO: %s\n",
                          demo_data->fifo_path);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
          return -1;
        }

        /* *******************************************************************
        ** Get the pathname for the file containing the table
        ** *******************************************************************
	*/
        dirname = mi_tab_spaceloc((MI_AM_TABLE_DESC *)td);
        if (!dirname || !*dirname)
        {
                dirname = "/tmp";
        }
        sprintf(name, "%s/%s-%d", dirname, mi_tab_name((MI_AM_TABLE_DESC *)td),
                mi_tab_partnum((MI_AM_TABLE_DESC *)td));
        demo_data->tab_path = (char *)mi_dalloc(strlen(name) + 1,
          PER_STATEMENT);
        strcpy(demo_data->tab_path, name);
 
        demo_data->data = NULL;
        mi_tab_setuserdata((MI_AM_TABLE_DESC *)td, demo_data);

	/* Get the row length for this table */
	rowlen = demo_get_rowlength((MI_AM_TABLE_DESC *)td);

	/* *******************************************************************
	** Send the pathname and the row length to the external program,
	** and get back the number of rows ("count").
	** *******************************************************************
	*/
	sprintf(sendbuf, "%s 09 %d %s", demo_data->fifo_path, rowlen,
	        demo_data->tab_path);

	buflen = strlen(sendbuf) + 1;

	n = write(demo_data->ext_fd, sendbuf, buflen);
	if (n != buflen)
	{
	    sprintf(errbuf,
	            "demo_am_getstat: tried to send %d bytes, sent %d\n",
	            buflen, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* *******************************************************************
	** Read back the response (number of rows in the table)
	** *******************************************************************
	*/
	n = retries = 0;
	while ((n <= 0) && (retries < 10)) /* try 10 times */
	{
	  retries++;
	  /* take a breath */
	  mi_yield();
	  n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	  strcpy(errbuf,
                 "demo_am_getstat: External data server reports ERROR.");
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  unlink(demo_data->fifo_path);
	  mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	  /* not reached */
	}

	/* *******************************************************************
	** Use that count to set the system stats
	** *******************************************************************
	*/
	sscanf(retbuf, "%d", &count);
	mi_tstats_setnrows((MI_AM_TSTATS_DESC *)sd, count);
	mi_tstats_setnpages((MI_AM_TSTATS_DESC *)sd, (count * rowlen) + 1);
	
	close(demo_data->ext_fd);
	close(demo_data->fifo_fd);
	unlink(demo_data->fifo_path);

	Gen_RetVal = MI_OK;

	/* ------ }}Your_Code (#QV17) END ------ */


	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_stats() ==================="));

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#L7NL) */




/* {{FUNCTION(120cce73-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_getbyid
**
** Description:
**
**	Implements the am_getbyid purpose function.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_getbyid (pointer,pointer,pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_getbyid
(
mi_pointer *            td,
mi_pointer *            retrow,
mi_pointer *            rowid,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	demo_data_t	*demo_data;       /* td's user data                 */
	mi_integer	rowlen;           /* length of a row                */
	MI_ROW_DESC     *rd;              /* row descriptor                 */
	mi_char         sendbuf[BUFSIZ];  /* buffer to send                 */
	mi_char         retbuf[50];       /* buffer to receive              */
	mi_char         *rowptr;          /* pointer to returned row        */
        mi_integer      n;                /* count of bytes sent/received   */
	mi_char         errbuf[100];      /* place to put error messages    */
	mi_integer      retries;          /* read retry counter             */
	mi_integer      i;                /* loop counter                   */
	mi_integer      bound;            /* describes width of column      */
	mi_string       itembuf[510];     /* temp storage for char data     */
	
	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_getbyid() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	rd   = mi_tab_rowdesc((MI_AM_TABLE_DESC *)td);

	/* Get the row length */
	rowlen = demo_get_rowlength((MI_AM_TABLE_DESC *)td);

	/* Get the userdata */
	demo_data = mi_tab_userdata((MI_AM_TABLE_DESC *)td);

	/* *******************************************************************
	** Send the table's pathname, the row length, the id of the desired 
	** row, and the table's filename to the external program.
	** *******************************************************************
	*/
	sprintf(sendbuf, "%s 05 %d %d %s ", demo_data->fifo_path, rowlen,
                *rowid, demo_data->tab_path);

	n = write(demo_data->ext_fd, sendbuf, strlen(sendbuf) + 1);
	if (n != strlen(sendbuf) + 1)
	{
	    sprintf(errbuf, "Error: Tried to send %d bytes, but only sent %d",
	            strlen(sendbuf) + 1 + rowlen, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* Give the external data server a moment */
	mi_yield();

	/* *******************************************************************
	** And read the response. The response will be either (1) the row,
	** (2) "OK", meaning there was no error, but the row isn't there,
	** or (3) "ERROR".
	** *******************************************************************
	*/
	n = retries = 0;
	while ((n ==0) && (retries < 10)) /* try 10 times */
	{
	    retries++;
	    mi_yield();
	    n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	    retbuf[n] = '\0';
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	    Gen_RetVal = MI_ERROR;
	}
	else if (strcmp(retbuf, "OK") == 0)
	{
	    Gen_RetVal = MI_NO_MORE_RESULTS;
	}
	else
	{
	    /* Build a row */
	    rowptr = retbuf;
	    rowptr++;  /* skip past the "not deleted" flag */

	    /* ****************************************************************
	    ** pick up each column of the row
	    ** ****************************************************************
	    */
	    for (i = 0; i < demo_data->ncols; i++)
	    {
	      /* set the null indicator flag */
	      if (rowptr[0] == '\1')
	      {
	        demo_data->is_null[i] = MI_FALSE;
	      } 
	      else
	      {
	        demo_data->is_null[i] = MI_TRUE;
	      }
	      rowptr++;

	      /* get the column value */
	      switch(demo_data->col_type[i])
	      {
	        case DEMO_INT:   bound = 4;
	                         bycopy(rowptr, (void *)&demo_data->data[i],
	                                bound);
	                         break;
	        case DEMO_CHAR:  bound = mi_column_precision(rd, i);
	                         bycopy(rowptr, itembuf, bound);
	                         /* IDS wants strings in an mi_lvarchar */
	                         demo_data->data[i] =
	                           (MI_DATUM)mi_string_to_lvarchar(itembuf);
	                         if (! demo_data->data[i])
	                         {
	                           mi_db_error_raise(Gen_Con, MI_EXCEPTION,
	                            "Error building row to return");
	                           /* not reached */
	                          }
	                          break;
	        default:          mi_db_error_raise(Gen_Con, MI_EXCEPTION,
	                           "Error: Unknown column type.");
	                          /* not reached */
	                          break;
	      }
	  
	      rowptr += bound;
	    }

	    *retrow = mi_row_create(Gen_Con, rd, demo_data->data,
	                            demo_data->is_null);

	    mi_tab_setuserdata((MI_AM_TABLE_DESC *)td, (void *)demo_data);

	    Gen_RetVal = MI_ROWS;
	}
	
	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_getbyid() ==================="));

	/* ------ }}Your_Code (#AG6T) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#8UCH) */




/* {{FUNCTION(120cce76-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_drop
**
** Description:
**
**	Implements the am_drop purpose function. Since, according to the
**	VTI Programmer's Manual, this routine isn't followed by an am_colse,
**	we'll need to close the server and client fd's and unlink the latter.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_drop (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_drop
(

mi_pointer *            td,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	demo_data_t	*demo_data;        /* user_data                     */
        mi_string       sendbuf[BUFSIZ];   /* buffer to send to ext server  */
        mi_string       retbuf[BUFSIZ];    /* buffer to receive             */
        mi_integer      buflen;            /* buffer length                 */
        mi_string       errbuf[80];        /* for mi_db_error_raise         */
        mi_integer      n;                 /* number of bytes sent/received */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_drop() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	demo_data = mi_tab_userdata((MI_AM_TABLE_DESC *)td);
	
        /* Send the "drop" request. "02" is for "drop table"                */
        sprintf(sendbuf, "%s 02 %s", demo_data->fifo_path, 
                demo_data->tab_path); 
        
        buflen = strlen(sendbuf) + 1;
        n = write(demo_data->ext_fd, sendbuf, buflen);
        if (n != buflen)
        {
            sprintf(errbuf, 
               "Tried to send %d bytes to external server. Sent %d\n",
                buflen, n);
	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    unlink(demo_data->fifo_path);
            mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
            /* not reached */
            return -1;
        }

        /* Read the external server's response */
        n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
        if (n < 0)
        {
          sprintf(errbuf, 
                  "Unable to read response from external data server\n");
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  unlink(demo_data->fifo_path);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
          return -1;
        }

        if (strcmp(retbuf, "ERROR") == 0)
        {
          sprintf(errbuf, 
            "External data server reports ERROR when deleting table.");
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  unlink(demo_data->fifo_path);
          mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
          /* not reached */
          return -1;
        }

	close(demo_data->ext_fd);
	close(demo_data->fifo_fd);
	unlink(demo_data->fifo_path);

	Gen_RetVal = MI_OK;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_drop() ==================="));

	/* ------ }}Your_Code (#GRIG) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#HD6E) */




/* {{FUNCTION(120cce7d-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_update
**
** Description:
**
**	Implement the am_update purpose function. Get the new row values
**	from the "newrow" row descriptor, build a flat row structure, and
**	pass it off to the external data manager. The external data manager
**	will seek to the corresponding row in the data store and rewrite 
**	that record with the new data.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_update (pointer,pointer,int) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_update
(
mi_pointer *            td,
mi_pointer *            newrow,
mi_integer *            rowid,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_char		rowbuf[500];
	mi_char		*charptr;
	mi_integer	intval;
	mi_char		*rowptr = rowbuf;
	mi_integer	collen;
	mi_integer	rowlen;
	mi_integer	i;
	demo_data_t	*demo_data;
	mi_integer	ret;
	mi_char         sendbuf[BUFSIZ];
	mi_char         *sendbufptr = sendbuf;
	mi_char         retbuf[50];
	mi_integer      n;
	mi_char         errbuf[100];
	mi_integer      retries;

	/* ------ }}Your_Declarations (#0000) END ------ */

	/* Use the NULL connection. */
	Gen_Con = NULL;

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_update() ==================="));

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);

	/* build the replacement row */
	rowptr[0] = 'N'; /* not deleted */
	rowptr++;

	/* set the "NULL" flags */
	for (i = 0; i < demo_data->ncols; i++)
	{
	    ret = mi_value((MI_ROW *)newrow, i, (MI_DATUM *)&charptr, &collen);
	    if (ret == MI_NULL_VALUE)
	    {
	        rowptr[0] = 0;
	    }
	    else if (ret == MI_NORMAL_VALUE)
	    {
	        rowptr[0] = 1;
	    }
	    else
	    {
	        mi_db_error_raise(NULL, MI_EXCEPTION,
	          "Error getting value for column %d from update row", i);
	        /* not reached */
	        Gen_RetVal = MI_ERROR;
	        return Gen_RetVal;
	    }
	    rowptr++;

	    /* set the data fields */
	    switch(demo_data->col_type[i])
	    {
	        case DEMO_INT:
	            intval = (int)charptr;
	            charptr = (char *)&intval;
	            break;
	        case DEMO_CHAR:
	            charptr = mi_lvarchar_to_string((mi_lvarchar *)charptr);
	            break;
	        default:
	            Gen_RetVal = MI_ERROR;
	    }
	    memcpy((void*)rowptr, (void*)charptr, collen);
	    rowptr += collen;
	}

	rowlen = rowptr - rowbuf;

	/* *******************************************************************
	** ok, now we have everything we need to start the transaction: a new
	** row (neatly packed into the rowbuf variable), the pathname for the
	** file containing the row (in the demo_data structure), and the row
	** length (in the rowlen variable).
	**
	** Build an "update" transaction, and send it to the external data
	** manager. To keep this down to a single interaction with the external
	** data manager, we'll tack the content of the updated row onto this
	** buffer. That will save us having to open a separate fifo.
	** *******************************************************************
	*/
	sprintf(sendbuf, "%s 04 %d %d %s ", demo_data->fifo_path, rowlen, 
	        *rowid, demo_data->tab_path);

	/* tack on the new row */
	n = strlen(sendbuf);
	sendbufptr += n;
	memcpy(sendbufptr, rowbuf, n);
	
	/* send the transaction request */
	n = write(demo_data->ext_fd, sendbuf,  strlen(sendbuf) + 1 + rowlen);
	if (n != strlen(sendbuf) + 1 + rowlen)
	{
	    sprintf(errbuf, "Error: Tried to send %d bytes, but only sent %d",
	        strlen(sendbuf) + 1 + rowlen, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* Give the external data server a moment to respond */
	mi_yield();

	/* And read the response */
	n = retries = 0;
	while ((n == 0) && (retries < 10)) /* pick a rational number */
	{
	    retries ++;
	    /* Give the external server a moment to respond */
	    mi_yield();
 
	    n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	    retbuf[n] = '\0';
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	  mi_db_error_raise(NULL, MI_EXCEPTION,
	    "External data manager reports error writing new row.");
	  /* not reached */
	}

	Gen_RetVal = 0; 

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_update() ==================="));

	/* ------ }}Your_Code (#385C) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#VCEO) */




/* {{FUNCTION(120cce75-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_close
**
** Description:
**
**	We've been holding the UDR's fifo file and the external data
**	manager's "well known FIFO" open since our am_open
**	routine. Now we're done: Close them and delete the client FIFO.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_close (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_close
(

mi_pointer *            td,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	demo_data_t    *demo_data;

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_close() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

        /* Get the user data record. This has the FIFO's fd and pathname */
        demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);

	/* Close and unlink the client fifo */
        close(demo_data->fifo_fd);
        if (unlink(demo_data->fifo_path) < 0)
        {
          mi_db_error_raise(NULL, MI_EXCEPTION,
            "Error from demo_am_close: Unable to unlink FIFO file.");
          /* not reached */
          Gen_RetVal = -1;
        }

	/* Close the server fifo */
	close(demo_data->ext_fd);

	Gen_RetVal = 0;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_close() ==================="));

	/* ------ }}Your_Code (#1V16) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#GRJ2) */




/* {{FUNCTION(120cce7e-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_delete
**
** Description:
**
**	Implements the am_delete purpose function. We don't actually delete
**	any records, but just flag them with a "D" to indicate they're
**	deleted.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_delete (pointer,int) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_delete
(

mi_pointer *            td,

mi_integer *            rowid,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

        mi_integer      rowlen;            /* length of a row               */
        demo_data_t     *demo_data;        /* data record                   */
        mi_char         sendbuf[BUFSIZ];
        mi_char         retbuf[BUFSIZ];
        mi_string       errbuf[80];        /* for mi_db_error_raise         */
        mi_integer      n;                 /* number of bytes sent/received */
	mi_integer      retries;           /* read retry counter            */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_delete() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Get the row length */
	rowlen = demo_get_rowlength((MI_AM_TABLE_DESC *)td);

        /* Get the table information */
        demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);

        /*
        ** Build the buffer to send to the external data server. In
        ** addition to the fifo_path and the transaction code, we need
        ** to send the row length, the rowid of the record to delete, 
        ** and the pathname to the file holding the table.
        */
        sprintf(sendbuf, "%s 06 %d %d %s", demo_data->fifo_path, rowlen, 
                *rowid, demo_data->tab_path);

	n = write(demo_data->ext_fd, sendbuf, strlen(sendbuf) + 1);
	if (n != strlen(sendbuf) + 1)
	{
	    sprintf(errbuf,
	            "demo_am_delete: tried to send %d bytes, sent %d\n",
	            strlen(sendbuf) + 1, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* ************************************************************
	** Read back the response: "OK" or "ERROR"
	** ************************************************************
	*/
	n = retries = 0;
	while ((n <= 0) && (retries < 10)) /* try 10 times */
	{
	    retries++;
	    /* take a breath */
	    mi_yield();
	    n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	}

        if (strcmp(retbuf, "ERROR") == 0)
        {
          mi_db_error_raise(NULL, MI_EXCEPTION,
            "External data server reports ERROR when deleting row.");
          /* not reached */
        }

	Gen_RetVal = 0;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_delete() ==================="));

	/* ------ }}Your_Code (#8K5C) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#V256) */




/* {{FUNCTION(120cce78-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_check
**
** Description:
**
**	Implements the am_check purpose function.
**
**	Our "check" routine for the demo is pretty minimal -- we just
**	scan through the data and make sure the size of the external
**	file is a multiple of the row size.
**
**	See the VTI Programmer's Manual for a list of oncheck options that 
**	you might want to use in a production-quality implementation.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_check (pointer,integer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_check
(

mi_pointer *            td,
mi_unsigned_integer     options,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_integer	rowlen;
	demo_data_t	*demo_data;
	mi_string	sendbuf[BUFSIZ];
	mi_string	retbuf[BUFSIZ];
	mi_integer	buflen;
	mi_integer	n;
	mi_string	errbuf[100];
	mi_integer	retries;

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_check() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* Get the user data record. This has the table's pathname in it */
	demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);

	/* Get the row length for this table */
	rowlen = demo_get_rowlength((MI_AM_TABLE_DESC *)td);

	/*
	** Send the pathname and the row length to the external program.
	** The external data manager will divide the size of the file
	** holding the table data by the length of a row. If it divides
	** evenly, we'll assume everything's ok.
	*/
	sprintf(sendbuf, "%s 11 %d %s", demo_data->fifo_path, rowlen,
	        demo_data->tab_path);

	buflen = strlen(sendbuf) + 1;

	n = write(demo_data->ext_fd, sendbuf, buflen);
	if (n != buflen)
	{
	    sprintf(errbuf,
	            "demo_am_getstat: tried to send %d bytes, sent %d\n",
	            buflen, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* *******************************************************************
	** Read back the response ("OK" or "ERROR")
	** *******************************************************************
	*/
	n = retries = 0;
	while ((n <= 0) && (retries < 10)) /* try 10 times */
	{
	  retries++;
	  /* take a breath */
	  mi_yield();
	  n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	  strcpy(errbuf,
                 "am_check: External data server reports ERROR!");
	  mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	  /* not reached */
	}

	Gen_RetVal = MI_OK;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_check() ==================="));

	/* ------ }}Your_Code (#MV16) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#KFMB) */


/* {{FUNCTION(120cce72-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_getnext
**
** Description:
**
**	Implements the am_getnext purpose function.
**
**	Our am_beginscan routine told the external data server which rows we're
**	interested in. That server then retrieved the rows and wrote them to
**	a new FIFO. This routine reads rows back from the FIFO, passes them 
**	back to the server, and deletes the FIFO when done.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_getnext (pointer,pointer,pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_getnext
(
mi_pointer *            sd,               /* scan descriptor               */
mi_pointer *            retrow,
mi_pointer *            retrowid,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	MI_AM_TABLE_DESC     *td;           /* table descriptor             */
	MI_ROW_DESC          *rd;           /* row descriptor               */
	demo_data_t          *demo_data;    /* user data                    */
	mi_integer           rowlen;        /* length of a row              */
	MI_AM_QUAL_DESC      *qd;           /* qualification descriptor     */

	typedef struct in_rec
	{
	  mi_integer         rowqualified; /* 1=fully qualified, -1=not     */
	  mi_integer         rowid;        /* unique identifier for row     */
	  mi_string          rowdata[500]; /* the row itself                */
	} in_rec_t;

	in_rec_t             rowbuf;        /* row, prepended w/rowid & flag */
	mi_string            *rowptr;
	mi_string            itembuf[510];
	mi_integer           i;
	mi_integer           bound;
	fifo_t               *row_fifo;     /* fifo for rows returned        */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_getnext() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	td = mi_scan_table((MI_AM_SCAN_DESC *)sd);
	rd = mi_tab_rowdesc(td);
	qd = mi_scan_quals((MI_AM_SCAN_DESC *)sd);
	rowlen = demo_get_rowlength(td);

	row_fifo = (fifo_t *)mi_scan_userdata((MI_AM_SCAN_DESC *)sd);

	demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);
	if (!demo_data->data) /* first one, so initialize data space */
	{
	  if ((demo_data->data = (MI_DATUM *)mi_dalloc(
	    sizeof(MI_DATUM *) * demo_data->ncols,
	    PER_STATEMENT))
	    == NULL)
	  {
	    mi_db_error_raise(Gen_Con, MI_EXCEPTION,
	      "Error: Unable to allocate data space in am_getnext.");
	    /* not reached */
	    return MI_ERROR;
	  }
	}

	/* ******************************************************************
	** Read rows from the temp file and return them if they qualify. We
	** do this in an endless loop -- we'll keep reading and checking
	** rows until we either find one to return or we run out of rows.
	** ******************************************************************
	*/
	for (;;)
	{
	  if (read(row_fifo->fifo_fd, (char *)&rowbuf, (rowlen + 
	        sizeof(mi_integer) * 2)) != (rowlen + sizeof(mi_integer) * 2))
	  {
	      DPRINTF("vti_demo", 20, 
	        ("== Leaving demo_am_getnext() - No More Results =="));

	      return MI_NO_MORE_RESULTS;
	  }

	  *retrowid = (mi_pointer *)&rowbuf.rowid;

	  /* build an IDS row */
	  rowptr = rowbuf.rowdata;
	  rowptr++; /* skip past the "Not deleted" flag */

	  for (i = 0; i < demo_data->ncols; i++)
	  {

	    /* take care of the null indicator flag */
	    if (rowptr[0] == '\1')
	    {
	        demo_data->is_null[i] = MI_FALSE;
	    }
	    else
	    {
	        demo_data->is_null[i] = MI_TRUE;
	    }
	    rowptr++;

	    /* get the column value */
	    switch(demo_data->col_type[i])
	    {
	      case DEMO_INT:   bound = 4;
	                       bycopy(rowptr, (void *)&demo_data->data[i],
	                              bound);
	                       break;
	      case DEMO_CHAR:  bound = mi_column_precision(rd, i);
	                       bycopy(rowptr, itembuf, bound);
	                       itembuf[bound] = '\0';
	                       /* IDS expects string data to be  */
	                       /* encapsulated in an mi_lvarchar */
	                       demo_data->data[i] =
	                        (MI_DATUM)mi_string_to_lvarchar(itembuf);
	                       if (! demo_data->data[i])
	                       {
	                         mi_db_error_raise(Gen_Con, MI_EXCEPTION,
	                          "Error building row value to return");
	                         /* not reached */
	                         return MI_ERROR;
	                       }
	                       break;
	      default:         mi_db_error_raise(Gen_Con, MI_EXCEPTION,
	                        "Error: Unknown data column type received");
	                       /* not reached */
	                       return MI_ERROR;
	                       break;
	    }

	    rowptr += bound;
	  }

	  *retrow = mi_row_create(Gen_Con, rd, demo_data->data, 
	                            demo_data->is_null);

	  mi_tab_setuserdata(td, (void *)demo_data);

	  /* ******************************************************************
	  ** If the remote data manager wasn't able to fully qualify the row,
	  ** it set the "rowqualified" flag to -1 and returned the data for us
	  ** to evaluate here. We'll evaluate it with mi_eval_am_qual()
	  ** ******************************************************************
	  */
	  if (rowbuf.rowqualified < 0)
	  {
	    if (mi_eval_am_qual(*retrow, qd))
	    {
	      /* if the row evaluates to MI_TRUE */
	      break;
	    }
	  }
	  else
	  {
	    break;
	  }
	}

	mi_init_am_qual(qd);
	Gen_RetVal = MI_ROWS;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_getnext() ==================="));

	/* ------ }}Your_Code (#LG6U) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#E13Q) */




/* {{FUNCTION(120cce71-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_beginscan
**
** Description:
**
**	Implements the am_beginscan purpose function.
**
**	For this demo, beginscan will make a copy of the qualification 
**	descriptor, get the name/location of the file where the data is 
**	stored, build a description of a row for that table, and pass all 
**	that information to the external program that manages the data store.
**	
**	The external program will create a new fifo in /tmp and write all of
**	the qualifying rows there, then notify us that the data is there.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_beginscan (pointer) returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_beginscan
(

mi_pointer *            sd,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	demo_data_t		*demo_data;
	mi_integer 		colwidth[10];	/* column widths        */
	mi_integer              rowlen;         /* row length           */
	MI_AM_TABLE_DESC	*td;            /* table descriptor     */
	MI_ROW_DESC		*rowdesc;       /* row descriptor       */
	MI_AM_QUAL_DESC		*qd;            /* qualificaiton desc   */
	mi_char			errbuf[100];    /* error msg buffer     */
	mi_char                 data_fifo[BUFSIZ]; /* path to new fifo  */
	mi_integer              data_fifo_fd;   /* fd for new fifo      */
	fifo_t                  *row_fifo;      /* fifo info to store   */

	mi_char       sendbuf[BUFSIZ];          /* buffer to send       */
	mi_char       retbuf[BUFSIZ];           /* buffer to receive    */
	mi_char       qualbuf[BUFSIZ];          /* buffer for qd        */
	mi_char       coltypes[11];             /* column types array   */
	mi_char       nulls[11];                /* null indicator array */
	mi_integer    i;                        /* misc. counter        */
	mi_integer    n;                        /* send/receive byte count */
	mi_integer    retries;                  /* read retry counter   */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_beginscan() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* get general information about the table */
	td = mi_scan_table((MI_AM_SCAN_DESC *)sd);
	rowdesc = mi_tab_rowdesc(td);
	demo_data = mi_tab_userdata(td);         /* was init'd in am_open */
	rowlen = demo_get_rowlength(td);
	
	/* get and parse the qualification descriptor */
	qd = mi_scan_quals((MI_AM_SCAN_DESC *)sd);
	memset(qualbuf, 0, BUFSIZ);

	if (qd != NULL)
	{
	  if (demo_parse_qd(qd, rowdesc, qualbuf) < 0)
	  {
	    mi_db_error_raise(Gen_Con, MI_EXCEPTION,
		"Error from demo_parse_qd().");
	    /* not reached */
	    return MI_ERROR;
	  }
	}
	else
	{
	  strcpy(qualbuf, "null");
	}

	/* *******************************************************************
	** get the table info (number of columns, column types, column
	** lengths, null indicator flags, filename). slap this all into 
        ** a simple character buffer that will be easy to parse on the 
	** other side, and send it over the wire.
	** *******************************************************************
	*/
	i = 0;
	while (i < demo_data->ncols)
	{
	  /* get column types */
	  if (demo_data->col_type[i] == DEMO_INT)
	  {
	    coltypes[i] = 'i';
	    colwidth[i] = 4;
	  }
	  else
	  {
	    coltypes[i] = 'c';
	    colwidth[i] = mi_column_precision(rowdesc, i);
	  }
	  /* get null indicators */
	  if (demo_data->is_null[i] == MI_TRUE)
	  {
	    nulls[i] = 't';
	  }
	  else
	  {
	    nulls[i] = 'f';
	  }
	  i++;
	}
	nulls[i] = '\0';
	coltypes[i] = '\0';

	/* initialize the rest of the column width array to zeroes */
	while (i < 10)
	{
	    colwidth[i] = 0;
	    i++;
	}

	/* *******************************************************************
	** construct a "beginscan" transaction request.
	** *******************************************************************
	*/
	sprintf(sendbuf, 
               "%s 07 %d %d %d %d %d %d %d %d %d %d %d %d %s %s %s",  
                demo_data->fifo_path, rowlen, demo_data->ncols, 
                colwidth[0], colwidth[1], colwidth[2], colwidth[3], 
                colwidth[4], colwidth[5], colwidth[6], colwidth[7],
                colwidth[8], colwidth[9], nulls, coltypes, demo_data->tab_path);

	/* *******************************************************************
	** send the request to initiate the scan transaction.
	** *******************************************************************
	*/
	n = write(demo_data->ext_fd, sendbuf, strlen(sendbuf) + 1);
	if (n != strlen(sendbuf) + 1)
	{
	    sprintf(errbuf, 
	           "BeginScan error: Tried to send %d bytes, but sent %d", 
	           strlen(sendbuf) + 1, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* ******************************************************************
	** Give the external data server a moment to respond, then read 
        ** the response. We expect the response to be in the form of a
	** new fifo filename that will be used to store qualifying data
	** rows to be picked up by am_getnext() 
	** ******************************************************************
	*/
	n = retries = 0;
	while ((n <= 0) && (retries < 10)) /* try 10 times */
	{
	    retries++;
	    /* take a breath */
	    mi_yield();

	    n = demo_read_buffer(demo_data->fifo_fd, data_fifo, 0);
	}

	/* *******************************************************************
	** if the external data manager had a problem with our request, it
	** sent back "ERROR" instead of a FIFO pathname. bail out.
	** *******************************************************************
	*/
	if (strcmp(data_fifo, "ERROR") == 0)
	{
	    strcpy(errbuf, 
	      "BEGINSCAN: External data manager reports error w/trans rqst.");
	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    unlink(demo_data->fifo_path);
            mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
            /* not reached */
	}
	
	/* *******************************************************************
	** open the new FIFO, cache its fd for use by am_getnext, and write
	** our qualification struct to it. the external data manager will then
	**  write all qualifying rows out to this fifo.
	** *******************************************************************
	*/
	data_fifo_fd = open(data_fifo, O_RDWR, 0666);
	if (data_fifo_fd < 0)
	{
	    strcpy(errbuf, "BEGINSCAN: Unable to open data FIFO.");
	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    unlink(demo_data->fifo_path);
            mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
            /* not reached */
	}

	/* cache the fifo information for am_getnext */
	row_fifo = (fifo_t *)mi_dalloc(sizeof(fifo_t),
	           PER_COMMAND);

	if (row_fifo == NULL)
	{
	    strcpy(errbuf, "BEGINSCAN: Unable to allocate row_fifo.");
	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    close(data_fifo_fd);
	    unlink(demo_data->fifo_path);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	row_fifo->fifo_fd = data_fifo_fd;
	row_fifo->fifo_path = 
	               mi_dalloc(strlen(data_fifo)+1, PER_COMMAND);
	strcpy(row_fifo->fifo_path, data_fifo);

	mi_scan_setuserdata((MI_AM_SCAN_DESC *)sd, (void *)row_fifo);

	/* *******************************************************************
	** Send our ascii version of the qualification descriptor to the
	** external data manager, using the new FIFO.
	** *******************************************************************
	*/
	n = write(data_fifo_fd, qualbuf, strlen(qualbuf) + 1);
	if (n < 0)
	{
	    strcpy(errbuf, "BEGINSCAN: Unable to send parsed QD.");
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* *******************************************************************
	** Give the external data server a moment, then read back reply. 
	** We're expecting an "OK", which indicates that rows have been
	** written to our client's FIFO for processing by am_getnext().
	** *******************************************************************
	*/
	n = retries = 0;
	while ((n == 0) && (retries < 10))
	{
	    retries++;
	    mi_yield();
	    n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	}
	if ((retries >= 10) || (n == 0))
	{
	    /* all is lost. */
	    strcpy(errbuf, "BEGINSCAN: Unable to get qualifying rows.");
	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    close(data_fifo_fd);
	    unlink(demo_data->fifo_path);
	    mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	  strcpy(errbuf, 
	        "External data manager reports error qualifying rows.");
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  close(data_fifo_fd);
	  unlink(demo_data->fifo_path);
	  mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	  /* not reached */
	}

	Gen_RetVal = 0;

	DPRINTF("vti_demo", 20, 
	("================= QD is:"));
	DPRINTF("vti_demo", 20, (qualbuf));
	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_beginscan() ==================="));

	/* ------ }}Your_Code (#9SA9) END ------ */


	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#QSJB) */




/* {{FUNCTION(120cce7c-ddc9-11d0-b447-00a024e37610) (MergeSection) */

/****************************************************************
**
** Function name:
**
**	demo_am_insert
**
** Description:
**
**	Build a buffer containing the data for a new row. Negotiate
**	with the external data manager to get the row written to the
**	file holding data for the affected table.
**
** Special Comments:
**
**	Entrypoint for the SQL routine demo_am_insert (pointer,pointer,pointer)
**	returns int.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	08/21/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
** Identification:
**
** NOTE:
**
**	BladeSmith will add and remove parameters from the function
**	prototype, and will generate tracing calls.  ONLY EDIT code
**	in blocks marked  Your_<section>.  Any other  modifications
**	will require manual merging.
**
*****************************************************************
*/

UDREXPORT 
mi_integer demo_am_insert
(
mi_pointer *            td,
mi_pointer *            newrow,
mi_pointer *            newrowid,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
	MI_CONNECTION * Gen_Con;          /* The connection handle.             */
	mi_integer      Gen_RetVal;       /* The return value.                  */
	/* ------ {{Your_Declarations (PreserveSection) BEGIN ------ */

	mi_char       rowbuf[500];  /* data for the new row       */
	mi_char       *rowptr = rowbuf; /* for pointer arithmetic */
	mi_integer    collen;       /* length of a column         */
	mi_integer    rowlen;       /* length of a row            */
	mi_integer    i;            /* loop counter               */
	mi_integer    ret;          /* return value               */
	demo_data_t   *demo_data;   /* data record from td        */
	mi_char       *charptr;     /* column value               */
	mi_integer    intval;       /* integer column value       */
	mi_char       sendbuf[BUFSIZ];
	mi_char       retbuf[BUFSIZ];
	mi_integer    buflen;       /* buffer length less row data*/
	mi_integer    n;            /* byte read/write counter    */
	mi_string     errbuf[80];   /* for mi_db_error_raise()    */
	mi_integer    retries;      /* read retry counter         */
	MI_ROW_DESC   *rd;          /* row descriptor             */

	/* ------ }}Your_Declarations (#0000) END ------ */

	DPRINTF("vti_demo", 20, 
	("================= Entering demo_am_insert() ==================="));

	/* Use the NULL connection. */
	Gen_Con = NULL;

	/* ------ {{Your_Code (PreserveSection) BEGIN ------ */

	/* get all the pieces together */
	memset(rowbuf, 0, 500);
	rd = mi_tab_rowdesc((MI_AM_TABLE_DESC *)td);
	demo_data = (demo_data_t *)mi_tab_userdata((MI_AM_TABLE_DESC *)td);

	/* build the new row: mark it as "not deleted" */
	rowptr[0] = 'N';
	rowptr++;

	/* set the "NULL" flags */
	for (i = 0; i < demo_data->ncols; i++)
	{
	    ret = mi_value((MI_ROW *)newrow, i, (MI_DATUM *)&charptr, &collen);
	    if (ret == MI_NULL_VALUE)
	    {
	        rowptr[0] = 0;
	    }
	    else if (ret == MI_NORMAL_VALUE)
	    {
	        rowptr[0] = 1;
	    }
	    else
	    {
	        mi_db_error_raise(NULL, MI_EXCEPTION,
	          "Error getting value for column %d from new row", i);
	        /* not reached */
	        Gen_RetVal = MI_ERROR;
	        return Gen_RetVal;
	    }
	    rowptr++;

	    /* set the data fields */
	    switch(demo_data->col_type[i])
	    {
	        case DEMO_INT:
	            intval = (int)charptr;
	            charptr = (char *)&intval;
	            break;
	        case DEMO_CHAR:
	            charptr = mi_lvarchar_to_string((mi_lvarchar *)charptr);
	            break;
	        default:
	            Gen_RetVal = MI_ERROR;
	    }
	    memcpy((void*)rowptr, (void*)charptr, collen);
	    rowptr += collen;
	}

	rowlen = rowptr - rowbuf;

	/* *******************************************************************
	** ok, now we have everything we need to start the transaction: a new
	** row (neatly packed into the rowbuf variable), the pathname for the
	** file containing the row (in the demo_data structure), and the row
	** length (in the rowlen variable).
	**
	** Build an "insert" transaction, and send it to the external data
	** manager. We'll send the data for the row in a separate exchange.
	** *******************************************************************
	*/
	sprintf(sendbuf, "%s 03 %d %s", demo_data->fifo_path, rowlen, 
	        demo_data->tab_path);

	/* send the transaction request */
	n = write(demo_data->ext_fd, sendbuf,  strlen(sendbuf) + 1);
	if (n != strlen(sendbuf) + 1)
	{
	    sprintf(errbuf, "Error: Tried to send %d bytes, but only sent %d",
	        strlen(sendbuf) + 1, n);
	    mi_db_error_raise(NULL, MI_EXCEPTION, errbuf);
	    /* not reached */
	}

	/* Give the external data server a moment to respond */
	mi_yield();

	/* And read the response, which will be the new rowid */
	n = retries = 0;
	while ((n == 0) && (retries < 10)) /* pick a rational number */
	{
	    retries ++;
	    /* Give the external server a moment to respond */
	    mi_yield();
 
	    n = demo_read_buffer(demo_data->fifo_fd, (mi_string *)&newrowid, 0);
	}

	if (n <= 0)
	{
	    /* ***************************************************************
	    ** bummer. we didn't get the new rowid, and the external
	    ** data server is sitting waiting for us to send a row.
	    ** send an error message, just to complete the transaction,
	    ** then bail out.
	    ** ***************************************************************
	    */
	    strcpy(sendbuf, "ERROR");
	    buflen = strlen("ERROR");
	    n = write(demo_data->ext_fd, sendbuf, buflen);

	    close(demo_data->ext_fd);
	    close(demo_data->fifo_fd);
	    unlink(demo_data->fifo_path);
	    mi_db_error_raise(NULL, MI_EXCEPTION,
	      "Unable to obtain new rowid from external data manager.");
	    /* not reached */
	}

	/* *******************************************************************
	** ok, now we're ready to send the actual data 
	** *******************************************************************
	*/
	n = write(demo_data->ext_fd, rowbuf, rowlen);
	if (n != rowlen)
	{
	  sprintf(errbuf, 
	         "Error when sending data for INSERT ROW transaction.");
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  unlink(demo_data->fifo_path);
	  mi_db_error_raise(Gen_Con, MI_EXCEPTION, errbuf);
	  /* not reached */
	}

	/* Give the external data server a moment to respond */
	mi_yield();

	/* And read the response */
	n = retries = 0;
	while ((n == 0) && (retries < 10)) /* pick a rational number */
	{
	    retries ++;
	    /* Give the external server a moment to respond */
	    mi_yield();
 
	    n = demo_read_buffer(demo_data->fifo_fd, retbuf, 0);
	    retbuf[n] = '\0';
	}

	if (strcmp(retbuf, "ERROR") == 0)
	{
	  close(demo_data->ext_fd);
	  close(demo_data->fifo_fd);
	  unlink(demo_data->fifo_path);
	  mi_db_error_raise(NULL, MI_EXCEPTION,
	    "External data manager reports error writing new row.");
	  /* not reached */
	  Gen_RetVal = -1;
	}

	Gen_RetVal = 0;

	DPRINTF("vti_demo", 20, 
	("================= Leaving demo_am_insert() ==================="));

	/* ------ }}Your_Code (#IO5D) END ------ */

	/* Return the function's return value. */
	return Gen_RetVal;
}
/* }}FUNCTION (#0PKC) */

/* ***************************************************************************
** Miscellaneous Utilities
** ***************************************************************************
*/

/*
** "get rowlength" is just what it sounds like.
*/
mi_integer
demo_get_rowlength(MI_AM_TABLE_DESC *td)
{
	MI_ROW_DESC	*rd;
	mi_integer	rowlen, ncol, i;
	MI_TYPE_DESC	*typedesc;
	mi_char		*typename;
	mi_integer	bound;

	rd   = mi_tab_rowdesc(td);
	ncol = mi_column_count(rd);

	/* Add up the lengths of the columns to get the width of a row */
	for (i = 0, rowlen = 1; i < ncol; i++)
	{
	  if (! (typedesc = mi_column_typedesc(rd, i)))
	  {
	    mi_db_error_raise(NULL, MI_EXCEPTION,
		"Error calling mi_column_typedesc()");
	    /* not reached */
	    return -1;
	  }
	  if (! (typename = mi_type_typename(typedesc)))
	  {
	    mi_db_error_raise(NULL, MI_EXCEPTION,
		"Error calling mi_type_typename()");
	    /* not reached */
	    return -1;
	  }
	  if (! strncmp(typename, "integer", (size_t)7))
	  {
	    bound = 4;
          }
          else if (! strncmp(typename, "char", (size_t)4))
          {
            bound = mi_column_precision(rd, i);
	  }
	  else
	  {
	    mi_db_error_raise(NULL, MI_EXCEPTION,
		"Error: Type is neither integer no char: %s", typename);
	    /* not reached */
	    return -1;
	  }
	  rowlen += 1 + bound;
	}
	return rowlen;
}

/* ***************************************************************************
**
** demo_parse_qd
**
** This routine picks the qualification descriptor apart and builds an
** SQL-like text statement that can be passed to the external data manager.
**
** Another approach might have been to mimic the structure of the (opaque)
** qualification descriptor. We would have had to linearize (flatten) the
** structure to pass it through a fifo, then de-linearize it on on the
** other end -- a fairly involved process. For the purposes of this demo,
** the current approach works just fine.
**
** ***************************************************************************
*/
mi_integer
demo_parse_qd(MI_AM_QUAL_DESC *qd, MI_ROW_DESC *rd, char *qualbuf)
{
    mi_integer     i;                /* loop counter                        */
    mi_char        constval[80];     /* value of constant, as char string   */
    mi_char        qual_boolop[4];   /* the boolean op in a complex qd      */

    /* do we have a simple predicate here? */
    if (mi_qual_issimple(qd))
    {
      if (mi_qual_negate(qd))
      {
        sprintf(qualbuf, "%snot ", qualbuf);
      }
      sprintf(qualbuf, "%s%s", qualbuf, mi_qual_funcname(qd));

      /* get the value of the constant into a character string */
      if (demo_get_constval(qd, rd, constval) < 0)
      {
        mi_db_error_raise(NULL, MI_EXCEPTION, "Unable to get constant value.");
        /* not reached */
        return -1;
      }

      /* if args are commuted, flip them. easier for remote parser */
      if (mi_qual_commuteargs(qd))
      {
        sprintf(qualbuf, "%s (%s,%d)", qualbuf, constval, mi_qual_column(qd));
      }
      else
      {
        sprintf(qualbuf, "%s (%d,%s)", qualbuf, mi_qual_column(qd), constval);
      }
    }
    else /* qualification is complex. set the boolean operator, then */
         /* plug in the sub-qualifications.                          */
    {
      if (mi_qual_boolop(qd) == MI_BOOLOP_AND)
      {
        strcpy(qual_boolop, "and");
      }
      else
      {
        strcpy(qual_boolop, "or");
      }

      sprintf(qualbuf, "%s%s (", qualbuf, qual_boolop);
      for (i=0; i<mi_qual_nquals(qd); i++)
      {
        demo_parse_qd(mi_qual_qual(qd, i), rd, qualbuf);
        if (i < (mi_qual_nquals(qd) - 1))
        {
          strcat(qualbuf, ", ");
        }
      }
      strcat(qualbuf, ")");
    }
    return 0;
}

/* ***************************************************************************
** demo_get_constval
**
** get the constant used in a qualification. 
** ***************************************************************************
*/
mi_integer 
demo_get_constval(MI_AM_QUAL_DESC *qd, MI_ROW_DESC *rd, mi_char *constval)
{
    MI_TYPE_DESC   *typedesc;        /* to get typename                     */
    mi_char        *typename;        /* to get size ("precision")           */
    mi_smallint    colnum;           /* the column being compared to const  */

    /* what kind of column do we have here? integer or char? */
    colnum = mi_qual_column(qd);
    if (! (typedesc = mi_column_typedesc(rd, colnum)))
    {
        mi_db_error_raise(NULL, MI_EXCEPTION, 
            "Unable to get typedesc for qd column");
        /* not reached */
        return -1;
    }

    if (! (typename = mi_type_typename(typedesc)))
    {
        mi_db_error_raise(NULL, MI_EXCEPTION, 
            "Unable to get typename for qd column");
        /* not reached */
        return -1;
    }

    if (! strncmp(typename, "integer", (size_t)7))
    {
        sprintf(constval, "\"%d\"", mi_qual_constant(qd)); 
    }
    else if (! strncmp(typename, "char", (size_t)4))
    {
        sprintf(constval, "\"%s\"", mi_lvarchar_to_string(mi_qual_constant(qd)));
    }
    else
    {
        mi_db_error_raise(NULL, MI_EXCEPTION, 
            "Column type for constant in qd is neither integer nor char");
        /* not reached */
        return -1;
    }

    return 0;
}
    
/* ***************************************************************************
** demo_read_buffer()
**
** Read (possibly binary) bytes from the client FIFO, return the number
** of bytes read.
**
** Input:
**
**    fifo_fd             - file handle for FIFO to read.
**    inbuf               - buffer to fill.
**    bytes_to_read       - number of bytes to read.
**
** Output:
**
**    bytes_read          - number of bytes actually read.
**
** Synopsis:
**
**    This simple routine is meant to get around the fact that we're
**    reading from a FIFO file while the external data server is
**    writing to it. If we're reading rows of data, then bytes_to_read
**    will be the row width -- we'll know we have a full row when the
**    bytes_read is equal to that.
**
**    Sometimes we won't know how many bytes to expect. In this case,
**    bytes_to_read is set to 0 and we'll ignore it.
** ***************************************************************************
*/
mi_integer
demo_read_buffer(mi_integer fifo_fd, mi_string *inbuf, mi_integer
                 bytes_to_read)
{
    mi_integer   i = 0;               /* loop counter                       */
    mi_string    *inbuf_ptr = inbuf;  /* pointer for navigating             */
    mi_integer   tot_bytes_read = 0;  /* ongoing count of bytes read        */
    mi_integer   incr_bytes = 0;      /* incremental bytes read             */
    mi_integer   incr_btr   = 0;      /* bytes to read - bytes already read */
    mi_integer   retries;
    mi_string    incr_buf[BUFSIZ];

    if (bytes_to_read == 0)
    {
        /* *******************************************************************
        ** Don't know what to expect - just get whatever's there. We're going
        ** to use a high retry count as a failsafe, in case we don't get
        ** any data on the fifo, but we *won't* just block waiting. If we did
        ** that, the vp could block forever.
        ** *******************************************************************
        */
        retries = 100;
        while ((incr_bytes <= 0) && (retries > 0))
        {
          retries--;
          incr_bytes = read(fifo_fd, (void *)inbuf, (size_t)BUFSIZ);
        }

        if (incr_bytes > 0)
        {
          tot_bytes_read += incr_bytes;
          inbuf_ptr += incr_bytes;
        }
        else
        {
          /* something's wrong here - bail out */
          return -1;
        }

        /* *******************************************************************
        ** now read until read() returns 0 (indicating we have it all) or -1
        ** (indicating we've encountered an error), or until we've tried 
        ** another <retries> times. we do want to keep that retry switch there 
        ** or we could block the vp forever. 
        ** *******************************************************************
        */
        retries = 2;
        incr_bytes = 1; /* force the first try */
        while ((incr_bytes <= 0) && (retries > 0))
        {
            retries--;
            memset(incr_buf, 0, BUFSIZ);
            incr_bytes = read(fifo_fd, (void *)incr_buf, (size_t)BUFSIZ);
            if (incr_bytes > 0)
            {
              /* ***************************************************************
              ** Tack the temporary buffer onto the end of the input buffer.
              ** ***************************************************************
              */
              if ((tot_bytes_read = tot_bytes_read + incr_bytes) > BUFSIZ)
              {
                /* we're going to overflow the buffer. bail out */
                return -1;
              }
              memcpy(inbuf_ptr, incr_buf, incr_bytes);
              inbuf_ptr += incr_bytes;
              tot_bytes_read += incr_bytes;
            }
        }

    }
    else
    {
        /* *******************************************************************
        ** We can't assume a full row will be ready for us on the first
        ** read, so we'll grab what's there. If it's not enough, we'll
        ** do it again, up to <retries> times, accumulating as we go.
        ** This is far from perfect, but it ought to work for our purposes.
        ** *******************************************************************
        */
        incr_btr = bytes_to_read;
        retries = 2;
        i = 0;
        while ((i < retries) && (tot_bytes_read < bytes_to_read))
        {
            i++;
            /* Read into our temporary buffer */
            memset(incr_buf, 0, BUFSIZ);
            incr_bytes = read(fifo_fd, (void *)incr_buf, (size_t)incr_btr);
            if ((incr_bytes < 0) && (errno != EINTR)) /* ignore interrupts */
            {
                /* the read() failed */
                return incr_bytes;
            }

            /* ***************************************************************
            ** Bump the total count of bytes read so far, increment our
            ** retry counter, and reset incr_btr (bytes to read).
            ** ***************************************************************
            */
            if (incr_bytes > 0)
            {
              incr_btr = bytes_to_read - tot_bytes_read;
          
              /* ***************************************************************
              ** Tack the temporary buffer onto the end of the input buffer.
              ** ***************************************************************
              */
              tot_bytes_read += incr_bytes;
              if (tot_bytes_read > BUFSIZ)
              {
                /* we're going to overflow the buffer. bail out */
                return -1;
              }
              memcpy(inbuf_ptr, incr_buf, incr_bytes);
              inbuf_ptr += incr_bytes;
            }
        }   /* while */
    }   /* bytes to read <> 0 */

    return tot_bytes_read;
}

/* ***************************************************************
** This is a simple function that's called recursively by
** demo_am_scancost() to compute the relative cost of a call.
***************************************************************** */
mi_real
scancost_table_support(mi_real cost, MI_AM_QUAL_DESC *qd)
{
    mi_real    retval;
    mi_integer i;
 
    if (qd == NULL)
    {
        retval = 1.0;
        cost = retval;
    }
 
    if (mi_qual_boolop(qd) == MI_BOOLOP_AND)
    {
        for (i=0; i<mi_qual_nquals(qd); i++)
        {
            cost = cost *
                      (scancost_table_support(cost, mi_qual_qual(qd, i)));
        }
        return cost;
    }
    retval = .333;
    return(retval);
}

/* ***************************************************************************
** vti_demo_traceon(mi_integer)
**
** Turn on tracing for the vti demo. We use tracing to see the qualification
** descriptor (in its parsed, text string form), and to follow our progress
** through the various Purpose functions.
** ***************************************************************************
*/
mi_integer
vti_demo_traceon(trace_level)
    mi_integer   trace_level;
{
    mi_char      tracebuf[50];
    mi_char      tracename[20];
 
    strcpy(tracename, "/tmp/vti_demo.trc");
 
    sprintf(tracebuf, "vti_demo %d", trace_level);
 
    if (mi_tracelevel_set(tracebuf) == MI_ERROR)
    {
        return MI_ERROR;
    }
    if (mi_tracefile_set(tracename) == MI_ERROR)
    {
        return MI_ERROR;
    }
 
    return 0;
}


#ifdef __cplusplus

}

#endif
