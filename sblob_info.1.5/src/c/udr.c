/*
** Title:          sblob_info
** SCCSid:         %W% %E% %U%
** CCid:           %W% %E% %U%
** Author:         J. T. Anderson (jta@informix.com)
** Created:        Nov 14, 1997 10:28:30 AM
** Description:    This is the generated 'C' file for the sblob_info DataBlade.
** Comments:       Generated for project sblob_info.1.1
**
**                 Creates UDRs that create, update, and extract smart
**                 blob information to better understand sbspace and
**                 logical log smart blob usage.
**                 See the README file in the source code distribution.
**
** Change Notes:   1/16/98 jta: changed ifx_int8toint() calls to
**                 ifx_int8tolong().
**
**                 ifx_int8toint() corresponds to SQL SMALLINT with a
**                 range of -32,767 to 32,767.
**
**                 ifx_int8tolong() corresponds to SQL INT with a
**                 range of -2,147,483,647 to +2,147,483,647.
**
**                 Next version of this code will change all sizes to
**                 SQL int8 / mi_int8.
**
**                 8/6/1998 wwwhite: added SblobRefCount() to return the
**                 refcount for a smart blob.
**
**                 6/7/2000 wwwhite: modified to use int8 for size values,
**                 since a smartblob can be > 2GB.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "sblob_info.h"

#define TRC_CLASS  "__myErrors__"
#define TRC_LEVEL  20
#define TRC_FILE   "/tmp/sblob_info.trc"
 
#define SBSPACE   1
#define MAXBYTES  2
#define ESTBYTES  3
#define EXTSZ     4
#define SBLOG     5
#define LO_BUFSIZE 1024
 
/* function prototype */

static mi_integer Sblob_LOSPEC_INFO ARGS ((MI_CONNECTION *conn,
                MI_LO_HANDLE *slob_p, mi_integer flag,
                long *long_result, mi_string *str_result,
                mi_integer str_size, mi_int8 *int8_return_value));



/****************************************************************
**
** Function name:
**
**    SblobUpdate_3args
**
** Description:
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobUpdate (blob,integer,lvarchar) returns integer.
**
** Parameters:
**
**      slob_p      Smart blob handle.
**      size        Number of bytes (size of update).
**      options     "append" or "truncate".
**
** Return value:
**
**    mi_integer
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Modified to support sblobs > 2GB.
**
*****************************************************************
*/

UDREXPORT 
mi_integer SblobUpdate_3args
(

MI_LO_HANDLE *          slob_p,
mi_int8 *               size,
mi_lvarchar *           options,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.             */
    mi_integer      Gen_RetVal;       /* The return value.                  */

    MI_LO_FD        slob_fd;
    mi_integer      count,
                    ret,
                    lo_bufsize,
                    int_offset,
                    int_zero = 0;
    long            long_result;
    mi_int8         i8_offset,
                    i8_seekpos,
                    i8_count,
                    i8_LO_BUFSIZE,
                    i8_lo_bufsize,
                    i8_zero,
                    i8_ret;
    mi_string       lo_buffer[LO_BUFSIZE+1],
                    *options_p=NULL,
                    *r="SblobUpdate_5args",
                    i8string[41];


    /* Use the NULL connection. */
    Gen_Con = NULL;


    /* initialize the i8string buffer */
    (void)memset(i8string, '\0', sizeof(i8string));

    /*
    ** get a printable copy of the size. since size could be greater 
    ** than an integer, we'll use an ascii string.                  
    */
    if ((ifx_int8toasc(size, i8string, sizeof(i8string)-1)) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8toasc failed for size!");
    }
    
    /*
    ** we can only compare an int8 to an int8, not to an integer. so,
    ** to check for a 0 value, we need an int8 containing 0.
    */
    if ((ifx_int8cvlong(int_zero, &i8_zero)) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvlong failed for i8_zero!");
    }

    if ((ifx_int8cmp(size, &i8_zero)) != 1)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobUpdate: 'size' parameter must be > 0");
    }

    options_p = mi_lvarchar_to_string(options);
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: entering function (size=%s, options='%s')",
            r, i8string, options_p));
 
    /* Update the smart blob:
    ** 1. Get a connection handle
    ** 2. Open the lo, truncating it depending on the input options
    ** 3. If this is an append, seek to the end of the smart blob
    ** 4. Write X's into it up to the size specified
    ** 5. Cleanup
    ** 6. return MI_OK
    */
 
    /* ==== 1. Open a connection, cache the handle in the MiFparam ==== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION, "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ==== 2. Open the lo with mi_lo_open ===== */
    if(strncmp(options_p, "append", mi_get_varlen(options)) == 0 )
        slob_fd = mi_lo_open (Gen_Con, slob_p, MI_LO_WRONLY);
 
    else if(strncmp(options_p, "truncate", mi_get_varlen(options)) == 0 )
        slob_fd = mi_lo_open (Gen_Con, slob_p, MI_LO_WRONLY | MI_LO_TRUNC);
 
    else
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "Options parameter must be 'append' or 'truncate'.");
 
    if(slob_fd == MI_ERROR)
        mi_db_error_raise (NULL, MI_EXCEPTION, "mi_lo_create() failed!");

    if(slob_p == NULL)
        mi_db_error_raise (NULL, MI_EXCEPTION, "MI_LO_HANDLE is NULL!");
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: Opened smart blob.", r));
 
    /* ==== 3. Seek to end of sblob if this is an append ========= */
 
    if(strncmp(options_p, "append", mi_get_varlen(options)) == 0 )
    {
 
        /* seek to the end of the smart blob */

        int_offset=0;
 
        if ((ifx_int8cvint(int_offset, &i8_offset)) < 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8cvint failed!");
        }
 
        if ((mi_lo_seek (Gen_Con, slob_fd, &i8_offset,  MI_LO_SEEK_END,
            &i8_seekpos)) == MI_ERROR)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "mi_lo_seek failed!");
 
        /*
        ** See 1/16/98 change note in header above.
        */
        if ((ifx_int8toasc(&i8_seekpos, i8string, 40)) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8toasc failed for i8_seekpos!");
        }
 
        DPRINTF(TRC_CLASS, TRC_LEVEL, 
            ("%s: starting position for append=%s.", r, i8string));
    }
 
    /* ==== 4. Write X's into it up to the size specified */
 
    /* write the lo in 1K blocks */
    (void) memset(lo_buffer, 'X', sizeof(lo_buffer)-1);
    lo_buffer[sizeof(lo_buffer)-1]='\0';

    /* now we're going to jump through some more hoops because the size of
    ** our large object could be greater than 2GB, and, hence, would
    ** require the use of an int8.  we're going to write 1k blocks.
    **
    ** to accomodate the int8 variables, we'll need to do some conversions
    ** between mi_integer and mi_int8 values, since the two types can't
    ** be manipulated together.
    */
 
    /* get LO_BUFSIZE into an int8 */
    if ((ifx_int8cvint(LO_BUFSIZE, &i8_LO_BUFSIZE)) < 0)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvint failed for i8_LO_BUFSIZE!");
    }

    /* initialize our count of bytes written to 0, and make an int8 copy */
    count=0;

    if ((ifx_int8cvint(count, &i8_count)) < 0)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvint failed for i8_count!");
    }

    while (ifx_int8cmp(&i8_count, size) < 0)
    {
        if (ifx_int8sub(size, &i8_count, &i8_lo_bufsize) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8sub failed for i8_diff!");
        }

        /* ...if lo_bufsize > LO_BUFSIZE... */
        if (ifx_int8cmp(&i8_lo_bufsize, &i8_LO_BUFSIZE) == 1)
        {
            ifx_int8copy(&i8_LO_BUFSIZE, &i8_lo_bufsize);
        }

        if (ifx_int8tolong(&i8_lo_bufsize, &lo_bufsize) != 0)
        {

            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8tolong failed for i8_lo_bufsize!");
        }

        /* mi_lo_write() uses an mi_integer for its size parameter */
        ret = mi_lo_write (Gen_Con, slob_fd, lo_buffer, lo_bufsize);

        if (ret == MI_ERROR)
            mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_write() failed!");

        DPRINTF(TRC_CLASS, TRC_LEVEL,
            ("%s: wrote %d bytes to smart blob", r, ret));
 

        /* to increment the count, first convert ret to an int8 */
        if (ifx_int8cvlong(ret, &i8_ret) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8cvlong failed for i8_ret!");
        }

        if (ifx_int8add(&i8_count, &i8_ret, &i8_count) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8add failed for i8_ret + i8_count!");
        }

        if (ifx_int8toasc(&i8_count, i8string, 40) < 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8cvasc failed for i8_count!");
        }

    }
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: wrote %s total bytes to smart blob", r, i8string));
 
    /* ==== 5. Cleanup ==== */
    (void) mi_lo_close(Gen_Con, slob_fd);
    mi_free(options_p);
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    Gen_RetVal = MI_OK;

    /* Return the function's return value. */
    return Gen_RetVal;
}




/****************************************************************
**
** Function name:
**
**    SblobSbspace
**
** Description:
**
**      Returns the name of the sbspace in which a smart blob is stored.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobSbspace (blob) returns lvarchar.
**
** Parameters:
**
**      slob_p          smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_lvarchar
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
*/
UDREXPORT mi_lvarchar *SblobSbspace
(

MI_LO_HANDLE *          slob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
    mi_lvarchar*    Gen_RetVal;         /* The return value.           */
    MI_CONNECTION * Gen_Con;            /* The connection handle.      */

    long            long_result;        /* not used by this function   */
    mi_int8         int8_return_value;  /* not used by this function   */
    mi_string       tmp_name[129],      /* API guide says to alloc 129 */
                    *r="SblobSbspace";
    mi_lvarchar     *return_value=NULL;


    /* Use the NULL connection. */
    Gen_Con = NULL;


    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));
 
/*
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: lo handle=%s", r,
        mi_lo_to_string(slob_p)));
*/
 
    /* ===== Open a connection, cache the handle in the MiFparam ===== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    (void) Sblob_LOSPEC_INFO
    (
        Gen_Con,
        slob_p,
        SBSPACE,
        &long_result, /* not used */
        tmp_name,
        sizeof(tmp_name),
        &int8_return_value  /* not used */
    );
 
    Gen_RetVal = mi_string_to_lvarchar (tmp_name);
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));


    /* Return the function's return value. */
    return Gen_RetVal;
}




/****************************************************************
**
** Function name:
**
**    SblobStatSize
**
** Description:
**
**      Gets the size of a smart blob.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobStatSize (blob) returns int8.   
**
** Parameters:
**
**      slob_p          smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_int8
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Modified to support sblobs > 2GB.
**
*****************************************************************
*/

UDREXPORT 
mi_int8 * SblobStatSize
(
MI_LO_HANDLE *          slob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.             */
    mi_int8 *       Gen_RetVal;       /* The return value.                  */

    MI_LO_FD        slob_fd;       /* smart blob descriptor */
    MI_LO_STAT      *lostat=NULL;  /* so we can get size */
    mi_int8         ret_val;       /* slob size */
    mi_string       i8string[41];  /* string representation for debugging */
 
    mi_string       *r="SblobStatSize";

    /* Use the NULL connection. */
    Gen_Con = NULL;


    /* initialize the i8string buffer */
    (void)memset(i8string, '\0', sizeof(i8string));

    /* allocate space for Gen_RetVal */
    Gen_RetVal = (mi_int8 *)mi_alloc(sizeof(mi_int8));

    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));

    /***********************************************************
    ** Open the large object and get its size
    **
    ** 1. Open a connection to the database and cache the
    **    handle in the fparam so we don't call mi_open for
    **    each invocation of this function in a single query.
    ** 2. Open the smart blob
    ** 3. Get its size
    ** 4. Cleanup
    ************************************************************/
 
    /* ===== 1. Open a connection, cache the handle in the MiFparam ==== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobStatSize: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ===== 2. Open the smart blob ===== */
    if ((slob_fd = mi_lo_open(Gen_Con, slob_p, MI_LO_RDONLY)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_open failed.");
 
    /* ===== 3. Get its size ===================================== */
    if ((mi_lo_stat(Gen_Con, slob_fd, &lostat)) != MI_OK)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_stat failed.");
    }
 
    if (mi_lo_stat_size(lostat, &ret_val) == MI_ERROR)
    {
        (void) mi_lo_stat_free(Gen_Con, lostat);
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_stat_size failed!");
    }
 
    if (ifx_int8toasc(&ret_val, i8string, sizeof(i8string)-1) != 0)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8toasc() failed for ret_val!");
    }
 
    /* ===== 4. CLEANUP ========================================= */
    (void) mi_lo_stat_free(Gen_Con, lostat);
    (void) mi_lo_close(Gen_Con, slob_fd);
 
    DPRINTF(TRC_CLASS,TRC_LEVEL, ("%s: smart blob size = %s", r, i8string));
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    Gen_RetVal = (mi_int8 *)mi_alloc(sizeof(mi_int8));
    ifx_int8copy(&ret_val, Gen_RetVal);


    /* Return the function's return value. */
    return Gen_RetVal;
}


/****************************************************************
**
** Function name:
**
**    SblobLog
**
** Description:
**
**      Returns if the user data portion of a smart blob is logged or not.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobLog (blob) returns boolean.
**
** Parameters:
**
**      sblob_p         smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_integer    MI_TRUE or MI_FALSE
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
*****************************************************************
*/

UDREXPORT 
mi_integer SblobLog
(
MI_LO_HANDLE *          sblob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.             */
    mi_integer      Gen_RetVal;       /* The return value.                  */

    long            return_value;
    mi_int8         int8_return_value;
    mi_string       *r="SblobLog";
 

    /* Use the NULL connection. */
    Gen_Con = NULL;

    /* ------ {{Your_Code (PreserveSection) BEGIN ------ */

    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));
 
    /* ===== Open a connection, cache the handle in the MiFparam ===== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ============ get the info ============ */
    (void) Sblob_LOSPEC_INFO
    (
        Gen_Con,
        sblob_p,
        SBLOG,
        &return_value,
        NULL,   /* not used */
        0,      /* not used */
        &int8_return_value  /* not used */
    );
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    Gen_RetVal = return_value;


    /* Return the function's return value. */
    return Gen_RetVal;
}



/****************************************************************
**
** Function name:
**
**    SblobExtSize
**
** Description:
**
**      Gets the extent size for a smart blob.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobExtSize (blob) returns integer.
**
** Parameters:
**
**      sblob_p         smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_integer      The extent size.
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
*****************************************************************
*/

UDREXPORT 
mi_integer SblobExtSize
(
MI_LO_HANDLE *          sblob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.        */
    mi_integer      Gen_RetVal;       /* The return value.             */

    long            return_value;
    mi_int8         int8_return_value;
    mi_string       *r="SblobExtSize";
 

    /* Use the NULL connection. */
    Gen_Con = NULL;


    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));

    /* ===== Open a connection, cache the handle in the MiFparam ===== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ============ get the info ============ */
    (void) Sblob_LOSPEC_INFO
    (
        Gen_Con,
        sblob_p,
        EXTSZ,
        &return_value,
        NULL,   /* not used */
        0,      /* not used */
        &int8_return_value  /* not used */
    );
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    Gen_RetVal = (mi_integer)return_value;

    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: return value is: %d", r, Gen_RetVal));

    /* Return the function's return value. */
    return Gen_RetVal;
}



/****************************************************************
**
** Function name:
**
**    SblobCreate_5args
**
** Description:
**
**      Creates a smart blob, writes X's into the specified space.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobCreate (lvarchar,integer,lvarchar,integer,integer) returns blob.
**
** Parameters:
**
**      sbspace     Smart blob space name.
**      size        Size of sblob in bytes.
**      logging     "t" or "f".
**      estbytes    Estimated size in bytes.
**      maxbytes    Maximum size in bytes.
**
** Return value:
**
**    MI_LO_HANDLE
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Modified to support sblobs > 2GB.
**
*****************************************************************
*/
UDREXPORT MI_LO_HANDLE *SblobCreate_5args
(
mi_lvarchar *           sbspace,
mi_int8 *               size,
mi_lvarchar *           logging,
mi_int8 *               estbytes,
mi_int8 *               maxbytes,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
    MI_LO_HANDLE*   Gen_RetVal;       /* The return value. */
    MI_CONNECTION * Gen_Con;          /* The connection handle. */

    MI_LO_HANDLE    *slob_p = NULL;
    MI_LO_SPEC      *lo_spec_p=NULL;
    MI_LO_FD        slob_fd=0;
    mi_integer      log_mode,
                    count,
                    ret,
                    lo_bufsize,
                    int_zero = 0;
    mi_string       lo_buffer[LO_BUFSIZE+1],
                    *sbspace_p=NULL,
                    *logging_p=NULL,
                    *r="SblobCreate_5args",
                    i8string[41]; 
    mi_int8         int8_zero,
                    i8_count,
                    i8_lo_bufsize,
                    i8_LO_BUFSIZE,
                    i8_ret;

    /* Use the NULL connection. */
    Gen_Con = NULL;


    /* initialize the i8string buffer */
    (void)memset(i8string, '\0', sizeof(i8string));

    if (ifx_int8cvlong(int_zero, &int8_zero) != 0)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8cvlong() failed for int_zero!");

    /* make sure the size argument is > 0 */
    if (ifx_int8cmp(size, &int8_zero) != 1)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: 'size' parameter must be >= 0");
 
    /* get a printable ascii copy of size for debugging */
    if (ifx_int8toasc(size, i8string, sizeof(i8string)-1) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8toasc() failed for size!");
    }
        
    sbspace_p = mi_lvarchar_to_string(sbspace);
    logging_p = mi_lvarchar_to_string(logging);
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: entering function: "));

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("        sbspace='%s'", sbspace_p));

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("        size   ='%s'", i8string));

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("        logging='%s'", logging_p));

    if (ifx_int8toasc(estbytes, i8string, sizeof(i8string)-1) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8toasc() failed for estbytes!");
    }

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("        estbytes ='%s'", i8string));

    if (ifx_int8toasc(maxbytes, i8string, sizeof(i8string)-1) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8toasc() failed for maxbytes!");
    }

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("        maxbytes ='%s'", i8string));

    /* Create the smart blob:
    ** 1. Get a connection handle
    ** 2. Allocate an MI_LO_SPEC with mo_lo_spec_init()
    ** 3. Set the storage info if sbspace parameter != "default"
    ** 4. Set the logging option based on logging parameter
    ** 5. Set the estbytes
    ** 6. Set the maxbyte
    ** 7. Create the lo with mi_lo_create
    ** 8. Write X's into it up to the size specified
    ** 9. Cleanup
    ** 10. return the MI_LO_HANDLE
    */
 
    /* ==== 1. Open a connection, cache the handle in the MiFparam ==== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ==== 2. Allocate an MI_LO_SPEC with mo_lo_spec_init() ==== */
    if ((mi_lo_spec_init(Gen_Con, &lo_spec_p)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_spec_init() failed!");
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: Allocated smart blob MI_LO_SPEC.", r));
 
    /* ==== 3. Set the storage info if sbspace parameter != "default" */
    if(strncmp(sbspace_p, "default", mi_get_varlen(sbspace)) != 0 )
    {
        if ((mi_lo_specset_sbspace(lo_spec_p, sbspace_p)) == MI_ERROR)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "mi_lo_specset_sbspace() failed!");

        DPRINTF(TRC_CLASS, TRC_LEVEL,
            ("%s: Set sbspace to %s.", r, sbspace_p));
    }
    else
        DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: Did not set sbspace.", r));
 
    /* ==== 4. Set the logging option based on logging parameter ==== */
 
    if(strncmp(logging_p, "log", mi_get_varlen(logging)) == 0 )
        log_mode=LO_LOG;
 
    else if(strncmp(logging_p, "nolog", mi_get_varlen(logging)) == 0 )
        log_mode=LO_NOLOG;
 
    else
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "Logging parameter must be 'log' or 'nolog'.");
 
    if ((mi_lo_specset_flags(lo_spec_p, log_mode)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_specset_flags() failed!");
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: Set logging mode to %s.",
        r, log_mode == LO_LOG ? "LO_LOG":"LO_NOLOG"));
 
    /* ==== 5. Set the estbytes ==================== */

    if ((mi_lo_specset_estbytes(lo_spec_p, estbytes)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_specset_estbytes() failed!");
 
    if (ifx_int8toasc(estbytes, i8string, sizeof(i8string)-1) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8toasc() failed for estbytes!");
    }

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: set estbytes to %s.", r, i8string));
 
    /* ==== 6. Set the maxbytes ==================== */
 
    if ((mi_lo_specset_maxbytes(lo_spec_p, maxbytes)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_specset_maxbytes() failed!");
 
    if (ifx_int8toasc(maxbytes, i8string, sizeof(i8string)-1) != 0)
    {
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "SblobCreate: ifx_int8toasc() failed for maxbytes!");
    }

    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: set maxbytes to %s.", r, i8string));
 
    /* ==== 7. Create the lo with mi_lo_create ===== */
    slob_fd = mi_lo_create (Gen_Con, lo_spec_p, MI_LO_WRONLY, &slob_p);
    slob_fd = mi_lo_create (Gen_Con, lo_spec_p, MI_LO_WRONLY, &slob_p);

    if(slob_fd == MI_ERROR)
        mi_db_error_raise (NULL, MI_EXCEPTION, "mi_lo_create() failed!");

    if(slob_p == NULL)
        mi_db_error_raise (NULL, MI_EXCEPTION, "MI_LO_HANDLE is NULL!");
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: Created smart blob.", r));

    /* ==== 8. Write X's into the smart blob up to the size ==== */
 
    /* write the lo in 1K blocks */
    (void) memset(lo_buffer, 'X', sizeof(lo_buffer)-1);
    lo_buffer[sizeof(lo_buffer)-1]='\0';
 
    /* initialize our count of bytes written to 0, and make an int8 copy */
    count=0;

    if ((ifx_int8cvint(count, &i8_count)) < 0)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvint failed for i8_count!");
    }

    /* get LO_BUFSIZE into an int8 */
    if ((ifx_int8cvint(LO_BUFSIZE, &i8_LO_BUFSIZE)) < 0)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvint failed for i8_LO_BUFSIZE!");
    }

    while (ifx_int8cmp(&i8_count, size) < 0)
    {
        if (ifx_int8sub(size, &i8_count, &i8_lo_bufsize) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8sub failed for i8_diff!");
        }

        /* ...if lo_bufsize > LO_BUFSIZE... */
        if (ifx_int8cmp(&i8_lo_bufsize, &i8_LO_BUFSIZE) == 1)
        {
            ifx_int8copy(&i8_LO_BUFSIZE, &i8_lo_bufsize);
        }

        if (ifx_int8tolong(&i8_lo_bufsize, &lo_bufsize) != 0)
        {

            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8tolong failed for i8_lo_bufsize!");
        }

        /* mi_lo_write() uses an mi_integer for its size parameter */
        ret = mi_lo_write (Gen_Con, slob_fd, lo_buffer, lo_bufsize);

        if (ret == MI_ERROR)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "mi_lo_write() failed!");

        DPRINTF(TRC_CLASS, TRC_LEVEL,
            ("%s: wrote %d bytes to smart blob", r, ret));
 

        /* to increment the count, first convert ret to an int8 */
        if (ifx_int8cvlong(ret, &i8_ret) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8cvlong failed for i8_ret!");
        }

        if (ifx_int8add(&i8_count, &i8_ret, &i8_count) != 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8add failed for i8_ret + i8_count!");
        }

        if (ifx_int8toasc(&i8_count, i8string, sizeof(i8string)-1) < 0)
        {
            (void) mi_lo_close(Gen_Con, slob_fd);
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "ifx_int8cvasc failed for i8_count!");
        }

    }
 
    DPRINTF(TRC_CLASS, TRC_LEVEL,
        ("%s: wrote %s total bytes to smart blob", r, i8string));

    /* ==== 9. Cleanup ==== */
    (void) mi_lo_spec_free(Gen_Con, lo_spec_p);
    (void) mi_lo_close(Gen_Con, slob_fd);
    mi_free(sbspace_p);
    mi_free(logging_p);
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    Gen_RetVal = slob_p;

    /* Return the function's return value. */
    return Gen_RetVal;
}



/****************************************************************
**
** Procedure name:
**
**    SblobDebug
**
** Description:
**
**      Turns on debug to a trace file.
**
** Special Comments:
**
**      Entrypoint for the SQL routine SblobDebug (integer) returns void.
**
** Parameters:
**
**      Integer level.
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Added a trace file name and an initial DPRINTF - www
**
*****************************************************************
*/
UDREXPORT void
SblobDebug
(
mi_integer              level,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)
{
    MI_CONNECTION * Gen_Con;          /* The connection handle. */

    char            trace_set[20];


    /* Use the NULL connection. */
    Gen_Con = NULL;

    (void) memset(trace_set, 0, sizeof(trace_set));
    sprintf(trace_set, "%s %d", TRC_CLASS, level);

    if(mi_tracefile_set(TRC_FILE) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_tracefile_set failed!");

    if(mi_tracelevel_set(trace_set) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_tracelevel_set failed!");
    return;

    DPRINTF(TRC_CLASS, TRC_LEVEL, 
        ("\nSblob_Info: Trace level set to: %d\n", level));
}




/****************************************************************
**
** Function name:
**
**    SblobMaxSize
**
** Description:
**
**      Returns the maximum size specified for a smart blob.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobMaxSize (blob) returns integer.
**
** Parameters:
**
**      sblob_p         smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_int8
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Modified to support sblobs > 2GB.
**
*****************************************************************
*/

UDREXPORT 
mi_int8 * SblobMaxSize
(
MI_LO_HANDLE *          sblob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.             */
    mi_int8 *       Gen_RetVal;       /* The return value.                  */

    long            return_value;     /* convert max_bytes to int */
    mi_int8         int8_return_value;
    mi_string       *r="SblobMaxSize";


    /* Use the NULL connection. */
    Gen_Con = NULL;


    /* allocate space for Gen_RetVal */
    Gen_RetVal = (mi_int8 *)mi_alloc(sizeof(mi_int8));

    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));
 
    /* ===== Open a connection, cache the handle in the MiFparam ===== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ============ get the info ============ */
    (void) Sblob_LOSPEC_INFO
    (
        Gen_Con,
        sblob_p,
        MAXBYTES,
        &return_value, /* not used */
        NULL,   /* not used */
        0,      /* not used */
        &int8_return_value
    );
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));

    ifx_int8copy(&int8_return_value, Gen_RetVal);
 


    /* Return the function's return value. */
    return Gen_RetVal;
}




/****************************************************************
**
** Function name:
**
**    SblobEstSize
**
** Description:
**
**      Returns the estimated size for a smart blob.
**
** Special Comments:
**
**    Entrypoint for the SQL routine SblobEstSize (blob) returns integer.
**
** Parameters:
**
**      sblob_p         smart blob handle (MI_LO_HANDLE)
**
** Return value:
**
**    mi_int8
**
** History:
**
**    08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**    06/09/2000 - Modified to support sblobs > 2GB.
**
*****************************************************************
*/

UDREXPORT 
mi_int8 * SblobEstSize
(
MI_LO_HANDLE *          sblob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.             */
    mi_int8 *       Gen_RetVal;       /* The return value.                  */

    long            return_value;
    mi_int8         int8_return_value;
    mi_string       *r="SblobEstSize";


    /* Use the NULL connection. */
    Gen_Con = NULL;


    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));

    /* allocate space for Gen_RetVal */
    Gen_RetVal = (mi_int8 *)mi_alloc(sizeof(mi_int8));
 
    /* ===== Open a connection, cache the handle in the MiFparam ===== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
            mi_db_error_raise(NULL, MI_EXCEPTION,
                "Sbspace: mi_open failed");

        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }
 
    /* ============ get the info ============ */
    (void) Sblob_LOSPEC_INFO
    (
        Gen_Con,
        sblob_p,
        ESTBYTES,
        &return_value,  /* not used */
        NULL,   /* not used */
        0,      /* not used */
        &int8_return_value
    );
 
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));
 
    ifx_int8copy(&int8_return_value, Gen_RetVal);


    /* Return the function's return value. */
    return Gen_RetVal;
}
/* }}FUNCTION (#P7MC46JN) */

/****************************************************************
**
** Function name:
**
**      Sblob_LOSPEC_INFO
**
** Description:
**
**      Work-horse function that extracts info from the MI_LO_SPEC
**      structure for the entrypoint functions that need information
**      from that structure.
**
**      This is not an entrypoint function for a SQL UDR; it is a
**      local function called by the following functions:
**
**              SblobSbspace    SBSPACE
**              SblobExtSize    EXTSZ
**              SblobMaxSize    MAXBYTES
**              SblobEstSize    ESTBYTES
**              SblobLog        SBLOG
**
** Parameters:
**
**      conn            Input MI_CONNECTION handle
**      slob_p          Input MI_LO_HANDLE
**      flag            Input specifies which MI_LO_SPEC info to get
**      long_result     Output stores a long result
**      str_result      Output stores a string result
**      str_size        Input specifies allocated size of str_result
**                      (the DataBlade API guide says to alloc 129 bytes)
**      int8_result     Output stores an mi_int8 result
**
** Return value:
**
**      mi_integer      MI_OK
**
** Notes:
**      This function is admittedly not an optimal design. The original
**      intent was to avoid duplicating the code that opens the lo,
**      gets the stat structure, gets a pointer to the lo spec. It would
**      be better to just return the lospec to the caller, but you'd also
**      have to return the lostat pointer so the caller could free it.
**      Next version might clean this up.
*/
 
static
mi_integer
Sblob_LOSPEC_INFO
(
    MI_CONNECTION   *conn,
    MI_LO_HANDLE    *slob_p,
    mi_integer      flag,
    long            *long_result,
    mi_string       *str_result,
    mi_integer      str_size,
    mi_int8         *int8_result
)
{
    MI_LO_FD        slob_fd;        /* smart blob descriptor */
    MI_LO_STAT      *lostat=NULL;   /* so we can get stat struct */
    MI_LO_SPEC      *lospec=NULL;   /* so we can get info */
    mi_int8         int8_size;      /* gets converted to long_result */
 
    mi_string       *r="MI_LOSPEC_INFO",
                    *p=NULL,
                    i8string[41];
    mi_integer      lo_flags,
                    trc_level=20;


    /* initialize the i8string buffer */
    (void)memset(i8string, '\0', sizeof(i8string));
 
    switch(flag)
    {
        case SBSPACE:
                        p="sbspace name";
                        break;
        case MAXBYTES:
                        p="max sblob size";
                        break;
        case ESTBYTES:
                        p="estimated sblob size";
                        break;
        case EXTSZ :
                        p="sblob extent size";
                        break;
        case SBLOG :
                        p="sblob logged";
                        break;
        default:
                        mi_db_error_raise(NULL, MI_EXCEPTION,
                            "Sblob_LOSPEC_INFO called with unknown flag");
                        break; /* not reached, but pleases lint */
    }
 
    DPRINTF(TRC_CLASS, trc_level,
        ("%s: entering function to get %s", r, p));
 
    /***********************************************************
    ** Open the large object and get its sbspace name
    **
    ** 1. Open the smart blob
    ** 2. Get the LO_STAT structure (mi_lo_stat)
    ** 3. Get the LO_SPEC structure (mi_lo_stat_cspec)
    ** 4. Get the info, depending on flag that was passed in.
    ** 5. free lo_stat and close smart blob
    ************************************************************/
 
    /* ===== 1. Open the smart blob ===== */
    if ((slob_fd = mi_lo_open(conn, slob_p, MI_LO_RDONLY)) == MI_ERROR)
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_open failed.");
 
    /* ===== 2. Get the LO_STAT structure ======================== */
    if ((mi_lo_stat(conn, slob_fd, &lostat)) != MI_OK)
    {
        (void) mi_lo_close(conn, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_stat failed.");
    }
 
    /* ===== 3. Get the LO_SPEC structure ======================== */
    lospec = mi_lo_stat_cspec(lostat);
    if (lospec == NULL)
    {
        (void) mi_lo_stat_free(conn, lostat);
        (void) mi_lo_close(conn, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_stat_cspec failed.");
    }
 
    /* ===== 4. Get the info ===================================== */
 
    *long_result = 0;
    if (ifx_int8cvlong(*long_result, int8_result) != 0)
    {
        (void) mi_lo_stat_free(conn, lostat);
        (void) mi_lo_close(conn, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "ifx_int8cvlong() failed for long_result!");
    }
 
    switch(flag)
    {
        case SBSPACE:
            if ( (mi_lo_specget_sbspace(lospec, str_result, str_size))
                == MI_ERROR)
            {
                (void) mi_lo_stat_free(conn, lostat);
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "mi_lo_specget_sbspace failed.");
            }
 
            DPRINTF(TRC_CLASS, trc_level, ("%s: %s=%s", r, p, str_result));
            break;
 
        case MAXBYTES:
            if ( (mi_lo_specget_maxbytes(lospec, int8_result)) == MI_ERROR)
            {
                (void) mi_lo_stat_free(conn, lostat);
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "mi_lo_specget_maxbytes failed.");
            }
 
            if (ifx_int8toasc(int8_result, i8string, sizeof(i8string)-1) < 0)
            {
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "ifx_int8toasc failed for maxbytes!");
            }
 
            DPRINTF(TRC_CLASS, TRC_LEVEL,
                    ("%s: %s=%s", r, p, i8string));
            break;
 
        case ESTBYTES:
            if ( (mi_lo_specget_estbytes(lospec, int8_result)) == MI_ERROR)
            {
                (void) mi_lo_stat_free(conn, lostat);
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "mi_lo_specget_estbytes failed.");
            }
 
            if ((ifx_int8toasc(int8_result, i8string, sizeof(i8string)-1)) < 0)
            {
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "ifx_int8toasc failed for estbytes!");
            }
 
            DPRINTF(TRC_CLASS, TRC_LEVEL,
                ("%s: %s=%s", r, p, i8string));
            break;
 
        case EXTSZ :
            if ( (*long_result = mi_lo_specget_extsz(lospec)) == MI_ERROR)
            {
                DPRINTF(TRC_CLASS, TRC_LEVEL,
                    ("%s: mi_lo_specget_extsz() failed!!", r));
                (void) mi_lo_stat_free(conn, lostat);
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "mi_lo_specget_extsz failed.");
            }
 
            DPRINTF(TRC_CLASS, TRC_LEVEL,
                ("%s: %s=%ld", r, p, *long_result));
            break;

        case SBLOG :
            lo_flags = mi_lo_specget_flags(lospec);
            if(lo_flags == MI_ERROR)
            {
                (void) mi_lo_stat_free(conn, lostat);
                (void) mi_lo_close(conn, slob_fd);
                mi_db_error_raise(NULL, MI_EXCEPTION,
                    "mi_lo_specget_flags failed.");
            }
 
            if( lo_flags & LO_LOG )
                *long_result = MI_TRUE;
            else
                *long_result = MI_FALSE;

            DPRINTF(TRC_CLASS, TRC_LEVEL,
                ("%s: %s=logging is %s", r, p,
                *long_result == LO_LOG ? "LO_LOG":"LO_NOLOG"));
            break;
 
        default:
                break; /* not reached, but makes lint happy */
    }
 
 
    /* ===== 5. CLEANUP ========================================= */
    (void) mi_lo_stat_free(conn, lostat);
    (void) mi_lo_close(conn, slob_fd);
 
    DPRINTF(TRC_CLASS, trc_level, ("%s: leaving function", r));
 
    return MI_OK;
 
}

/****************************************************************
**
** Function name:
**
**      SblobRefCount
**
** Description:
**
** Special Comments:
**
**      Entrypoint for the SQL routine SblobRefCount (blob) returns integer.
**
** Parameters:
**
** Return value:
**
**      mi_integer
**
** History:
**
**      08/05/1998 - Generated by BladeSmith Version 3.60.TC1  .
**
*****************************************************************
*/

UDREXPORT
mi_integer SblobRefCount
(
MI_LO_HANDLE *          slob_p,
MI_FPARAM *             Gen_fparam        /* Standard info - see DBDK docs.*/
)

{
    MI_CONNECTION * Gen_Con;          /* The connection handle.  */
    mi_integer      Gen_RetVal;       /* The return value.       */

    MI_LO_FD        slob_fd;        /* smart blob descriptor  */
    MI_LO_STAT      *lostat=NULL;   /* so we can get refcount */
    mi_string       *r="SblobRefCount";
    mi_integer      refcount;


    /* Use the NULL connection. */
    Gen_Con = NULL;


    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: entering function", r));

    /***********************************************************
    ** Open the large object and get its refcount
    **
    ** 1. Open a connection to the database and cache the
    **    handle in the fparam so we don't call mi_open for
    **    each invocation of this function in a single query.
    ** 2. Open the smart blob
    ** 3. Get its refcount
    ** 4. Cleanup
    ************************************************************/

    /* ===== 1. Open a connection, cache the handle in the MiFparam ==== */
    Gen_Con = (MI_CONNECTION *) mi_fp_funcstate(Gen_fparam);
    if(Gen_Con == (MI_CONNECTION *)NULL) /* NULL first time UDR is called */
    {
        if ( (Gen_Con = mi_open(NULL,NULL,NULL)) == (MI_CONNECTION *)NULL)
                mi_db_error_raise(NULL, MI_EXCEPTION,
                "SblobRefCount: mi_open failed");
        mi_fp_setfuncstate (Gen_fparam, (void *) Gen_Con);
    }

    /* ===== 2. Open the smart blob ===== */
    if ((slob_fd = mi_lo_open(Gen_Con, slob_p, MI_LO_RDONLY)) == MI_ERROR)
            mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_open failed.");

    /* ===== 3. Get its refcount ===================================== */
    if ((mi_lo_stat(Gen_Con, slob_fd, &lostat)) != MI_OK)
    {
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION, "mi_lo_stat failed.");
    }

    if ((refcount = mi_lo_stat_refcnt(lostat)) == MI_ERROR)
    {
        (void) mi_lo_stat_free(Gen_Con, lostat);
        (void) mi_lo_close(Gen_Con, slob_fd);
        mi_db_error_raise(NULL, MI_EXCEPTION,
            "mi_lo_stat_refcnt failed!");
    }
    /* ===== 4. CLEANUP ========================================= */
    (void) mi_lo_stat_free(Gen_Con, lostat);
    (void) mi_lo_close(Gen_Con, slob_fd);

    DPRINTF(TRC_CLASS,TRC_LEVEL, ("%s: smart blob refcnt = %d", r, refcount));
    DPRINTF(TRC_CLASS, TRC_LEVEL, ("%s: leaving function", r));

    Gen_RetVal =  refcount;

    /* ------ }}Your_Code (#2FEN) END ------ */


    /* Return the function's return value. */
    return Gen_RetVal;
}



#ifdef __cplusplus

}

#endif
